<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../../../">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>src.common.fitting &mdash; dran v1.0 documentation</title>
      <link rel="stylesheet" type="text/css" href="../../../_static/pygments.css?v=80d5e7a1" />
      <link rel="stylesheet" type="text/css" href="../../../_static/css/theme.css?v=19f00094" />

  
  <!--[if lt IE 9]>
    <script src="../../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script src="../../../_static/jquery.js?v=5d32c60e"></script>
        <script src="../../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
        <script src="../../../_static/documentation_options.js?v=e160b93e"></script>
        <script src="../../../_static/doctools.js?v=888ff710"></script>
        <script src="../../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../../index.html" class="icon icon-home">
            dran
          </a>
              <div class="version">
                v1.0
              </div>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../extras/installation.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../extras/caveats.html">Caveats</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../extras/quickstart.html">Quickstart Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../extras/cli.html">The command line interface (CLI)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../extras/gui.html">The graphical user interface (GUI)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../extras/gui.html#the-landing-page">The landing page</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../extras/gui.html#edit-driftscan">Edit driftscan</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../extras/gui.html#edit-time-series">Edit Time series</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../extras/gui.html#view-plots">View plots</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Tutorials:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../extras/tuts/tutorials.html">Tutorials</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../extras/commands.html">Commands</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Guidelines:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../extras/changelog.html">Changelog</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../docs/modules.html">src</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">dran</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../../index.html">Module code</a></li>
      <li class="breadcrumb-item active">src.common.fitting</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for src.common.fitting</h1><div class="highlight"><pre>
<span></span><span class="kn">from</span> <span class="nn">.msgConfiguration</span> <span class="kn">import</span> <span class="n">msg_wrapper</span>
<span class="kn">from</span> <span class="nn">.plotting</span> <span class="kn">import</span> <span class="o">*</span> 

<span class="kn">from</span> <span class="nn">scipy</span> <span class="kn">import</span> <span class="n">interpolate</span>
<span class="kn">from</span> <span class="nn">sklearn.metrics</span> <span class="kn">import</span> <span class="n">mean_squared_error</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="c1"># import matplotlib.pyplot as pl</span>
<span class="kn">from</span> <span class="nn">scipy.optimize</span> <span class="kn">import</span> <span class="n">curve_fit</span>
<span class="kn">import</span> <span class="nn">sys</span>
<span class="kn">import</span> <span class="nn">bisect</span>

<span class="c1"># import warnings</span>
<span class="c1"># def fxn():</span>
<span class="c1">#     warnings.warn(&quot;deprecated&quot;, DeprecationWarning)</span>
<span class="c1"># with warnings.catch_warnings(action=&quot;ignore&quot;):</span>
<span class="c1">#     fxn()</span>


<div class="viewcode-block" id="clean_rfi">
<a class="viewcode-back" href="../../../docs/src.common.html#src.common.fitting.clean_rfi">[docs]</a>
<span class="k">def</span> <span class="nf">clean_rfi</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">log</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Clean the RFI in the data using iterative rms cuts. </span>
<span class="sd">        </span>
<span class="sd">        Parameters:</span>
<span class="sd">            x (array): Array of the independent variable</span>
<span class="sd">            y (array): Array of the dependent variable</span>
<span class="sd">            log (object): file logging object</span>

<span class="sd">        returns: </span>
<span class="sd">            finX (array): the data representing the x-axis after the removal of rfi data</span>
<span class="sd">            finY (array):the data representing the y-axis after the removal of rfi data</span>
<span class="sd">            rmsBeforeClean (int): the rms before removal of rfi data</span>
<span class="sd">            rmsAfterClean (int): the rms after removal of rfi data</span>
<span class="sd">            finspl (array): the spline of the cleaned data</span>
<span class="sd">            pointsDeleted (int): number of points deleted when cleaning the data</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">msg_wrapper</span><span class="p">(</span><span class="s2">&quot;debug&quot;</span><span class="p">,</span> <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">,</span> <span class="s2">&quot;Cleaning the data of RFI&quot;</span><span class="p">)</span>

    <span class="c1"># spline the data</span>
    <span class="n">splined_data</span> <span class="o">=</span> <span class="n">spline</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span><span class="n">log</span><span class="o">=</span><span class="n">log</span><span class="p">)</span>
    <span class="n">scanLen</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="n">resRFI</span><span class="p">,</span> <span class="n">rmsBeforeClean</span><span class="p">,</span> <span class="n">rmsAfterClean</span><span class="p">,</span> <span class="n">finX</span><span class="p">,</span> <span class="n">finY</span><span class="p">,</span> <span class="n">finRes</span><span class="p">,</span> <span class="n">finMaxSpl</span><span class="p">,</span> <span class="n">finspl</span><span class="p">,</span> <span class="n">pointsDeleted</span> <span class="o">=</span> <span class="n">clean_data</span><span class="p">(</span>
        <span class="n">splined_data</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">scanLen</span><span class="p">,</span><span class="n">log</span><span class="p">)</span>

    <span class="n">msg_wrapper</span><span class="p">(</span><span class="s2">&quot;debug&quot;</span><span class="p">,</span> <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">,</span> <span class="s2">&quot;Splined RMS before: after cleaning -&gt; </span><span class="si">{:.3f}</span><span class="s2">: </span><span class="si">{:.3f}</span><span class="s2"> </span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span>
                <span class="p">(</span><span class="n">rmsBeforeClean</span><span class="p">,</span> <span class="n">rmsAfterClean</span><span class="p">))</span>

    <span class="k">return</span> <span class="n">finX</span><span class="p">,</span> <span class="n">finY</span><span class="p">,</span> <span class="n">rmsBeforeClean</span><span class="p">,</span> <span class="n">rmsAfterClean</span><span class="p">,</span> <span class="n">finspl</span><span class="p">,</span> <span class="n">pointsDeleted</span></div>


<div class="viewcode-block" id="clean_data">
<a class="viewcode-back" href="../../../docs/src.common.html#src.common.fitting.clean_data">[docs]</a>
<span class="k">def</span> <span class="nf">clean_data</span><span class="p">(</span><span class="n">spl</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">scanLen</span><span class="p">,</span> <span class="n">log</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Clean the data using iterative fitting. </span>

<span class="sd">        Args:</span>
<span class="sd">            spl : 1d array</span>
<span class="sd">                the splined data</span>
<span class="sd">            x : 1d array</span>
<span class="sd">                data representing the x-axis</span>
<span class="sd">            y : 1d array</span>
<span class="sd">                data representing the y-axis</span>
<span class="sd">            scanLen : int</span>
<span class="sd">                length of the drift scan array</span>
<span class="sd">            log : object</span>
<span class="sd">                file logging object</span>

<span class="sd">        Returns:</span>
<span class="sd">            resRFI: 1d array</span>
<span class="sd">                the residual before the rfi has been removed</span>
<span class="sd">            rmsBeforeClean: int</span>
<span class="sd">                the rms before removing rfi data</span>
<span class="sd">            rmsAfterClean: int</span>
<span class="sd">                the rms after removal of rfi data</span>
<span class="sd">            finX: 1d array</span>
<span class="sd">                the data representing the x-axis after the removal of rfi data</span>
<span class="sd">            finY: 1d array</span>
<span class="sd">                the data representing the y-axis after the removal of rfi data</span>
<span class="sd">            finRes: 1d array</span>
<span class="sd">                the residual of the cleaned data after the rfi has been removed</span>
<span class="sd">            finMaxSpl: int</span>
<span class="sd">                the maximum of the spline of the cleaned data</span>
<span class="sd">            finspl: 1d array</span>
<span class="sd">                the spline of the cleaned data</span>
<span class="sd">            pointsDeleted: int</span>
<span class="sd">                number of points deleted when cleaning the data</span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="n">msg_wrapper</span><span class="p">(</span><span class="s2">&quot;debug&quot;</span><span class="p">,</span> <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">,</span> <span class="s2">&quot;Iterative cleaning of RFI&quot;</span><span class="p">)</span>

    <span class="c1"># calculate the residual and clean the data</span>
    <span class="n">resRFI</span><span class="p">,</span> <span class="n">rmsBeforeClean</span> <span class="o">=</span> <span class="n">calc_residual</span><span class="p">(</span><span class="n">spl</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span><span class="n">log</span><span class="p">)</span>
    <span class="n">finX</span><span class="p">,</span> <span class="n">finY</span><span class="p">,</span> <span class="n">rmsAfterClean</span><span class="p">,</span> <span class="n">finRes</span><span class="p">,</span> <span class="n">finMaxSpl</span><span class="p">,</span> <span class="n">finspl</span><span class="p">,</span> <span class="n">pointsDeleted</span> <span class="o">=</span> <span class="n">clean_data_iterative_fitting</span><span class="p">(</span>
        <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">scanLen</span><span class="p">,</span> <span class="n">resRFI</span><span class="p">,</span> <span class="n">rmsBeforeClean</span><span class="p">,</span><span class="n">log</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">resRFI</span><span class="p">,</span> <span class="n">rmsBeforeClean</span><span class="p">,</span> <span class="n">rmsAfterClean</span><span class="p">,</span> <span class="n">finX</span><span class="p">,</span> <span class="n">finY</span><span class="p">,</span> <span class="n">finRes</span><span class="p">,</span> <span class="n">finMaxSpl</span><span class="p">,</span> <span class="n">finspl</span><span class="p">,</span> <span class="n">pointsDeleted</span></div>


<div class="viewcode-block" id="calc_residual">
<a class="viewcode-back" href="../../../docs/src.common.html#src.common.fitting.calc_residual">[docs]</a>
<span class="k">def</span> <span class="nf">calc_residual</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">log</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculate the residual and rms between the model and the data.</span>

<span class="sd">        Parameters:</span>
<span class="sd">            model (array): 1D array containing the model data</span>
<span class="sd">            data (array): 1D array containing the raw data</span>
<span class="sd">            log (object): file logging object</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        res: 1d array</span>
<span class="sd">            the residual</span>
<span class="sd">        rms: int</span>
<span class="sd">            the rms value</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">res</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">model</span> <span class="o">-</span> <span class="n">data</span><span class="p">)</span>
    <span class="n">rms</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">mean_squared_error</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">model</span><span class="p">))</span>

    <span class="k">return</span> <span class="n">res</span><span class="p">,</span> <span class="n">rms</span></div>


<div class="viewcode-block" id="clean_data_iterative_fitting">
<a class="viewcode-back" href="../../../docs/src.common.html#src.common.fitting.clean_data_iterative_fitting">[docs]</a>
<span class="k">def</span> <span class="nf">clean_data_iterative_fitting</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">scanLen</span><span class="p">,</span> <span class="n">res</span><span class="p">,</span> <span class="n">rms</span><span class="p">,</span> <span class="n">log</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">,</span><span class="n">x2</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&#39;&#39;&#39; Find the best fit to the data by iteratively eliminating data points</span>
<span class="sd">    that fall beyond an established cut-off limit.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        x : 1d array</span>
<span class="sd">            data representing the x-axis</span>
<span class="sd">        y : 1d array</span>
<span class="sd">            data representing the y-axis</span>
<span class="sd">        scanLen : int</span>
<span class="sd">            length of the drift scan array</span>
<span class="sd">        res: 1d array</span>
<span class="sd">            the residual</span>
<span class="sd">        rms: int</span>
<span class="sd">            the rms value</span>
<span class="sd">        log : object</span>
<span class="sd">            file logging object</span>
<span class="sd">        x2 : 1d array</span>
<span class="sd">            filenames</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">            finalX: 1d array</span>
<span class="sd">                the data representing the x-axis after the removal of rfi data</span>
<span class="sd">            finalY: 1d array</span>
<span class="sd">                the data representing the y-axis after the removal of rfi data</span>
<span class="sd">            finalRms: int</span>
<span class="sd">                the rms after removal of rfi data</span>
<span class="sd">            finRes: 1d array</span>
<span class="sd">                the residual of the cleaned data after the rfi has been removed</span>
<span class="sd">            finMaxSpl: int</span>
<span class="sd">                the maximum of the spline of the cleaned data</span>
<span class="sd">            finalSplinedData: 1d array</span>
<span class="sd">                the spline of the cleaned data</span>
<span class="sd">            pointsDeleted: int</span>
<span class="sd">                number of points deleted when cleaning the data</span>
<span class="sd">    &#39;&#39;&#39;</span>

    <span class="c1">#msg_wrapper(&quot;debug&quot;, log.debug, &quot;Performing RFI cuts on data&quot;)</span>
    <span class="c1"># ToDo: Make this more effecient</span>

    <span class="c1"># set initial values</span>
    <span class="n">smallestY</span> <span class="o">=</span> <span class="n">y</span>
    <span class="n">smallestX</span> <span class="o">=</span> <span class="n">x</span>

    <span class="c1"># set final value parameters</span>
    <span class="n">finalNames</span><span class="o">=</span><span class="p">[]</span>
    <span class="n">finalX</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">finalY</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">finalRms</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">finalRes</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">finalMaxSpl</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">finalSplinedData</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">smallest</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="n">loop</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="k">while</span> <span class="n">smallest</span><span class="p">:</span>
        <span class="c1">#While you don&#39;t have the smallest rms, process data</span>

        <span class="n">loop</span> <span class="o">=</span> <span class="n">loop</span><span class="o">+</span><span class="mi">1</span>
        <span class="c1">#print(&#39;loop: &#39;,loop)</span>

        <span class="c1">#Remove spikes</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">x2</span><span class="p">)</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span>
            <span class="n">newX</span><span class="p">,</span> <span class="n">newY</span> <span class="o">=</span> <span class="n">_remove_RFI</span><span class="p">(</span><span class="n">smallestX</span><span class="p">,</span> <span class="n">smallestY</span><span class="p">,</span> <span class="n">res</span><span class="p">,</span> <span class="n">rms</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">newX</span><span class="p">,</span> <span class="n">newY</span> <span class="p">,</span><span class="n">newNames</span><span class="o">=</span> <span class="n">_remove_RFI</span><span class="p">(</span><span class="n">smallestX</span><span class="p">,</span> <span class="n">smallestY</span><span class="p">,</span> <span class="n">res</span><span class="p">,</span> <span class="n">rms</span><span class="p">,</span><span class="n">log</span><span class="p">,</span><span class="n">x2</span><span class="p">)</span>
            <span class="n">finalNames</span><span class="o">=</span><span class="n">newNames</span>

        <span class="n">newX</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">newX</span><span class="p">)</span>
        <span class="n">newY</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">newY</span><span class="p">)</span>
       
        <span class="c1">#spline the data if you found RFI</span>
        <span class="n">splineData2</span> <span class="o">=</span> <span class="n">spline</span><span class="p">(</span><span class="n">newX</span><span class="p">,</span> <span class="n">newY</span><span class="p">,</span><span class="n">log</span><span class="o">=</span><span class="n">log</span><span class="p">)</span>
        <span class="n">maxSplineData2</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">splineData2</span><span class="p">)</span>
        <span class="n">res2</span><span class="p">,</span> <span class="n">rms2</span> <span class="o">=</span> <span class="n">calc_residual</span><span class="p">(</span><span class="n">splineData2</span><span class="p">,</span> <span class="n">newY</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">rms2</span> <span class="o">&lt;</span> <span class="n">rms</span><span class="p">:</span>  <span class="c1"># get better values</span>
            <span class="n">rms</span> <span class="o">=</span> <span class="n">rms2</span>
            <span class="n">res</span> <span class="o">=</span> <span class="n">res2</span>
            <span class="n">smallestX</span> <span class="o">=</span> <span class="n">newX</span>
            <span class="n">smallestY</span> <span class="o">=</span> <span class="n">newY</span>
            <span class="n">finalX</span> <span class="o">=</span> <span class="n">newX</span>
            <span class="n">finalY</span> <span class="o">=</span> <span class="n">newY</span>
            <span class="n">finalRms</span> <span class="o">=</span> <span class="n">rms2</span>
            <span class="n">finalRes</span> <span class="o">=</span> <span class="n">res2</span>
            <span class="n">finalSplinedData</span> <span class="o">=</span> <span class="n">splineData2</span>
            <span class="n">finalMaxSpl</span> <span class="o">=</span> <span class="n">maxSplineData2</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">x2</span><span class="p">)</span><span class="o">!=</span><span class="mi">0</span><span class="p">:</span>
                <span class="n">finalNames</span><span class="o">=</span><span class="n">newNames</span>
            <span class="n">smallest</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">smallest</span> <span class="o">=</span> <span class="kc">False</span>

    <span class="c1"># If the rms cut only looped once, values dont change</span>
    <span class="k">if</span> <span class="n">loop</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>

        <span class="c1"># If you already have good data, keep values as they are</span>
        <span class="n">finalX</span> <span class="o">=</span> <span class="n">x</span>
        <span class="n">finalY</span> <span class="o">=</span> <span class="n">y</span>
        <span class="n">finalRms</span> <span class="o">=</span> <span class="n">rms</span>
        <span class="n">finalRes</span> <span class="o">=</span> <span class="n">res</span>

        <span class="c1">#spline the data</span>
        <span class="n">finalSplinedData</span> <span class="o">=</span> <span class="n">spline</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span><span class="n">log</span><span class="o">=</span><span class="n">log</span><span class="p">)</span>
        <span class="n">finalMaxSpl</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">finalSplinedData</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">x2</span><span class="p">)</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span>
            <span class="c1">#print(&#39;p&#39;)</span>
            <span class="n">finalNames</span><span class="o">=</span><span class="n">x2</span>

    <span class="n">pointsDeleted</span> <span class="o">=</span> <span class="n">scanLen</span><span class="o">-</span><span class="nb">len</span><span class="p">(</span><span class="n">finalY</span><span class="p">)</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">x2</span><span class="p">)</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">finalX</span><span class="p">,</span> <span class="n">finalY</span><span class="p">,</span> <span class="n">finalRms</span><span class="p">,</span> <span class="n">finalRes</span><span class="p">,</span> <span class="n">finalMaxSpl</span><span class="p">,</span> <span class="n">finalSplinedData</span><span class="p">,</span> <span class="n">pointsDeleted</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="se">\n</span><span class="si">{</span><span class="nb">abs</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">-</span><span class="nb">len</span><span class="p">(</span><span class="n">finalNames</span><span class="p">))</span><span class="si">}</span><span class="s1"> entries removed, after </span><span class="si">{</span><span class="n">loop</span><span class="si">}</span><span class="s1"> iterations</span><span class="se">\n</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">finalNames</span><span class="p">)</span><span class="si">}</span><span class="s1"> remaining</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">finalX</span><span class="p">,</span> <span class="n">finalY</span><span class="p">,</span> <span class="n">finalRms</span><span class="p">,</span> <span class="n">finalRes</span><span class="p">,</span> <span class="n">finalMaxSpl</span><span class="p">,</span> <span class="n">finalSplinedData</span><span class="p">,</span> <span class="n">pointsDeleted</span><span class="p">,</span> <span class="n">finalNames</span></div>

    
<span class="k">def</span> <span class="nf">_remove_RFI</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">res</span><span class="p">,</span> <span class="n">rms</span><span class="p">,</span> <span class="n">log</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">,</span><span class="n">x2</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">            Removes data points with a residual cutt-off</span>
<span class="sd">            more or less than 2.7*rms</span>

<span class="sd">            Parameters</span>
<span class="sd">            ----------</span>
<span class="sd">            x : 1d array</span>
<span class="sd">                data representing the x-axis</span>
<span class="sd">            y : 1d array</span>
<span class="sd">                data representing the y-axis</span>
<span class="sd">            res: 1d array</span>
<span class="sd">                the residual</span>
<span class="sd">            rms: int</span>
<span class="sd">                the rms value</span>
<span class="sd">            log : object</span>
<span class="sd">                file logging object</span>

<span class="sd">            Returns</span>
<span class="sd">            -------</span>
<span class="sd">            cleanX: 1d array</span>
<span class="sd">                array of data representing the x-axis</span>
<span class="sd">            cleanY: 1d array</span>
<span class="sd">                array of data representing the cleaned y-axis data</span>
<span class="sd">    &#39;&#39;&#39;</span>

    <span class="n">scanLen</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="n">cleanX</span><span class="p">,</span> <span class="n">cleanY</span><span class="p">,</span> <span class="n">names</span> <span class="o">=</span> <span class="p">([]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">))</span>  <span class="c1"># create new lists</span>
    <span class="n">cut</span><span class="o">=</span><span class="mi">3</span><span class="c1">#2.7</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">x2</span><span class="p">)</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">scanLen</span><span class="p">):</span>
            <span class="k">if</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">res</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">&gt;</span> <span class="n">cut</span> <span class="o">*</span> <span class="n">rms</span><span class="p">):</span>  <span class="c1"># 2.5, 2.7 3.0</span>
                <span class="k">pass</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># Keep points that lie within the cut_off</span>
                <span class="n">cleanX</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
                <span class="n">cleanY</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">y</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>

        <span class="k">return</span> <span class="n">cleanX</span><span class="p">,</span> <span class="n">cleanY</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1">#print(&#39;n&#39;)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">scanLen</span><span class="p">):</span>
            <span class="k">if</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">res</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">&gt;</span> <span class="n">cut</span><span class="o">*</span> <span class="n">rms</span><span class="p">):</span>  <span class="c1"># 2.5, 2.7 3.0</span>
                <span class="k">pass</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># Keep points that lie within the cut_off</span>
                <span class="n">cleanX</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
                <span class="n">cleanY</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">y</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
                <span class="n">names</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">x2</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>

        <span class="c1">#print(&#39;len names: &#39;,len(names))</span>
        <span class="k">return</span> <span class="n">cleanX</span><span class="p">,</span> <span class="n">cleanY</span><span class="p">,</span> <span class="n">names</span>
    
<div class="viewcode-block" id="gauss_lin">
<a class="viewcode-back" href="../../../docs/src.common.html#src.common.fitting.gauss_lin">[docs]</a>
<span class="k">def</span> <span class="nf">gauss_lin</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="o">*</span><span class="n">p</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generate a gaussian plus first-order polynomial to fit the drift </span>
<span class="sd">        scan beam. Note that the width of the Gaussian is hard-coded </span>
<span class="sd">        to the half-power beamwidth.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">            x : 1D array</span>
<span class="sd">                1D array of data representing the x-axis</span>
<span class="sd">            p : tuple</span>
<span class="sd">                tuple of gaussian parameters </span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">            gaussFit: 1d array </span>
<span class="sd">                array of data representing the gaussian fit</span>
<span class="sd">     &quot;&quot;&quot;</span>

    <span class="n">amp</span><span class="p">,</span> <span class="n">mu</span><span class="p">,</span> <span class="n">hpbw</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">c</span> <span class="o">=</span> <span class="n">p</span>
    <span class="n">sigma</span> <span class="o">=</span> <span class="n">hpbw</span><span class="o">/</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="mi">2</span><span class="p">)))</span>
    <span class="k">return</span> <span class="n">amp</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="p">(</span><span class="n">x</span><span class="o">-</span><span class="n">mu</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="o">/</span><span class="p">(</span><span class="mf">2.</span><span class="o">*</span><span class="n">sigma</span><span class="o">**</span><span class="mi">2</span><span class="p">))</span> <span class="o">+</span> <span class="n">a</span><span class="o">*</span><span class="n">x</span> <span class="o">+</span> <span class="n">c</span></div>


<div class="viewcode-block" id="spline">
<a class="viewcode-back" href="../../../docs/src.common.html#src.common.fitting.spline">[docs]</a>
<span class="k">def</span> <span class="nf">spline</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">anchor_points</span><span class="o">=</span><span class="mi">9</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span><span class="n">log</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Given a set of data points (x,y) determine a smooth spline</span>
<span class="sd">        approximation of degree k on the interval x[0] &lt;= x &lt;= x[n]</span>

<span class="sd">        Args:</span>
<span class="sd">            x (array): 1D array of data representing the x-axis</span>
<span class="sd">            y (array): 1D array of data representing the y-axis</span>
<span class="sd">            anchor_points (int): the number of anchor points in the data</span>
<span class="sd">            order (int): polynomial order to fit, preferrably a cubic spline</span>
<span class="sd">        Return:</span>
<span class="sd">            spline_fit (array): Spline of the data</span>
<span class="sd">    &#39;&#39;&#39;</span>

    <span class="k">try</span><span class="p">:</span>    
        <span class="n">msg_wrapper</span><span class="p">(</span><span class="s2">&quot;debug&quot;</span><span class="p">,</span> <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">,</span> <span class="s2">&quot;Spline the data to get estimate of underlying signal&quot;</span><span class="p">)</span>
    <span class="k">except</span><span class="p">:</span>
        <span class="k">pass</span>

    <span class="n">scanLen</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">scanLen</span> <span class="o">&lt;=</span> <span class="n">anchor_points</span><span class="o">*</span><span class="mi">2</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Too few points to interpolate, consider entering lower knot points&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;spline not set&quot;</span><span class="p">)</span>
        <span class="n">spline_fit</span><span class="o">=</span><span class="p">[]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1">#anchor_points=7</span>
        <span class="n">anchor_points_intervals</span> <span class="o">=</span> <span class="n">scanLen</span><span class="o">/</span><span class="n">anchor_points</span>  <span class="c1"># intervals where anchor points will be placed</span>
        <span class="n">anchor_points_pos</span> <span class="o">=</span> <span class="p">[]</span> <span class="c1"># list to hold positions where anchor_points will be placed olong the array</span>
        <span class="n">anchor_points_counter</span> <span class="o">=</span> <span class="mi">0</span> <span class="c1"># position counter or locator </span>

        <span class="c1"># create a list of the positions where the anchor_points will be located</span>
        <span class="c1">#anchor_points=10</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">anchor_points</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
            <span class="n">anchor_points_counter</span> <span class="o">=</span> <span class="n">anchor_points_counter</span> <span class="o">+</span> <span class="n">anchor_points_intervals</span>
            <span class="n">anchor_points_pos</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">anchor_points_counter</span><span class="p">))</span>

        <span class="c1"># interpolate the data</span>
        <span class="c1"># create linearly spaced data points</span>
        <span class="n">x1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">scanLen</span><span class="p">,</span> <span class="n">scanLen</span><span class="p">)</span>
        <span class="n">x2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">((</span><span class="n">anchor_points_pos</span><span class="p">),</span> <span class="nb">int</span><span class="p">)</span>	<span class="c1"># create array of anchor_points positions</span>
        
        <span class="k">try</span><span class="p">:</span>
            <span class="n">tck</span> <span class="o">=</span> <span class="n">interpolate</span><span class="o">.</span><span class="n">splrep</span><span class="p">(</span><span class="n">x1</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="n">order</span><span class="p">,</span> <span class="n">task</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span>
                                    <span class="n">t</span><span class="o">=</span><span class="n">x2</span><span class="p">)</span>  <span class="c1"># interpolate, k=5 is max</span>
            <span class="n">spline_fit</span> <span class="o">=</span> <span class="n">interpolate</span><span class="o">.</span><span class="n">splev</span><span class="p">(</span><span class="n">x1</span><span class="p">,</span> <span class="n">tck</span><span class="p">,</span> <span class="n">der</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Failed to interpolate, Error on input data,too few points, min required = 9&quot;</span><span class="p">)</span>
            <span class="n">spline_fit</span><span class="o">=</span><span class="n">y</span>

    <span class="k">return</span> <span class="n">spline_fit</span><span class="c1">#,anchor_points_pos</span></div>


<div class="viewcode-block" id="spline_fit">
<a class="viewcode-back" href="../../../docs/src.common.html#src.common.fitting.spline_fit">[docs]</a>
<span class="k">def</span> <span class="nf">spline_fit</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">anchor_points</span><span class="o">=</span><span class="mi">9</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="mi">3</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Given a set of data points (x,y) determine a smooth spline</span>
<span class="sd">        approximation of degree k on the interval x[0] &lt;= x &lt;= x[n]</span>

<span class="sd">        Args:</span>
<span class="sd">            x (array): 1D array of data representing the x-axis</span>
<span class="sd">            y (array): 1D array of data representing the y-axis</span>
<span class="sd">            anchor_points (int): the number of anchor points in the data</span>
<span class="sd">            order (int): polynomial order to fit, preferrably a cubic spline</span>
<span class="sd">        Return:</span>
<span class="sd">            spline_fit (array): Spline of the data</span>
<span class="sd">    &#39;&#39;&#39;</span>

    <span class="n">nx</span><span class="o">=</span><span class="p">[]</span>
    <span class="n">ny</span><span class="o">=</span><span class="p">[]</span>
    <span class="c1"># remove nan values</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)):</span>
        <span class="c1">#print(i,y[i],type(y[i]))</span>
        <span class="k">if</span> <span class="n">y</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span> <span class="ow">or</span> <span class="nb">str</span><span class="p">(</span><span class="n">y</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">==</span><span class="s2">&quot;nan&quot;</span><span class="p">:</span>
            <span class="c1">#print(i,y[i])</span>
            <span class="k">pass</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">nx</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
            <span class="n">ny</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">y</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>

    <span class="n">scanLen</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">nx</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">scanLen</span> <span class="o">&lt;=</span> <span class="n">anchor_points</span><span class="o">*</span><span class="mi">2</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Too few points to interpolate, consider entering lower knot points&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;spline not set&quot;</span><span class="p">)</span>
        <span class="n">spline_fit</span><span class="o">=</span><span class="p">[]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1">#anchor_points=7</span>
        <span class="n">anchor_points_intervals</span> <span class="o">=</span> <span class="n">scanLen</span><span class="o">/</span><span class="n">anchor_points</span>  <span class="c1"># intervals where anchor points will be placed</span>
        <span class="n">anchor_points_pos</span> <span class="o">=</span> <span class="p">[]</span> <span class="c1"># list to hold positions where anchor_points will be placed olong the array</span>
        <span class="n">anchor_points_counter</span> <span class="o">=</span> <span class="mi">0</span> <span class="c1"># position counter or locator </span>

        <span class="c1"># create a list of the positions where the anchor_points will be located</span>
        <span class="c1">#anchor_points=10</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">anchor_points</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
            <span class="n">anchor_points_counter</span> <span class="o">=</span> <span class="n">anchor_points_counter</span> <span class="o">+</span> <span class="n">anchor_points_intervals</span>
            <span class="n">anchor_points_pos</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">anchor_points_counter</span><span class="p">))</span>

        <span class="c1"># interpolate the data</span>
        <span class="c1"># create linearly spaced data points</span>
        <span class="n">x1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">scanLen</span><span class="p">,</span> <span class="n">scanLen</span><span class="p">)</span>
        <span class="n">x2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">((</span><span class="n">anchor_points_pos</span><span class="p">),</span> <span class="nb">int</span><span class="p">)</span>	<span class="c1"># create array of anchor_points positions</span>
        
        <span class="k">try</span><span class="p">:</span>
            <span class="n">tck</span> <span class="o">=</span> <span class="n">interpolate</span><span class="o">.</span><span class="n">splrep</span><span class="p">(</span><span class="n">x1</span><span class="p">,</span> <span class="n">ny</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="n">order</span><span class="p">,</span> <span class="n">task</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span>
                                    <span class="n">t</span><span class="o">=</span><span class="n">x2</span><span class="p">)</span>  <span class="c1"># interpolate, k=5 is max</span>
            <span class="n">spline_fit</span> <span class="o">=</span> <span class="n">interpolate</span><span class="o">.</span><span class="n">splev</span><span class="p">(</span><span class="n">x1</span><span class="p">,</span> <span class="n">tck</span><span class="p">,</span> <span class="n">der</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Failed to interpolate, Error on input data,too few points, min required = 9&quot;</span><span class="p">)</span>
            <span class="n">spline_fit</span><span class="o">=</span><span class="n">ny</span>

        <span class="c1">#print(len(x),len(spline_fit))</span>
        <span class="c1">#print(spline_fit)</span>
    <span class="c1">#     pl.plot(x,y,&#39;k.&#39;)</span>
    <span class="c1">#     pl.plot(nx,spline_fit,&#39;r&#39;)</span>
    <span class="c1">#    # pl.plot(nx[anchor_points_pos],spline_fit[anchor_points_pos],&#39;r.&#39;)</span>
    <span class="c1">#     pl.show()</span>
    <span class="c1">#     pl.close()</span>
    <span class="c1">#     print(&#39;closed&#39;)</span>
    <span class="c1">#     sys.exit()</span>
    <span class="k">return</span> <span class="n">nx</span><span class="p">,</span><span class="n">spline_fit</span><span class="c1">#,anchor_points_pos</span></div>


<div class="viewcode-block" id="gauss">
<a class="viewcode-back" href="../../../docs/src.common.html#src.common.fitting.gauss">[docs]</a>
<span class="k">def</span> <span class="nf">gauss</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="o">*</span><span class="n">p</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Gaussian for fitting the beam </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">amp</span><span class="p">,</span> <span class="n">mu</span><span class="p">,</span> <span class="n">hpbw</span> <span class="o">=</span> <span class="n">p</span>
        <span class="n">sigma</span> <span class="o">=</span> <span class="n">hpbw</span><span class="o">/</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="mi">2</span><span class="p">)))</span>  <span class="c1">#a bit messy but not sure how to pass a constant through the curve fitting</span>
        <span class="k">return</span> <span class="n">amp</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="p">(</span><span class="n">x</span><span class="o">-</span><span class="n">mu</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="o">/</span><span class="p">(</span><span class="mf">2.</span><span class="o">*</span><span class="n">sigma</span><span class="o">**</span><span class="mi">2</span><span class="p">))</span></div>


<div class="viewcode-block" id="test_gauss_fit">
<a class="viewcode-back" href="../../../docs/src.common.html#src.common.fitting.test_gauss_fit">[docs]</a>
<span class="k">def</span> <span class="nf">test_gauss_fit</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">p0</span><span class="p">,</span><span class="n">log</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Fit the data using a gaussian</span>

<span class="sd">        Arguments:</span>
<span class="sd">            p0: initial fit guess</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># fit initial guess parameters to data and get best fit parameters</span>
        <span class="c1"># returns best fit coeffecients and errors</span>
        <span class="c1"># Curve fitting is a type of optimization that finds an optimal set </span>
        <span class="c1"># of parameters for a defined function that best fits a given set of observations.</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">coeff</span><span class="p">,</span> <span class="n">covarMatrix</span> <span class="o">=</span> <span class="n">curve_fit</span><span class="p">(</span><span class="n">gauss_lin</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span> <span class="n">p0</span><span class="p">)</span>
            <span class="n">fit</span> <span class="o">=</span> <span class="n">gauss_lin</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="o">*</span><span class="n">coeff</span><span class="p">)</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">msg_wrapper</span><span class="p">(</span><span class="s2">&quot;info&quot;</span><span class="p">,</span> <span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;Passed gaussian fit test, Max peak =  </span><span class="si">{</span><span class="nb">max</span><span class="p">(</span><span class="n">fit</span><span class="p">)</span><span class="si">:</span><span class="s2">.3f</span><span class="si">}</span><span class="s2"> [K]&quot;</span><span class="p">)</span>
            <span class="k">except</span><span class="p">:</span>
                <span class="k">pass</span>
            <span class="k">return</span> <span class="n">coeff</span><span class="p">,</span><span class="n">fit</span><span class="p">,</span><span class="s2">&quot;&quot;</span>
        
        <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="n">e</span><span class="p">)</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">msg_wrapper</span><span class="p">(</span><span class="s2">&quot;warning&quot;</span><span class="p">,</span> <span class="n">log</span><span class="o">.</span><span class="n">warning</span><span class="p">,</span> <span class="s2">&quot;gaussian curve_fit algorithm failed&quot;</span><span class="p">)</span>
            <span class="k">except</span><span class="p">:</span>
                <span class="k">pass</span>

            <span class="n">flag</span><span class="o">=</span><span class="mi">3</span>
            <span class="k">return</span> <span class="p">[],[],</span><span class="n">flag</span></div>

        
<div class="viewcode-block" id="test_position_validity">
<a class="viewcode-back" href="../../../docs/src.common.html#src.common.fitting.test_position_validity">[docs]</a>
<span class="k">def</span> <span class="nf">test_position_validity</span><span class="p">(</span><span class="n">localMaxPositions</span><span class="p">,</span><span class="n">localMinPositions</span><span class="p">,</span><span class="n">maxPoints</span><span class="p">):</span>
<span class="w">            </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Test the position validity of the local min/max positions. The </span>
<span class="sd">            local minimum positions cannot fall within the range of the </span>
<span class="sd">            local maximum positions.</span>

<span class="sd">            Args:</span>
<span class="sd">                localMaxPositions (list): list of local max positions</span>
<span class="sd">                localMinPositions (list): list of local min positions</span>
<span class="sd">                p (int): maximum number of permissable points.</span>
<span class="sd">            Returns:</span>
<span class="sd">                pointsToDelete: index list of positions to delete</span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="n">pointsToDelete</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">halfMaxPoints</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="n">maxPoints</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">localMaxPositions</span><span class="p">)):</span>
                <span class="c1"># create list of max positions bounded by the condition</span>
                <span class="n">window</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">localMaxPositions</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-</span><span class="n">halfMaxPoints</span><span class="p">,</span><span class="n">localMaxPositions</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">+</span><span class="n">halfMaxPoints</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">localMinPositions</span><span class="p">)):</span>
                    <span class="k">if</span> <span class="n">localMinPositions</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="ow">in</span> <span class="n">window</span><span class="p">:</span>
                        <span class="nb">print</span><span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="n">localMinPositions</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">localMaxPositions</span><span class="p">[</span><span class="n">i</span><span class="p">])</span><span class="c1">#, window)</span>
                        <span class="n">pointsToDelete</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">localMinPositions</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="p">)</span>
            <span class="k">return</span> <span class="n">pointsToDelete</span></div>


<div class="viewcode-block" id="locate_baseline_blocks_auto">
<a class="viewcode-back" href="../../../docs/src.common.html#src.common.fitting.locate_baseline_blocks_auto">[docs]</a>
<span class="k">def</span> <span class="nf">locate_baseline_blocks_auto</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">peakCenterGuess</span><span class="p">,</span> <span class="n">hfnbw</span><span class="p">,</span><span class="n">log</span><span class="p">,</span><span class="n">saveLoc</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Find the locations to fit a baseline automatically.</span>

<span class="sd">        These locations are found/determined by fitting a </span>
<span class="sd">        spline to the data and using the </span>
<span class="sd">        locations of the local minimum as baseline regions.</span>

<span class="sd">        Parameters:</span>
<span class="sd">            peakCenterGuess (float): value of x at peak center in x array</span>
<span class="sd">            hfnbw (float): half the first null beam width</span>
<span class="sd">            log (object): loffing object</span>
<span class="sd">        &quot;&quot;&quot;</span>
         
        <span class="c1"># setup parameters</span>
        <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span> <span class="c1"># message to write on plot</span>
        <span class="n">flag</span> <span class="o">=</span> <span class="mi">0</span> <span class="c1"># error flag, default to no error detected </span>

        <span class="c1"># generate a spline to help locate where to best fit our baseline model.</span>
        <span class="n">yspl</span> <span class="o">=</span> <span class="n">spline</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span><span class="n">log</span><span class="o">=</span><span class="n">log</span><span class="p">)</span>

        <span class="c1"># find location of maximum peak, assumed to be at center</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">peakPosition</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">x</span> <span class="o">&gt;=</span> <span class="n">peakCenterGuess</span><span class="p">)[</span><span class="mi">0</span><span class="p">])[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">peakSpline</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">yspl</span> <span class="o">==</span> <span class="nb">max</span><span class="p">(</span><span class="n">yspl</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;Failed to determine center peak location&quot;</span>
            <span class="n">msg_wrapper</span><span class="p">(</span><span class="s2">&quot;warning&quot;</span><span class="p">,</span><span class="n">log</span><span class="o">.</span><span class="n">warning</span><span class="p">,</span><span class="n">msg</span><span class="p">)</span>
            <span class="n">flag</span> <span class="o">=</span> <span class="mi">22</span>
            <span class="k">return</span> <span class="p">[],</span> <span class="p">[],</span> <span class="p">[],</span> <span class="mi">0</span><span class="p">,</span> <span class="n">flag</span><span class="p">,</span> <span class="n">msg</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span>
     
        <span class="c1"># LOCATE LOCAL MINUMUM/MAXIMUM POSITIONS</span>
        <span class="c1"># these values are used to figure out where to</span>
        <span class="c1"># select our baseline points/locations for</span>
        <span class="n">msg_wrapper</span><span class="p">(</span><span class="s2">&quot;debug&quot;</span><span class="p">,</span><span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">,</span><span class="s1">&#39;Locate local min and max positions&#39;</span><span class="p">)</span>
        <span class="n">localMinPositions</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sign</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">yspl</span><span class="p">)))</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">nonzero</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span>  <span class="c1"># local min positions / first nulls</span>
        <span class="n">localMaxPositions</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sign</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">yspl</span><span class="p">)))</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">nonzero</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span>  <span class="c1"># local max positions / peak</span>

        <span class="n">msg</span><span class="o">=</span><span class="sa">f</span><span class="s1">&#39;Found positions of possible local mins at: </span><span class="si">{</span><span class="n">localMinPositions</span><span class="si">}</span><span class="s1">, and local maxs at: </span><span class="si">{</span><span class="n">localMaxPositions</span><span class="si">}</span><span class="s1">&#39;</span>
        <span class="n">msg_wrapper</span><span class="p">(</span><span class="s2">&quot;debug&quot;</span><span class="p">,</span><span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">,</span><span class="n">msg</span><span class="p">)</span>
        
        <span class="c1"># get maximum of driftscan</span>
        <span class="n">ymax</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">yspl</span><span class="p">)</span>
        
        <span class="c1"># Delete local min point within 50 points of either side of a local max point from the positions found above</span>
        <span class="n">maxPoints</span><span class="o">=</span><span class="mi">50</span> 
        <span class="n">pointsToDelete</span><span class="o">=</span><span class="n">test_position_validity</span><span class="p">(</span><span class="n">localMaxPositions</span><span class="p">,</span><span class="n">localMinPositions</span><span class="p">,</span><span class="n">maxPoints</span><span class="p">)</span>

        <span class="c1"># If any invalid points found, delete them</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">pointsToDelete</span><span class="p">)</span><span class="o">!=</span><span class="mi">0</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">pointsToDelete</span><span class="p">)):</span>
                <span class="k">if</span> <span class="n">pointsToDelete</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="ow">in</span> <span class="n">localMinPositions</span><span class="p">:</span>
                    <span class="n">localMinPositions</span><span class="o">=</span><span class="nb">list</span><span class="p">(</span><span class="n">localMinPositions</span><span class="p">)</span>
                    <span class="n">ind</span><span class="o">=</span><span class="n">localMinPositions</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">pointsToDelete</span><span class="p">[</span><span class="n">k</span><span class="p">])</span>
                    <span class="k">del</span> <span class="n">localMinPositions</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span>

        <span class="c1">#ensure that the points are in an array</span>
        <span class="n">localMinPositions</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">localMinPositions</span><span class="p">)</span>
        <span class="n">msg</span><span class="o">=</span><span class="sa">f</span><span class="s1">&#39;After validating points, the accepted positions for -&gt; Min locs: </span><span class="si">{</span><span class="n">localMinPositions</span><span class="si">}</span><span class="s1">, and Max locs: </span><span class="si">{</span><span class="n">localMaxPositions</span><span class="si">}</span><span class="s1">&#39;</span>
        <span class="n">msg_wrapper</span><span class="p">(</span><span class="s2">&quot;debug&quot;</span><span class="p">,</span><span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">,</span><span class="n">msg</span><span class="p">)</span>
        
        <span class="c1"># if len(localMinPositions)=0 try to establish other possible locations</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">localMinPositions</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">:</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;- Failed to locate local min positions, set to FNBW locs&quot;</span>
            <span class="n">msg_wrapper</span><span class="p">(</span><span class="s2">&quot;warning&quot;</span><span class="p">,</span> <span class="n">log</span><span class="o">.</span><span class="n">warning</span><span class="p">,</span> <span class="n">msg</span><span class="p">)</span>
            <span class="n">flag</span> <span class="o">=</span> <span class="mi">21</span>
            <span class="c1"># sys.exit()</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">h</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">x</span><span class="o">&lt;=-</span><span class="n">hfnbw</span><span class="p">)[</span><span class="mi">0</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                <span class="nb">print</span><span class="p">(</span><span class="n">h</span><span class="p">)</span>
            <span class="k">except</span><span class="p">:</span>
                <span class="n">h</span><span class="o">=</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            
            <span class="k">try</span><span class="p">:</span>
                <span class="c1">#TODO write better notes on why i do this</span>
                <span class="n">hh</span><span class="o">=</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">x</span><span class="o">&gt;=</span><span class="n">hfnbw</span><span class="p">)[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]][</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">except</span><span class="p">:</span>
                <span class="n">hh</span><span class="o">=</span><span class="n">x</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

            <span class="n">localMinPositions</span><span class="o">=</span><span class="p">[</span><span class="n">h</span><span class="p">,</span><span class="n">hh</span><span class="p">]</span>

        <span class="c1"># if len(localMinPositions) still = 0 and len(localMaxPositions) == 0</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">localMinPositions</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">localMaxPositions</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;Failed to locate local min and max positions&quot;</span>
            <span class="n">msg_wrapper</span><span class="p">(</span><span class="s2">&quot;warning&quot;</span><span class="p">,</span> <span class="n">log</span><span class="o">.</span><span class="n">warning</span><span class="p">,</span> <span class="n">msg</span><span class="p">)</span>
            <span class="n">flag</span> <span class="o">=</span> <span class="mi">19</span>
            <span class="c1"># print(msg)</span>
            <span class="c1"># sys.exit()</span>
            <span class="k">return</span> <span class="p">[],</span> <span class="p">[],</span> <span class="p">[],</span> <span class="mi">1</span><span class="p">,</span> <span class="n">flag</span><span class="p">,</span> <span class="n">msg</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span>

        <span class="c1"># localMinPositions must be = 2, number of local minimum positions found</span>
        <span class="c1"># IF MORE ARE FOUND WE MOST PROBABLY HAVE SIDELOBES</span>
        <span class="n">numberOfMinPositions</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">localMinPositions</span><span class="p">)</span>

        <span class="c1"># Find the index or insertion point for the peakPosition in the</span>
        <span class="c1"># locMinPositions list. i.e. where we most likely expect the </span>
        <span class="c1"># peak to be located.</span>
        <span class="n">peakInd</span> <span class="o">=</span> <span class="n">bisect</span><span class="o">.</span><span class="n">bisect</span><span class="p">(</span><span class="n">localMinPositions</span><span class="p">,</span> <span class="n">peakPosition</span><span class="p">)</span>
        <span class="n">scanLen</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>

        <span class="c1"># basic parameter info</span>
        <span class="n">msg_wrapper</span><span class="p">(</span><span class="s2">&quot;debug&quot;</span><span class="p">,</span> <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">,</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="n">msg_wrapper</span><span class="p">(</span><span class="s2">&quot;debug&quot;</span><span class="p">,</span> <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">,</span> <span class="s2">&quot;-&quot;</span><span class="o">*</span><span class="mi">30</span><span class="p">)</span>
        <span class="n">msg_wrapper</span><span class="p">(</span><span class="s2">&quot;debug&quot;</span><span class="p">,</span> <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">,</span><span class="s2">&quot;Drift scan basic info: &quot;</span><span class="p">)</span>
        <span class="n">msg_wrapper</span><span class="p">(</span><span class="s2">&quot;debug&quot;</span><span class="p">,</span> <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">,</span><span class="s2">&quot;-&quot;</span><span class="o">*</span><span class="mi">30</span><span class="p">)</span>
        <span class="n">msg_wrapper</span><span class="p">(</span><span class="s2">&quot;debug&quot;</span><span class="p">,</span> <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">,</span><span class="sa">f</span><span class="s2">&quot;Found local minimums at = </span><span class="si">{</span><span class="n">localMinPositions</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="n">msg_wrapper</span><span class="p">(</span><span class="s2">&quot;debug&quot;</span><span class="p">,</span> <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">,</span><span class="sa">f</span><span class="s2">&quot;Found local maximums at = </span><span class="si">{</span><span class="n">localMaxPositions</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="n">msg_wrapper</span><span class="p">(</span><span class="s2">&quot;debug&quot;</span><span class="p">,</span> <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;no. of local min positions = </span><span class="si">{</span><span class="n">numberOfMinPositions</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="n">msg_wrapper</span><span class="p">(</span><span class="s1">&#39;debug&#39;</span><span class="p">,</span> <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;index of peak in local mins = </span><span class="si">{</span><span class="n">peakInd</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span> <span class="c1"># i.e. if peak were inserted  between the local mins, what would its index be</span>
    
        <span class="c1"># check location of peak</span>
        <span class="n">msg_wrapper</span><span class="p">(</span><span class="s2">&quot;debug&quot;</span><span class="p">,</span> <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">,</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="n">msg_wrapper</span><span class="p">(</span><span class="s2">&quot;debug&quot;</span><span class="p">,</span> <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">,</span> <span class="s2">&quot;-&quot;</span><span class="o">*</span><span class="mi">20</span><span class="p">)</span>
        <span class="n">msg_wrapper</span><span class="p">(</span><span class="s2">&quot;debug&quot;</span><span class="p">,</span> <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">,</span> <span class="s2">&quot;Peak locations: &quot;</span><span class="p">)</span>
        <span class="n">msg_wrapper</span><span class="p">(</span><span class="s2">&quot;debug&quot;</span><span class="p">,</span> <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">,</span> <span class="s2">&quot;-&quot;</span><span class="o">*</span><span class="mi">20</span><span class="p">)</span>
        <span class="n">msg_wrapper</span><span class="p">(</span><span class="s2">&quot;debug&quot;</span><span class="p">,</span> <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;Peak pos from Gauss fit: </span><span class="si">{</span><span class="n">peakPosition</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="n">msg_wrapper</span><span class="p">(</span><span class="s2">&quot;debug&quot;</span><span class="p">,</span> <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;Peak pos from Spline fit: </span><span class="si">{</span><span class="n">peakSpline</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="n">msg_wrapper</span><span class="p">(</span><span class="s2">&quot;debug&quot;</span><span class="p">,</span> <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;Peak pos if at mid of scan: </span><span class="si">{</span><span class="nb">int</span><span class="p">(</span><span class="n">scanLen</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="c1"># Ensure peak falls within expected range, beyond 25% of the beginning of the drift scan and</span>
        <span class="c1"># below 75% of the end of the drift scan.</span>
        <span class="n">peakLocMinLimit</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">scanLen</span><span class="o">*</span><span class="mf">.25</span><span class="p">)</span>
        <span class="n">peakLocMaxLimit</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">scanLen</span><span class="o">*</span><span class="mf">.75</span><span class="p">)</span>
        
        <span class="c1"># If the code has struggled to locate the local min/max,</span>
        <span class="k">if</span> <span class="p">(</span> <span class="n">peakPosition</span> <span class="o">&lt;</span> <span class="n">peakLocMinLimit</span> <span class="ow">or</span> <span class="n">peakPosition</span> <span class="o">&gt;</span> <span class="n">peakLocMaxLimit</span> <span class="p">):</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;Peak not within expected range.&quot;</span>
            <span class="n">msg_wrapper</span><span class="p">(</span><span class="s2">&quot;info&quot;</span><span class="p">,</span> <span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">,</span> <span class="n">msg</span><span class="p">)</span>
            <span class="n">flag</span><span class="o">=</span><span class="mi">20</span>
            <span class="n">msg_wrapper</span><span class="p">(</span><span class="s2">&quot;info&quot;</span><span class="p">,</span> <span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;Peak limit left: </span><span class="si">{</span><span class="n">peakLocMinLimit</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="n">msg_wrapper</span><span class="p">(</span><span class="s2">&quot;info&quot;</span><span class="p">,</span> <span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;Peak position: </span><span class="si">{</span><span class="n">peakPosition</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span> 
            <span class="n">msg_wrapper</span><span class="p">(</span><span class="s2">&quot;info&quot;</span><span class="p">,</span> <span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;Peak limit right: </span><span class="si">{</span><span class="n">peakLocMaxLimit</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="c1"># sys.exit()</span>
            <span class="k">return</span> <span class="p">[],[],[],</span><span class="mi">1</span><span class="p">,</span><span class="n">flag</span><span class="p">,</span><span class="n">msg</span><span class="p">,[],[],</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span>

        <span class="k">else</span><span class="p">:</span>

            <span class="c1"># locate/setup fnbw location on left and right of beam</span>
            <span class="c1"># if we can&#39;t locate base locations program defaults</span>
            <span class="c1"># to fnbw locations</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">leftFNBWPoint</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">x</span> <span class="o">&gt;=</span> <span class="p">(</span><span class="n">peakCenterGuess</span><span class="o">-</span><span class="n">hfnbw</span><span class="p">))[</span><span class="mi">0</span><span class="p">])[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">except</span><span class="p">:</span>
                <span class="n">leftFNBWPoint</span> <span class="o">=</span> <span class="mi">0</span>

            <span class="k">try</span><span class="p">:</span>
                <span class="n">rightFNBWPoint</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">x</span> <span class="o">&gt;=</span> <span class="p">(</span><span class="n">peakCenterGuess</span><span class="o">+</span><span class="n">hfnbw</span><span class="p">))[</span><span class="mi">0</span><span class="p">])[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">except</span><span class="p">:</span>
                <span class="n">rightFNBWPoint</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">rightFNBWPoint</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="ow">or</span> <span class="n">leftFNBWPoint</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">flag</span><span class="o">=</span><span class="mi">27</span>
                <span class="n">msg</span><span class="o">=</span><span class="s2">&quot;Failed to locate FNBW locations&quot;</span>
                <span class="n">msg_wrapper</span><span class="p">(</span><span class="s2">&quot;info&quot;</span><span class="p">,</span> <span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">,</span> <span class="n">msg</span><span class="p">)</span>
                <span class="c1"># print(msg)</span>
                <span class="c1"># sys.exit()</span>
                <span class="k">return</span> <span class="p">[],</span> <span class="p">[],</span> <span class="p">[],</span> <span class="mi">1</span><span class="p">,</span> <span class="n">flag</span><span class="p">,</span> <span class="n">msg</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span>

            <span class="c1"># msg_wrapper(&quot;debug&quot;, log.debug, &quot;\n&quot;)</span>
            <span class="n">msg_wrapper</span><span class="p">(</span><span class="s2">&quot;debug&quot;</span><span class="p">,</span> <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">,</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="n">msg_wrapper</span><span class="p">(</span><span class="s2">&quot;debug&quot;</span><span class="p">,</span> <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">,</span> <span class="s2">&quot;-&quot;</span><span class="o">*</span><span class="mi">20</span><span class="p">)</span>
            <span class="n">msg_wrapper</span><span class="p">(</span><span class="s2">&quot;debug&quot;</span><span class="p">,</span> <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">,</span> <span class="s2">&quot;Locate/setup location of FNBW: &quot;</span><span class="p">)</span>
            <span class="n">msg_wrapper</span><span class="p">(</span><span class="s2">&quot;debug&quot;</span><span class="p">,</span> <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">,</span> <span class="s2">&quot;-&quot;</span><span class="o">*</span><span class="mi">20</span><span class="p">)</span>
            
            <span class="n">msg_wrapper</span><span class="p">(</span><span class="s2">&quot;debug&quot;</span><span class="p">,</span> <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;FNBW: </span><span class="si">{</span><span class="n">hfnbw</span><span class="o">*</span><span class="mi">2</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span> 
            <span class="n">msg_wrapper</span><span class="p">(</span><span class="s2">&quot;debug&quot;</span><span class="p">,</span> <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;HFNBW: </span><span class="si">{</span><span class="n">hfnbw</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span> 
            <span class="n">msg_wrapper</span><span class="p">(</span><span class="s2">&quot;debug&quot;</span><span class="p">,</span> <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;left fnbw loc: </span><span class="si">{</span><span class="n">leftFNBWPoint</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span> 
            <span class="n">msg_wrapper</span><span class="p">(</span><span class="s2">&quot;debug&quot;</span><span class="p">,</span> <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;right fnbw loc: </span><span class="si">{</span><span class="n">rightFNBWPoint</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

            
            <span class="c1"># SEARCH FOR MINIMUMS</span>
            <span class="c1"># We only need two points, one on left of peak and one on right of peak</span>
            <span class="c1"># if we have more points this means there are side lobes and we</span>
            <span class="c1"># need to adjust the baseline accordingly</span>
            <span class="n">msg_wrapper</span><span class="p">(</span><span class="s2">&quot;debug&quot;</span><span class="p">,</span> <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">,</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="n">msg_wrapper</span><span class="p">(</span><span class="s2">&quot;debug&quot;</span><span class="p">,</span> <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">,</span> <span class="s2">&quot;-&quot;</span><span class="o">*</span><span class="mi">20</span><span class="p">)</span>
            <span class="n">msg_wrapper</span><span class="p">(</span><span class="s2">&quot;debug&quot;</span><span class="p">,</span> <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">,</span> <span class="s2">&quot;Finding locations of local minimum from scan: &quot;</span><span class="p">)</span>
            <span class="n">msg_wrapper</span><span class="p">(</span><span class="s2">&quot;debug&quot;</span><span class="p">,</span> <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">,</span> <span class="s2">&quot;-&quot;</span><span class="o">*</span><span class="mi">20</span><span class="p">)</span>
            
            <span class="c1"># set fault parameters</span>
            <span class="n">rf</span> <span class="o">=</span> <span class="mi">0</span>  <span class="c1"># right is faulty rf=1</span>
            <span class="n">lf</span> <span class="o">=</span> <span class="mi">0</span>  <span class="c1"># left is faulty lf=1</span>
            
            <span class="k">if</span> <span class="n">peakInd</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">localMinPositions</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="c1"># there is only one peak index position found</span>

                <span class="n">msg_wrapper</span><span class="p">(</span><span class="s2">&quot;debug&quot;</span><span class="p">,</span> <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">,</span> <span class="sa">f</span><span class="s1">&#39;peak ind: </span><span class="si">{</span><span class="n">peakInd</span><span class="si">}</span><span class="s1">, local min pos: </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">localMinPositions</span><span class="p">)</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>

                <span class="k">if</span> <span class="n">localMinPositions</span><span class="p">[</span><span class="n">peakInd</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">peakPosition</span><span class="p">:</span>
                    <span class="c1"># the position found is to the left of the assumed peak location</span>

                    <span class="n">minPosOnLeftOfPeak</span> <span class="o">=</span> <span class="n">localMinPositions</span>
                    <span class="n">minPosOnRightOfPeak</span> <span class="o">=</span> <span class="n">rightFNBWPoint</span>
                    
                    <span class="n">flag</span> <span class="o">=</span> <span class="mi">6</span>
                    <span class="n">rf</span> <span class="o">=</span> <span class="mi">1</span>
                    <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;Failed to locate right min pos&quot;</span>
                    <span class="n">msg_wrapper</span><span class="p">(</span><span class="s2">&quot;info&quot;</span><span class="p">,</span> <span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">,</span><span class="n">msg</span><span class="p">)</span>
                    <span class="n">msg_wrapper</span><span class="p">(</span><span class="s2">&quot;debug&quot;</span><span class="p">,</span> <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">,</span>
                                <span class="s2">&quot;leftMinLoc found: </span><span class="si">{}</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">minPosOnLeftOfPeak</span><span class="p">))</span>
                    <span class="n">msg_wrapper</span><span class="p">(</span><span class="s2">&quot;debug&quot;</span><span class="p">,</span> <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">,</span> <span class="s2">&quot;setting rightMinLoc: </span><span class="si">{}</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                        <span class="n">minPosOnRightOfPeak</span><span class="p">))</span>

                <span class="k">if</span> <span class="n">localMinPositions</span><span class="p">[</span><span class="n">peakInd</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">peakPosition</span><span class="p">:</span>
                    <span class="c1"># the position found is to the right of the assumed peak location</span>

                    <span class="n">minPosOnLeftOfPeak</span> <span class="o">=</span> <span class="n">leftFNBWPoint</span>
                    <span class="n">minPosOnRightOfPeak</span> <span class="o">=</span> <span class="n">localMinPositions</span>
                    

                    <span class="n">flag</span> <span class="o">=</span> <span class="mi">7</span>
                    <span class="n">lf</span> <span class="o">=</span> <span class="mi">1</span>
                    <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;Failed to locate left min pos&quot;</span>
                    <span class="n">msg_wrapper</span><span class="p">(</span><span class="s2">&quot;info&quot;</span><span class="p">,</span> <span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">,</span><span class="n">msg</span><span class="p">)</span>
                    <span class="n">msg_wrapper</span><span class="p">(</span><span class="s2">&quot;debug&quot;</span><span class="p">,</span> <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">,</span><span class="s2">&quot;setting leftMinLoc: </span><span class="si">{}</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">minPosOnLeftOfPeak</span><span class="p">))</span>
                    <span class="n">msg_wrapper</span><span class="p">(</span><span class="s2">&quot;debug&quot;</span><span class="p">,</span> <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">,</span><span class="s2">&quot;rightMinLoc found: </span><span class="si">{}</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                        <span class="n">minPosOnRightOfPeak</span><span class="p">))</span>

            <span class="k">elif</span> <span class="n">peakInd</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">localMinPositions</span><span class="p">):</span>
                <span class="n">msg_wrapper</span><span class="p">(</span><span class="s2">&quot;debug&quot;</span><span class="p">,</span> <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">,</span> <span class="sa">f</span><span class="s1">&#39;peak ind &lt; local min pos: </span><span class="si">{</span><span class="n">peakInd</span><span class="si">}</span><span class="s1"> &lt; </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">localMinPositions</span><span class="p">)</span><span class="si">}</span><span class="s1">; i.e. one peak, 2 or more local mins&#39;</span> <span class="p">)</span>
                
                <span class="k">if</span> <span class="p">(</span><span class="n">localMinPositions</span><span class="p">[</span><span class="n">peakInd</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">peakPosition</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">localMinPositions</span><span class="p">[</span><span class="n">peakInd</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">peakPosition</span><span class="p">):</span>
                    
                    <span class="c1"># grab all the local min positions to the left and right of the peak</span>
                    <span class="n">minPosOnLeftOfPeak</span> <span class="o">=</span> <span class="n">localMinPositions</span><span class="p">[:</span><span class="n">peakInd</span><span class="p">]</span>
                    <span class="n">minPosOnRightOfPeak</span> <span class="o">=</span> <span class="n">localMinPositions</span><span class="p">[</span><span class="n">peakInd</span><span class="p">:]</span>
        
                    <span class="n">msg_wrapper</span><span class="p">(</span><span class="s2">&quot;debug&quot;</span><span class="p">,</span> <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">,</span><span class="sa">f</span><span class="s2">&quot;all leftMinLoc: </span><span class="si">{</span><span class="n">minPosOnLeftOfPeak</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                    <span class="n">msg_wrapper</span><span class="p">(</span><span class="s2">&quot;debug&quot;</span><span class="p">,</span> <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">,</span><span class="sa">f</span><span class="s2">&quot;all rightMinLoc: </span><span class="si">{</span><span class="n">minPosOnRightOfPeak</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">minPosOnLeftOfPeak</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="c1"># there are no left min positons, set left min to fnbw point</span>
                        <span class="n">minPosOnLeftOfPeak</span> <span class="o">=</span> <span class="n">leftFNBWPoint</span>
                        <span class="n">flag</span> <span class="o">=</span> <span class="mi">7</span>
                        <span class="n">lf</span> <span class="o">=</span> <span class="mi">1</span>
                        <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;Failed to locate left min pos&quot;</span>
                        <span class="n">msg_wrapper</span><span class="p">(</span><span class="s2">&quot;info&quot;</span><span class="p">,</span> <span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">,</span> <span class="n">msg</span><span class="p">)</span>

                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">minPosOnRightOfPeak</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="c1"># there are no right min positions, set right min to fnbw point</span>
                        <span class="n">minPosOnRightOfPeak</span> <span class="o">=</span> <span class="n">rightFNBWPoint</span>
                        <span class="n">flag</span> <span class="o">=</span> <span class="mi">6</span>
                        <span class="n">rf</span> <span class="o">=</span> <span class="mi">1</span>
                        <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;Failed to locate right min pos&quot;</span>
                        <span class="n">msg_wrapper</span><span class="p">(</span><span class="s2">&quot;info&quot;</span><span class="p">,</span> <span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">,</span> <span class="n">msg</span><span class="p">)</span>
                
            <span class="k">else</span><span class="p">:</span>
                
                <span class="k">if</span> <span class="n">localMinPositions</span><span class="p">[</span><span class="n">peakInd</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">peakPosition</span><span class="p">:</span>
                    <span class="c1"># can&#39;t find local mins beyond peak</span>

                    <span class="n">minPosOnLeftOfPeak</span> <span class="o">=</span> <span class="n">localMinPositions</span><span class="p">[:</span><span class="n">peakInd</span><span class="p">]</span>
                    <span class="n">minPosOnRightOfPeak</span> <span class="o">=</span> <span class="n">rightFNBWPoint</span>
                    

                    <span class="n">flag</span> <span class="o">=</span> <span class="mi">6</span>
                    <span class="n">rf</span> <span class="o">=</span> <span class="mi">1</span>
                    <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;Failed to locate right min pos&quot;</span>
                    <span class="nb">print</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
                    <span class="n">msg_wrapper</span><span class="p">(</span><span class="s2">&quot;info&quot;</span><span class="p">,</span> <span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">,</span><span class="n">msg</span><span class="p">)</span>
                    <span class="n">msg_wrapper</span><span class="p">(</span><span class="s2">&quot;debug&quot;</span><span class="p">,</span> <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">,</span><span class="s2">&quot;leftMinLoc: </span><span class="si">{}</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">minPosOnLeftOfPeak</span><span class="p">))</span>
                    <span class="n">msg_wrapper</span><span class="p">(</span><span class="s2">&quot;debug&quot;</span><span class="p">,</span> <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">,</span><span class="s2">&quot;rightMinLoc: </span><span class="si">{}</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                        <span class="n">minPosOnRightOfPeak</span><span class="p">))</span>

                <span class="k">if</span> <span class="n">localMinPositions</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">peakPosition</span><span class="p">:</span>
                    <span class="c1"># all local mins are beyond peak</span>

                    <span class="n">minPosOnLeftOfPeak</span> <span class="o">=</span> <span class="n">leftFNBWPoint</span>
                    <span class="n">minPosOnRightOfPeak</span> <span class="o">=</span> <span class="n">localMinPositions</span>
                    

                    <span class="n">flag</span> <span class="o">=</span> <span class="mi">7</span>
                    <span class="n">lf</span> <span class="o">=</span> <span class="mi">1</span>
                    <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;Failed to locate left min pos&quot;</span>
                    <span class="n">msg_wrapper</span><span class="p">(</span><span class="s2">&quot;info&quot;</span><span class="p">,</span> <span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">,</span><span class="n">msg</span><span class="p">)</span>
                    <span class="n">msg_wrapper</span><span class="p">(</span><span class="s2">&quot;debug&quot;</span><span class="p">,</span> <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">,</span>
                                <span class="s2">&quot;setting leftMinLocs : </span><span class="si">{}</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">minPosOnLeftOfPeak</span><span class="p">))</span>
                    <span class="n">msg_wrapper</span><span class="p">(</span><span class="s2">&quot;debug&quot;</span><span class="p">,</span> <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">,</span> <span class="s2">&quot;rightMinLoc beyond peak: </span><span class="si">{}</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                        <span class="n">minPosOnRightOfPeak</span><span class="p">))</span>

            <span class="c1"># Determine if data has large sidelobes by evaluating the region</span>
            <span class="c1"># around the center peak</span>
            <span class="n">maxPosInMaxs</span> <span class="o">=</span> <span class="n">localMaxPositions</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">localMaxPositions</span><span class="o">-</span><span class="n">peakPosition</span><span class="p">)</span><span class="o">.</span><span class="n">argmin</span><span class="p">()]</span>
            <span class="n">indOfmaxPosInMaxs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">localMaxPositions</span> <span class="o">==</span> <span class="n">maxPosInMaxs</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>

            <span class="n">msg_wrapper</span><span class="p">(</span><span class="s2">&quot;debug&quot;</span><span class="p">,</span> <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">,</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="n">msg_wrapper</span><span class="p">(</span><span class="s2">&quot;debug&quot;</span><span class="p">,</span> <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">,</span> <span class="s2">&quot;-&quot;</span><span class="o">*</span><span class="mi">20</span><span class="p">)</span>
            <span class="n">msg_wrapper</span><span class="p">(</span><span class="s2">&quot;debug&quot;</span><span class="p">,</span> <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">,</span> <span class="s2">&quot;Searching for sidelobes&quot;</span><span class="p">)</span>
            <span class="n">msg_wrapper</span><span class="p">(</span><span class="s2">&quot;debug&quot;</span><span class="p">,</span> <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">,</span> <span class="s2">&quot;-&quot;</span><span class="o">*</span><span class="mi">20</span><span class="p">)</span>
            
            <span class="n">msg_wrapper</span><span class="p">(</span><span class="s2">&quot;debug&quot;</span><span class="p">,</span> <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;local max positions: </span><span class="si">{</span><span class="n">localMaxPositions</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="n">msg_wrapper</span><span class="p">(</span><span class="s2">&quot;debug&quot;</span><span class="p">,</span> <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;maxPosInMaxs: </span><span class="si">{</span><span class="n">maxPosInMaxs</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="n">msg_wrapper</span><span class="p">(</span><span class="s2">&quot;debug&quot;</span><span class="p">,</span> <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;IndexOfMaxPos: </span><span class="si">{</span><span class="n">indOfmaxPosInMaxs</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="n">msg_wrapper</span><span class="p">(</span><span class="s2">&quot;debug&quot;</span><span class="p">,</span> <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;lenmaxpos: </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">localMaxPositions</span><span class="p">)</span><span class="si">}</span><span class="s2"> &quot;</span><span class="p">)</span>

            <span class="n">sidelobes</span> <span class="o">=</span> <span class="mi">0</span>  <span class="c1"># data contains no sidelobes</span>
            

            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">localMaxPositions</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="c1"># theres more than one peak</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">localMaxPositions</span><span class="p">)</span> <span class="o">==</span> <span class="n">indOfmaxPosInMaxs</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
                    <span class="n">leftSidelobe</span> <span class="o">=</span> <span class="n">localMaxPositions</span><span class="p">[</span><span class="n">indOfmaxPosInMaxs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                    <span class="n">rightSidelobe</span> <span class="o">=</span> <span class="n">localMaxPositions</span><span class="p">[</span><span class="n">indOfmaxPosInMaxs</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">indOfmaxPosInMaxs</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">localMaxPositions</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">:</span>
                        <span class="n">leftSidelobe</span> <span class="o">=</span> <span class="n">localMaxPositions</span><span class="p">[</span><span class="n">indOfmaxPosInMaxs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                        <span class="n">rightSidelobe</span> <span class="o">=</span> <span class="p">[]</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">leftSidelobe</span> <span class="o">=</span> <span class="n">localMaxPositions</span><span class="p">[</span><span class="n">indOfmaxPosInMaxs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                        <span class="n">rightSidelobe</span> <span class="o">=</span> <span class="n">localMaxPositions</span><span class="p">[</span><span class="n">indOfmaxPosInMaxs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span>

                <span class="n">maxPeakInSpline</span> <span class="o">=</span> <span class="n">yspl</span><span class="p">[</span><span class="n">maxPosInMaxs</span><span class="p">]</span>
                <span class="n">halfOfMaxPeakInSpline</span> <span class="o">=</span> <span class="mf">0.5</span><span class="o">*</span><span class="n">maxPeakInSpline</span>

                <span class="c1"># check if sidelobes are larger than half the peak</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">yspl</span><span class="p">[</span><span class="n">leftSidelobe</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">halfOfMaxPeakInSpline</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">yspl</span><span class="p">[</span><span class="n">rightSidelobe</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">halfOfMaxPeakInSpline</span><span class="p">):</span>

                    <span class="c1"># large sidelobes detected</span>
                    <span class="n">msg_wrapper</span><span class="p">(</span><span class="s2">&quot;info&quot;</span><span class="p">,</span> <span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">,</span> <span class="s2">&quot;Large sidelobes detected: </span><span class="si">{}</span><span class="s2"> &lt; </span><span class="si">{}</span><span class="s2"> &lt; </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                        <span class="n">yspl</span><span class="p">[</span><span class="n">leftSidelobe</span><span class="p">],</span> <span class="n">maxPeakInSpline</span><span class="p">,</span> <span class="n">yspl</span><span class="p">[</span><span class="n">rightSidelobe</span><span class="p">]))</span>
                    <span class="n">sidelobes</span> <span class="o">=</span> <span class="mi">1</span>
                    <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;Large sidelobes detected&quot;</span>
                    <span class="n">flag</span> <span class="o">=</span> <span class="mi">9</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">msg_wrapper</span><span class="p">(</span><span class="s2">&quot;info&quot;</span><span class="p">,</span> <span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">,</span> <span class="s2">&quot;No sidelobes detected, moving on&quot;</span><span class="p">)</span>


            <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">localMaxPositions</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">msg_wrapper</span><span class="p">(</span><span class="s2">&quot;info&quot;</span><span class="p">,</span> <span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">,</span> <span class="s2">&quot;Passed sidelobe check: No sidelobes detected</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">msg_wrapper</span><span class="p">(</span><span class="s2">&quot;info&quot;</span><span class="p">,</span> <span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">,</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Failed to locate a maximum&quot;</span><span class="p">)</span>
                <span class="n">sys</span><span class="o">.</span><span class="n">exit</span><span class="p">()</span>

            <span class="n">maxloc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">yspl</span><span class="o">==</span><span class="nb">max</span><span class="p">(</span><span class="n">yspl</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span>
            <span class="c1">#print(maxloc,maxloc[0],len(yspl),yspl[0],yspl[-1])</span>
            
            <span class="c1"># Make sure peak lies within FNBW window or points</span>
            <span class="k">if</span> <span class="n">maxloc</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">leftFNBWPoint</span> <span class="ow">or</span> <span class="n">maxloc</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">&gt;</span> <span class="n">rightFNBWPoint</span><span class="p">:</span>
                <span class="c1"># found peak in noise</span>
                <span class="n">msg_wrapper</span><span class="p">(</span><span class="s2">&quot;info&quot;</span><span class="p">,</span> <span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">,</span><span class="s2">&quot;peak found in baselocs&quot;</span><span class="p">)</span>
                <span class="c1"># sys.exit()</span>
                <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;peak found in baselocs&quot;</span>
                <span class="n">flag</span> <span class="o">=</span> <span class="mi">16</span>

                <span class="c1"># we have sidelobes</span>
                <span class="c1"># find local min positions ----------------------------------------</span>
                <span class="n">locminpos</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sign</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">yspl</span><span class="p">)))</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">nonzero</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span>
                <span class="n">baseLine</span><span class="p">,</span> <span class="n">leftBaselineBlock</span><span class="p">,</span> <span class="n">rightBaselineBlock</span><span class="p">,</span> <span class="n">minPosOnLeftOfPeak</span><span class="p">,</span> <span class="n">minPosOnRightOfPeak</span><span class="p">,</span> <span class="n">lp</span><span class="p">,</span> <span class="n">rp</span> <span class="o">=</span> <span class="n">get_base</span><span class="p">(</span>
                    <span class="n">locminpos</span><span class="p">,</span><span class="nb">int</span><span class="p">((</span><span class="n">scanLen</span><span class="o">*</span><span class="mf">.05</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
                    <span class="c1">#locminpos, int((scanLen*.05)/2), len(x)), # why 5% ???</span>
                <span class="c1"># ----------------------------------------------------------------</span>

                <span class="c1">#print(lp, rp)</span>

                <span class="c1"># pl.plot(x,y)</span>
                <span class="c1"># pl.plot(x,yspl)</span>
                <span class="c1"># pl.plot(x[leftBaselineBlock], y[leftBaselineBlock], &#39;b.&#39;)</span>
                <span class="c1"># pl.plot(x[rightBaselineBlock],y[rightBaselineBlock],&#39;m.&#39;)</span>
                <span class="c1"># pl.plot(x[lp], y[lp], &#39;k.&#39;)</span>
                <span class="c1"># pl.plot(x[rp],y[rp],&#39;k*&#39;)</span>
                <span class="c1"># pl.plot(x[minPosOnLeftOfPeak],yspl[minPosOnLeftOfPeak],&quot;y*&quot;)</span>
                <span class="c1"># pl.plot(x[minPosOnRightOfPeak], yspl[minPosOnRightOfPeak], &quot;r*&quot;)</span>
                <span class="c1"># pl.show()</span>
                <span class="c1"># pl.close()</span>
                <span class="c1"># sys.exit()</span>
                <span class="n">sidelobes</span><span class="o">=</span><span class="mi">1</span>
                <span class="c1">#sys.exit()</span>
                <span class="k">return</span> <span class="n">baseLine</span><span class="p">,</span> <span class="n">leftBaselineBlock</span><span class="p">,</span> <span class="n">rightBaselineBlock</span><span class="p">,</span> <span class="n">sidelobes</span><span class="p">,</span> <span class="n">flag</span><span class="p">,</span> <span class="n">msg</span><span class="p">,</span> <span class="n">minPosOnLeftOfPeak</span><span class="p">,</span> <span class="n">minPosOnRightOfPeak</span><span class="p">,</span><span class="n">lp</span><span class="p">,</span><span class="n">rp</span>
                <span class="c1">#return [],[],[],1,flag,msg,[],[],0,0</span>

            <span class="k">else</span><span class="p">:</span>

                <span class="c1"># Check if you returned anything: sanity check</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="nb">type</span><span class="p">(</span><span class="n">minPosOnRightOfPeak</span><span class="p">)</span>
                    <span class="c1"># check you are returned something, dummy check</span>
        
                <span class="k">except</span><span class="p">:</span>
                    <span class="n">flag</span><span class="o">=</span><span class="mi">6</span>
                    <span class="n">msg</span><span class="o">=</span><span class="s2">&quot;Failed to locate right min pos&quot;</span>
                    <span class="n">msg_wrapper</span><span class="p">(</span><span class="s2">&quot;info&quot;</span><span class="p">,</span> <span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">,</span> <span class="n">msg</span><span class="p">)</span>
                    <span class="k">return</span> <span class="p">[],</span> <span class="p">[],</span> <span class="p">[],</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="n">flag</span><span class="p">,</span> <span class="n">msg</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="p">[],</span> <span class="p">[]</span>

                <span class="k">try</span><span class="p">:</span>
                    <span class="c1"># check you are returned something, dummy check</span>
                    <span class="nb">type</span><span class="p">(</span><span class="n">minPosOnLeftOfPeak</span><span class="p">)</span>
                <span class="k">except</span><span class="p">:</span>
                    <span class="n">flag</span><span class="o">=</span><span class="mi">7</span>
                    <span class="n">msg</span><span class="o">=</span><span class="s2">&quot;Failed to locate left min pos&quot;</span>
                    <span class="n">msg_wrapper</span><span class="p">(</span><span class="s2">&quot;info&quot;</span><span class="p">,</span> <span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">,</span> <span class="n">msg</span><span class="p">)</span>
                    <span class="k">return</span> <span class="p">[],</span> <span class="p">[],</span> <span class="p">[],</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="n">flag</span><span class="p">,</span> <span class="n">msg</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="p">[],</span> <span class="p">[]</span>

                <span class="c1"># print(type(minPosOnLeftOfPeak).__name__)</span>
                <span class="c1"># Get the locations of the local minimum positions, if not found, return the position to be within </span>
                <span class="c1"># a hundred points from both extreme ends of the data array.</span>
                <span class="k">if</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">minPosOnRightOfPeak</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="p">)</span> <span class="o">!=</span> <span class="s1">&#39;ndarray&#39;</span><span class="p">:</span>
                    <span class="k">if</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">minPosOnRightOfPeak</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="p">)</span> <span class="o">==</span> <span class="s1">&#39;list&#39;</span><span class="p">:</span>
                        <span class="k">pass</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="k">try</span><span class="p">:</span>
                            <span class="n">minPosOnRightOfPeak</span><span class="o">=</span><span class="p">[</span><span class="n">minPosOnRightOfPeak</span><span class="p">]</span>
                        <span class="k">except</span><span class="p">:</span>
                            <span class="n">minPosOnRightOfPeak</span> <span class="o">=</span> <span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">-</span><span class="mi">100</span><span class="p">]</span>

                <span class="k">if</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">minPosOnLeftOfPeak</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="p">)</span> <span class="o">!=</span> <span class="s1">&#39;ndarray&#39;</span><span class="p">:</span>
                    <span class="k">if</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">minPosOnRightOfPeak</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="p">)</span> <span class="o">==</span> <span class="s1">&#39;list&#39;</span><span class="p">:</span>
                        <span class="n">ls</span><span class="o">=</span><span class="p">[]</span>
                        <span class="c1"># check all values are integers</span>
                        <span class="k">try</span><span class="p">:</span>
                            <span class="k">for</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">minPosOnLeftOfPeak</span><span class="p">:</span>
                                <span class="c1"># print(type(val).__name__, val)</span>
                                <span class="k">if</span> <span class="s2">&quot;float&quot;</span> <span class="ow">in</span> <span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">val</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="p">):</span>
                                    <span class="k">pass</span>
                                <span class="k">else</span><span class="p">:</span>
                                    <span class="n">ls</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">val</span><span class="p">)</span>
                            <span class="n">minPosOnLeftOfPeak</span><span class="o">=</span><span class="n">ls</span>
                        <span class="k">except</span><span class="p">:</span>
                            <span class="k">pass</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="k">try</span><span class="p">:</span>
                            <span class="n">minPosOnLeftOfPeak</span><span class="o">=</span><span class="p">[</span><span class="n">minPosOnLeftOfPeak</span><span class="p">]</span>
                        <span class="k">except</span><span class="p">:</span>
                            <span class="n">minPosOnLeftOfPeak</span> <span class="o">=</span> <span class="p">[</span><span class="mi">100</span><span class="p">]</span>

                <span class="n">msg_wrapper</span><span class="p">(</span><span class="s2">&quot;debug&quot;</span><span class="p">,</span> <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">,</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
                <span class="n">msg_wrapper</span><span class="p">(</span><span class="s2">&quot;debug&quot;</span><span class="p">,</span> <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">,</span> <span class="s2">&quot;-&quot;</span><span class="o">*</span><span class="mi">20</span><span class="p">)</span>
                <span class="n">msg_wrapper</span><span class="p">(</span><span class="s2">&quot;info&quot;</span><span class="p">,</span> <span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">,</span><span class="s2">&quot;Getting center of baseline blocks on left and right of peak: &quot;</span><span class="p">)</span>
                <span class="n">msg_wrapper</span><span class="p">(</span><span class="s2">&quot;debug&quot;</span><span class="p">,</span> <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">,</span> <span class="s2">&quot;-&quot;</span><span class="o">*</span><span class="mi">20</span><span class="p">)</span>

                <span class="n">msg_wrapper</span><span class="p">(</span><span class="s2">&quot;info&quot;</span><span class="p">,</span> <span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">,</span><span class="sa">f</span><span class="s2">&quot;min pos left: </span><span class="si">{</span><span class="n">x</span><span class="p">[</span><span class="n">minPosOnLeftOfPeak</span><span class="p">]</span><span class="si">}</span><span class="s2"> @ loc/s </span><span class="si">{</span><span class="n">minPosOnLeftOfPeak</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                <span class="n">msg_wrapper</span><span class="p">(</span><span class="s2">&quot;info&quot;</span><span class="p">,</span> <span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">,</span><span class="sa">f</span><span class="s2">&quot;min pos right: </span><span class="si">{</span><span class="n">x</span><span class="p">[</span><span class="n">minPosOnRightOfPeak</span><span class="p">]</span><span class="si">}</span><span class="s2"> @ loc/s </span><span class="si">{</span><span class="n">minPosOnRightOfPeak</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                <span class="n">msg_wrapper</span><span class="p">(</span><span class="s2">&quot;info&quot;</span><span class="p">,</span> <span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">,</span><span class="sa">f</span><span class="s2">&quot;scan length: </span><span class="si">{</span><span class="n">scanLen</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

                <span class="c1"># Plot possible locations to fit your baseline</span>
                <span class="n">saveTo</span><span class="o">=</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">saveLoc</span><span class="si">}</span><span class="s1">_baselocs.png&#39;</span>
                <span class="n">plotBaselineEstimate</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">yspl</span><span class="p">,</span> <span class="n">minPosOnLeftOfPeak</span><span class="p">,</span> <span class="n">minPosOnRightOfPeak</span><span class="p">,</span> \
                                     <span class="s2">&quot;left local minumums&quot;</span><span class="p">,</span> <span class="s2">&quot;right local minimums&quot;</span><span class="p">,</span> <span class="s2">&quot;Baseline points selection&quot;</span><span class="p">,</span> <span class="n">saveTo</span><span class="p">)</span>

                <span class="c1"># Locate the baselines</span>
                <span class="c1"># the number of points to use for baseline on each side of beam</span>
                <span class="c1"># limited to 5% of length of the scan, this works well for </span>
                <span class="c1"># situations where there are large sidelobes e.g. Jupiter, so </span>
                <span class="c1"># we apply it to all scans, if fit is bad you can always use the GUI</span>
                <span class="c1"># to fit by hand.</span>
                <span class="n">maxPointsInBaselineBlock</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">scanLen</span><span class="o">*</span><span class="mf">.05</span><span class="p">)</span>
                <span class="n">hMaxPointsInBaselineBlock</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">maxPointsInBaselineBlock</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span>
                <span class="n">nums</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">scanLen</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>  <span class="c1"># array of numbers from 1 to len(list)</span>

                <span class="c1"># set left and right baseline points placeholders</span>
                <span class="n">lb</span><span class="o">=</span><span class="p">[]</span>
                <span class="n">rb</span><span class="o">=</span><span class="p">[]</span>

                <span class="c1"># Get baseline block on left of beam</span>
                <span class="n">msg_wrapper</span><span class="p">(</span><span class="s2">&quot;debug&quot;</span><span class="p">,</span> <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">,</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
                <span class="n">msg_wrapper</span><span class="p">(</span><span class="s2">&quot;debug&quot;</span><span class="p">,</span> <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">,</span> <span class="s2">&quot;-&quot;</span><span class="o">*</span><span class="mi">20</span><span class="p">)</span>
                <span class="n">msg_wrapper</span><span class="p">(</span><span class="s2">&quot;debug&quot;</span><span class="p">,</span> <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">,</span><span class="s2">&quot;Get baseline block on left of beam&quot;</span><span class="p">)</span>
                <span class="n">msg_wrapper</span><span class="p">(</span><span class="s2">&quot;debug&quot;</span><span class="p">,</span> <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">,</span> <span class="s2">&quot;-&quot;</span><span class="o">*</span><span class="mi">20</span><span class="p">)</span>
                <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">minPosOnLeftOfPeak</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">==</span> <span class="s2">&quot;int64&quot;</span><span class="p">:</span>

                    <span class="k">if</span> <span class="n">lf</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                        <span class="c1"># left is faulty, set baseline points to half of the 5% limit</span>
                        <span class="n">leftBaselineBlock</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">minPosOnLeftOfPeak</span><span class="o">-</span><span class="n">hMaxPointsInBaselineBlock</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
                        <span class="n">lb</span> <span class="o">=</span> <span class="n">lb</span><span class="o">+</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">minPosOnLeftOfPeak</span><span class="o">-</span><span class="n">hMaxPointsInBaselineBlock</span><span class="p">]</span>

                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">leftBaselineBlock</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span>
                            <span class="n">minPosOnLeftOfPeak</span><span class="o">-</span><span class="n">hMaxPointsInBaselineBlock</span><span class="p">,</span> <span class="n">minPosOnLeftOfPeak</span><span class="o">+</span><span class="n">hMaxPointsInBaselineBlock</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
                        <span class="n">lb</span> <span class="o">=</span> <span class="n">lb</span><span class="o">+</span><span class="p">[</span><span class="n">minPosOnLeftOfPeak</span><span class="o">-</span><span class="n">hMaxPointsInBaselineBlock</span><span class="p">,</span> <span class="n">minPosOnLeftOfPeak</span><span class="o">+</span><span class="n">hMaxPointsInBaselineBlock</span><span class="p">]</span>

                        <span class="k">if</span> <span class="n">minPosOnLeftOfPeak</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">leftBaselineBlock</span><span class="p">):</span>
                            <span class="c1"># min pos left is too close to the edge, adjust accordingly</span>
                            <span class="n">leftBaselineBlock</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">leftBaselineBlock</span><span class="p">),</span> <span class="mi">1</span><span class="p">)</span>
                            <span class="n">lb</span> <span class="o">=</span> <span class="n">lb</span><span class="o">+</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">leftBaselineBlock</span><span class="p">)]</span>
                            <span class="n">msg_wrapper</span><span class="p">(</span><span class="s2">&quot;debug&quot;</span><span class="p">,</span> <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">,</span><span class="sa">f</span><span class="s2">&quot;mix: </span><span class="si">{</span><span class="n">leftBaselineBlock</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                            <span class="n">sys</span><span class="o">.</span><span class="n">exit</span><span class="p">()</span>
                <span class="k">else</span><span class="p">:</span>

                    <span class="n">leftBaselineBlock</span> <span class="o">=</span> <span class="p">[]</span>
                    <span class="n">slots</span> <span class="o">=</span> <span class="p">[]</span>
                
                    <span class="k">if</span> <span class="n">lf</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span> <span class="c1"># left not faulty</span>
                        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">minPosOnLeftOfPeak</span><span class="p">)):</span>
                            <span class="n">slots</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span>
                                <span class="n">minPosOnLeftOfPeak</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-</span><span class="n">hMaxPointsInBaselineBlock</span><span class="p">,</span> <span class="n">minPosOnLeftOfPeak</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">+</span><span class="n">hMaxPointsInBaselineBlock</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
                            <span class="n">lb</span> <span class="o">=</span> <span class="n">lb</span><span class="o">+</span><span class="p">[</span><span class="n">minPosOnLeftOfPeak</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-</span><span class="n">hMaxPointsInBaselineBlock</span><span class="p">,</span>
                                    <span class="n">minPosOnLeftOfPeak</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">+</span><span class="n">hMaxPointsInBaselineBlock</span><span class="p">]</span>
                            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">slots</span><span class="p">)):</span>
                                <span class="n">leftBaselineBlock</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">slots</span><span class="p">[</span><span class="n">j</span><span class="p">])</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="c1"># struggled to find left base so use all data to fnbw point</span>
                        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">minPosOnLeftOfPeak</span><span class="p">)</span><span class="o">==</span><span class="mi">1</span><span class="p">:</span>
                            <span class="n">leftBaselineBlock</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">minPosOnLeftOfPeak</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="mi">1</span><span class="p">)</span>

                        <span class="n">lb</span> <span class="o">=</span> <span class="n">lb</span><span class="o">+</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="n">minPosOnLeftOfPeak</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
                        <span class="n">flag</span><span class="o">=</span><span class="mi">7</span>
                        <span class="n">msg</span><span class="o">=</span><span class="s2">&quot;-- Failed to locate left min pos&quot;</span>
                        <span class="n">msg_wrapper</span><span class="p">(</span><span class="s2">&quot;debug&quot;</span><span class="p">,</span> <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">,</span><span class="n">msg</span><span class="p">)</span>
                        <span class="c1"># TODO: Think about this a little bit more, </span>
                
                <span class="n">msg_wrapper</span><span class="p">(</span><span class="s2">&quot;debug&quot;</span><span class="p">,</span> <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;lb: </span><span class="si">{</span><span class="n">lb</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                <span class="c1"># msg_wrapper(&quot;debug&quot;, log.debug, f&quot;leftBaselineBlock: {leftBaselineBlock}&quot;)</span>
                
                <span class="c1"># Get baseline block on right of beam</span>
                <span class="n">msg_wrapper</span><span class="p">(</span><span class="s2">&quot;debug&quot;</span><span class="p">,</span> <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">,</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
                <span class="n">msg_wrapper</span><span class="p">(</span><span class="s2">&quot;debug&quot;</span><span class="p">,</span> <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">,</span> <span class="s2">&quot;-&quot;</span><span class="o">*</span><span class="mi">20</span><span class="p">)</span>
                <span class="n">msg_wrapper</span><span class="p">(</span><span class="s2">&quot;debug&quot;</span><span class="p">,</span> <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">,</span><span class="s2">&quot;Get baseline block on right of beam&quot;</span><span class="p">)</span>
                <span class="n">msg_wrapper</span><span class="p">(</span><span class="s2">&quot;debug&quot;</span><span class="p">,</span> <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">,</span> <span class="s2">&quot;-&quot;</span><span class="o">*</span><span class="mi">20</span><span class="p">)</span>
                <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">minPosOnRightOfPeak</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">==</span> <span class="s2">&quot;int64&quot;</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">rf</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                        <span class="n">flag</span><span class="o">=</span><span class="mi">6</span>
                        <span class="n">msg</span><span class="o">=</span><span class="s2">&quot;Failed to locate right min pos&quot;</span>
                        <span class="n">rightBaselineBlock</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">minPosOnRightOfPeak</span><span class="o">+</span><span class="n">hMaxPointsInBaselineBlock</span><span class="p">,</span> <span class="n">scanLen</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
                        <span class="n">rb</span><span class="o">=</span> <span class="n">rb</span><span class="o">+</span><span class="p">[</span><span class="n">minPosOnRightOfPeak</span> <span class="o">+</span>
                                <span class="n">hMaxPointsInBaselineBlock</span><span class="p">,</span> <span class="n">scanLen</span><span class="p">]</span>
                        <span class="n">msg_wrapper</span><span class="p">(</span><span class="s2">&quot;debug&quot;</span><span class="p">,</span> <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">,</span><span class="n">msg</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">rightBaselineBlock</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">minPosOnRightOfPeak</span><span class="o">-</span><span class="n">hMaxPointsInBaselineBlock</span><span class="p">,</span> <span class="n">minPosOnRightOfPeak</span><span class="o">+</span><span class="n">hMaxPointsInBaselineBlock</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
                        <span class="n">rb</span><span class="o">=</span><span class="n">rb</span><span class="o">+</span><span class="p">[</span><span class="n">minPosOnRightOfPeak</span><span class="o">-</span><span class="n">hMaxPointsInBaselineBlock</span><span class="p">,</span>
                                <span class="n">minPosOnRightOfPeak</span><span class="o">+</span><span class="n">hMaxPointsInBaselineBlock</span><span class="p">]</span>
                        <span class="k">if</span> <span class="p">(</span><span class="n">scanLen</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">rightBaselineBlock</span><span class="p">))</span> <span class="o">&lt;</span> <span class="n">minPosOnRightOfPeak</span><span class="p">:</span>
                            <span class="c1"># min pos right is too close to the edge, adjust accordingly</span>
                            <span class="n">rightBaselineBlock</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">scanLen</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">rightBaselineBlock</span><span class="p">),</span> <span class="n">scanLen</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
                            <span class="n">rb</span><span class="o">=</span> <span class="n">rb</span><span class="o">+</span><span class="p">[</span><span class="n">scanLen</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">rightBaselineBlock</span><span class="p">),</span> <span class="n">scanLen</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">rightBaselineBlock</span><span class="o">=</span><span class="p">[]</span>
                    <span class="n">slots</span> <span class="o">=</span> <span class="p">[]</span>
                    <span class="c1">#rf=[]</span>

                    <span class="k">if</span> <span class="n">rf</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">minPosOnRightOfPeak</span><span class="p">)):</span>
                            <span class="n">end</span><span class="o">=</span><span class="n">minPosOnRightOfPeak</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">+</span><span class="n">hMaxPointsInBaselineBlock</span>
                            <span class="k">if</span> <span class="n">end</span><span class="o">&gt;</span><span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
                                <span class="n">end</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="c1">#-1</span>
                            <span class="k">else</span><span class="p">:</span>
                                <span class="k">pass</span>

                            <span class="n">slots</span><span class="o">=</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span>
                                <span class="n">minPosOnRightOfPeak</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-</span><span class="n">hMaxPointsInBaselineBlock</span><span class="p">,</span> <span class="n">end</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
                            <span class="n">rb</span> <span class="o">=</span> <span class="n">rb</span><span class="o">+</span><span class="p">[</span><span class="n">minPosOnRightOfPeak</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-</span><span class="n">hMaxPointsInBaselineBlock</span><span class="p">,</span> <span class="n">end</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">slots</span><span class="p">)):</span>
                                <span class="n">rightBaselineBlock</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">slots</span><span class="p">[</span><span class="n">j</span><span class="p">])</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">rightBaselineBlock</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span>
                            <span class="n">scanLen</span><span class="o">-</span><span class="n">maxPointsInBaselineBlock</span><span class="p">,</span> <span class="n">scanLen</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
                        <span class="n">rb</span> <span class="o">=</span> <span class="n">rb</span><span class="o">+</span><span class="p">[</span><span class="n">scanLen</span><span class="o">-</span><span class="n">maxPointsInBaselineBlock</span><span class="p">,</span> <span class="n">scanLen</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                        <span class="n">flag</span> <span class="o">=</span> <span class="mi">6</span>
                        <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;Failed to locate right min pos&quot;</span>
                        <span class="n">msg_wrapper</span><span class="p">(</span><span class="s2">&quot;debug&quot;</span><span class="p">,</span> <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">,</span><span class="n">msg</span><span class="p">)</span>

               
                <span class="n">msg_wrapper</span><span class="p">(</span><span class="s2">&quot;debug&quot;</span><span class="p">,</span> <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;rb: </span><span class="si">{</span><span class="n">rb</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

                <span class="c1"># ensure data makes sense</span>
                <span class="n">msg_wrapper</span><span class="p">(</span><span class="s2">&quot;debug&quot;</span><span class="p">,</span> <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">,</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
                <span class="n">msg_wrapper</span><span class="p">(</span><span class="s2">&quot;debug&quot;</span><span class="p">,</span> <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">,</span> <span class="s2">&quot;-&quot;</span><span class="o">*</span><span class="mi">20</span><span class="p">)</span>
                <span class="n">msg_wrapper</span><span class="p">(</span><span class="s2">&quot;debug&quot;</span><span class="p">,</span> <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">,</span><span class="s2">&quot;Ensure data makes sense: more sanity checks&quot;</span><span class="p">)</span>
                <span class="n">msg_wrapper</span><span class="p">(</span><span class="s2">&quot;debug&quot;</span><span class="p">,</span> <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">,</span> <span class="s2">&quot;-&quot;</span><span class="o">*</span><span class="mi">20</span><span class="p">)</span>
                
                <span class="k">try</span><span class="p">:</span>
                    <span class="c1"># find if data contains negatives and move/shift points forward</span>

                    <span class="n">zeroIndex</span> <span class="o">=</span> <span class="n">leftBaselineBlock</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
                    <span class="c1">#print(&quot;\nzeroIndex found at index: {}&quot;.format(zeroIndex))</span>
                    
                    <span class="c1"># find the difference between adjacent numbers and identify</span>
                    <span class="c1"># where to allocate shift</span>
                    <span class="n">res</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">leftBaselineBlock</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">leftBaselineBlock</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">leftBaselineBlock</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">)])</span>
                        
                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">res</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">:</span>
                            <span class="c1"># if more than one location for baseline is selected,</span>
                            <span class="c1"># determine shift and adjust accordingly</span>
                            <span class="n">l</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">res</span><span class="o">!=</span><span class="mi">1</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
                            <span class="c1">#(&quot;shift parameter: &quot;,l)</span>
                            <span class="c1">#print(&quot;value at shift parametera: &quot;,leftBaselineBlock[l[0]],&quot;\n&quot;)</span>
                            <span class="n">left</span> <span class="o">=</span> <span class="n">leftBaselineBlock</span><span class="p">[</span><span class="n">zeroIndex</span><span class="p">:</span><span class="n">l</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span>
                            <span class="n">right</span> <span class="o">=</span> <span class="n">leftBaselineBlock</span><span class="p">[</span><span class="n">l</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span><span class="p">:]</span>
                            <span class="n">s</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span>
                                <span class="n">leftBaselineBlock</span><span class="p">[</span><span class="n">l</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">leftBaselineBlock</span><span class="p">[</span><span class="n">l</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span><span class="o">+</span><span class="mi">1</span><span class="o">+</span><span class="n">zeroIndex</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
                            <span class="n">shiftedBlock</span> <span class="o">=</span> <span class="n">left</span><span class="o">+</span><span class="nb">list</span><span class="p">(</span><span class="n">s</span><span class="p">)</span><span class="o">+</span><span class="n">right</span> <span class="c1">#np.arange(0, shift,1)</span>
                            <span class="c1">#print(&quot;shiftedleftbaselineblock: &quot;, shiftedBlock)</span>
                            <span class="n">leftBaselineBlock</span> <span class="o">=</span> <span class="n">shiftedBlock</span>
                            <span class="n">msg_wrapper</span><span class="p">(</span><span class="s2">&quot;debug&quot;</span><span class="p">,</span> <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">,</span> <span class="s2">&quot;Shifted baseline block&quot;</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="k">pass</span>
                <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
                    <span class="k">pass</span>

                <span class="k">try</span><span class="p">:</span>
                    <span class="c1"># find if data contains goes beyond max of scan </span>
                    <span class="c1"># and move/shift points backwards</span>
                    <span class="n">maxIndex</span> <span class="o">=</span> <span class="n">rightBaselineBlock</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">scanLen</span><span class="p">)</span>
                    <span class="c1">#print(&quot;maxIndex: {}&quot;.format(maxIndex))</span>
            
                    <span class="c1"># find the difference between adjacent numbers and identify</span>
                    <span class="c1"># where to allocate shift</span>
                    <span class="n">res</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">rightBaselineBlock</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">rightBaselineBlock</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">rightBaselineBlock</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">)])</span>
                    <span class="c1">#print(res)</span>

                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">res</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">:</span>
                        <span class="c1"># if more than one location for baseline is selected,</span>
                        <span class="c1"># determine shift and adjust accordingly</span>
                        <span class="n">l</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">res</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
                        <span class="c1">#print(&quot;shift parameter: &quot;,l)</span>

                        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">l</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                            <span class="n">msg_wrapper</span><span class="p">(</span><span class="s2">&quot;debug&quot;</span><span class="p">,</span> <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">,</span> <span class="s2">&quot;Shifting entire block&quot;</span><span class="p">)</span>
                            
                            <span class="n">last</span> <span class="o">=</span> <span class="n">rightBaselineBlock</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                            <span class="n">shift</span> <span class="o">=</span><span class="nb">abs</span><span class="p">(</span><span class="n">scanLen</span><span class="o">-</span><span class="n">last</span><span class="p">)</span>
                            <span class="n">shiftedBlock</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span>
                                <span class="n">rightBaselineBlock</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="n">shift</span><span class="p">,</span> <span class="n">scanLen</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
                            <span class="c1">#print(&quot;shiftedrightbaselineblock: &quot;, shiftedBlock)</span>
                            <span class="n">rightBaselineBlock</span> <span class="o">=</span> <span class="n">shiftedBlock</span>

                        <span class="k">else</span><span class="p">:</span>
                            <span class="c1">#print(&quot;value at shift parameterb: &quot;,</span>
                            <span class="c1">#    rightBaselineBlock[l[0]], &quot;\n&quot;)</span>
                            <span class="n">msg_wrapper</span><span class="p">(</span><span class="s2">&quot;debug&quot;</span><span class="p">,</span> <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">,</span> <span class="s2">&quot;Shifting block&quot;</span><span class="p">)</span>

                            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">l</span><span class="p">)</span><span class="o">==</span><span class="mi">1</span><span class="p">:</span>
                                <span class="n">left</span> <span class="o">=</span> <span class="n">rightBaselineBlock</span><span class="p">[:</span><span class="n">l</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span>
                                <span class="n">right</span> <span class="o">=</span> <span class="n">rightBaselineBlock</span><span class="p">[</span><span class="n">l</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span><span class="p">:]</span>
                                <span class="n">shift</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">rightBaselineBlock</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">scanLen</span><span class="p">)</span>
                                <span class="n">s</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span>
                                    <span class="n">rightBaselineBlock</span><span class="p">[</span><span class="n">l</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">shift</span><span class="p">,</span> <span class="n">rightBaselineBlock</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">shift</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
                                <span class="n">shiftedBlock</span> <span class="o">=</span> <span class="n">left</span><span class="o">+</span><span class="nb">list</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
                                <span class="c1">#print(&quot;shiftedrightbaselineblock: &quot;, shiftedBlock)</span>
                                <span class="n">rightBaselineBlock</span> <span class="o">=</span> <span class="n">shiftedBlock</span>

                            <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">l</span><span class="p">)</span><span class="o">==</span><span class="mi">2</span><span class="p">:</span>
                                <span class="c1">#print(&quot;Length l &gt; 1&quot;)</span>
                                
                                <span class="c1"># find value closest to max</span>
                                <span class="n">nearest</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">l</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">t</span><span class="p">:</span> <span class="nb">abs</span><span class="p">(</span><span class="n">t</span><span class="o">-</span><span class="n">maxIndex</span><span class="p">))</span>
                                <span class="n">index</span><span class="o">=</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">l</span><span class="o">==</span><span class="n">nearest</span><span class="p">)[</span><span class="mi">0</span><span class="p">]][</span><span class="mi">0</span><span class="p">]</span>
                                <span class="c1">#print(nearest,index[0])</span>
                                <span class="c1">#print(&quot;value at shift parameter: &quot;,</span>
                                <span class="c1">#    rightBaselineBlock[nearest], &quot;\n&quot;)</span>
                                <span class="c1"># shift backwards</span>
                                <span class="n">left</span> <span class="o">=</span> <span class="n">rightBaselineBlock</span><span class="p">[:</span><span class="n">nearest</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span>
                                <span class="n">right</span> <span class="o">=</span> <span class="n">rightBaselineBlock</span><span class="p">[</span><span class="n">nearest</span><span class="o">+</span><span class="mi">1</span><span class="p">:]</span>
                                <span class="c1">#print(&quot;left: &quot;, left)</span>
                                <span class="c1">#print(&quot;right: &quot;, right)</span>
                                <span class="n">shift</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">rightBaselineBlock</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">scanLen</span><span class="p">)</span>
                                <span class="c1">#print(&quot;shifting back by: &quot;, shift)</span>
                                <span class="n">s</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span>
                                    <span class="n">rightBaselineBlock</span><span class="p">[</span><span class="n">nearest</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">shift</span><span class="p">,</span> <span class="n">rightBaselineBlock</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">shift</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
                                <span class="n">shiftedBlock</span> <span class="o">=</span> <span class="n">left</span><span class="o">+</span><span class="nb">list</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
                                <span class="c1">#print(&quot;shiftedrightbaselineblock: &quot;, shiftedBlock)</span>
                                <span class="n">rightBaselineBlock</span> <span class="o">=</span> <span class="n">shiftedBlock</span>

                            <span class="k">else</span><span class="p">:</span>
                                <span class="c1">#print(&quot;l &gt; 2&quot;)</span>
                                <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;Too many shift parameters.&quot;</span>
                                <span class="n">flag</span><span class="o">=</span><span class="mi">18</span>
                                <span class="n">msg_wrapper</span><span class="p">(</span><span class="s2">&quot;debug&quot;</span><span class="p">,</span> <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;Too many shift parameters: Peak limit left: </span><span class="si">{</span><span class="n">peakLocMinLimit</span><span class="si">}</span><span class="s2">, Peak position: </span><span class="si">{</span><span class="n">peakPosition</span><span class="si">}</span><span class="s2">, Peak limit right: </span><span class="si">{</span><span class="n">peakLocMaxLimit</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                                <span class="n">sys</span><span class="o">.</span><span class="n">exit</span><span class="p">()</span>
                                <span class="k">return</span> <span class="p">[],[],[],</span><span class="mi">1</span><span class="p">,</span><span class="n">flag</span><span class="p">,</span><span class="n">msg</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span>    
                <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
                    <span class="k">pass</span>

                <span class="c1"># msg_wrapper(&quot;debug&quot;, log.debug, f&quot;lb: {lb}&quot;)</span>
                <span class="c1"># msg_wrapper(&quot;debug&quot;, log.debug, f&quot;rb: {rb}&quot;)</span>
                <span class="c1"># print(len(x),len(y),len(yspl))</span>
                <span class="c1"># print(leftBaselineBlock)</span>
                <span class="c1"># print(rightBaselineBlock)</span>
                
                <span class="n">saveTo</span><span class="o">=</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">saveLoc</span><span class="si">}</span><span class="s1">_baselocsOutline.png&#39;</span>
                <span class="n">plotBaselineEstimate</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">yspl</span><span class="p">,</span> <span class="n">lb</span><span class="p">,</span> <span class="n">rb</span><span class="p">,</span><span class="s1">&#39;baselocs at left of beam&#39;</span><span class="p">,</span><span class="s1">&#39;baselocs at rigth of beam&#39;</span><span class="p">,</span>\
                                     <span class="s2">&quot;Plot with baseline blocks outlined&quot;</span><span class="p">,</span> <span class="n">saveTo</span><span class="p">,</span> <span class="n">leftBaselineBlock</span><span class="p">,</span> <span class="n">rightBaselineBlock</span><span class="p">)</span>

                
                <span class="c1"># create a single baseline block</span>
                <span class="n">baseLine</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">leftBaselineBlock</span><span class="p">)</span> <span class="o">+</span> <span class="nb">list</span><span class="p">(</span><span class="n">rightBaselineBlock</span><span class="p">)</span>
                <span class="n">baseLine</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">baseLine</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span>

                <span class="k">return</span> <span class="n">baseLine</span><span class="p">,</span> <span class="n">leftBaselineBlock</span><span class="p">,</span> <span class="n">rightBaselineBlock</span><span class="p">,</span> <span class="n">sidelobes</span><span class="p">,</span> <span class="n">flag</span><span class="p">,</span> <span class="n">msg</span><span class="p">,</span> <span class="n">minPosOnLeftOfPeak</span><span class="p">,</span> <span class="n">minPosOnRightOfPeak</span><span class="p">,</span><span class="n">lb</span><span class="p">,</span><span class="n">rb</span></div>


<div class="viewcode-block" id="correct_drift">
<a class="viewcode-back" href="../../../docs/src.common.html#src.common.fitting.correct_drift">[docs]</a>
<span class="k">def</span> <span class="nf">correct_drift</span><span class="p">(</span><span class="n">xBase</span><span class="p">,</span> <span class="n">yBase</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">log</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Correct for a drifting baseline in the scan by fitting</span>
<span class="sd">        a first order polynomial to a region with no</span>
<span class="sd">        signal.	</span>

<span class="sd">        Parameters</span>
<span class="sd">        -----------</span>
<span class="sd">            xBase : x data of the baseline</span>
<span class="sd">            yBase : y data of the baseline</span>
<span class="sd">            x : x data of the entire drift scan</span>
<span class="sd">    &#39;&#39;&#39;</span>

    <span class="c1"># fit the baseline and get best fit coeffecients</span>
    <span class="n">driftModel</span><span class="p">,</span> <span class="n">driftRes</span><span class="p">,</span> <span class="n">driftRms</span><span class="p">,</span> <span class="n">driftCoeffs</span> <span class="o">=</span> <span class="n">calc_residual_and_rms</span><span class="p">(</span>
        <span class="n">xBase</span><span class="p">,</span> <span class="n">yBase</span><span class="p">,</span><span class="n">log</span><span class="p">,</span> <span class="n">order</span><span class="p">)</span>
    <span class="n">dataModel</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">polyval</span><span class="p">(</span><span class="n">driftCoeffs</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>

    
    <span class="n">msg_wrapper</span><span class="p">(</span><span class="s2">&quot;info&quot;</span><span class="p">,</span> <span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">,</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="n">msg_wrapper</span><span class="p">(</span><span class="s2">&quot;info&quot;</span><span class="p">,</span> <span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">,</span> <span class="s2">&quot;-&quot;</span><span class="o">*</span><span class="mi">30</span><span class="p">)</span>
    <span class="n">msg_wrapper</span><span class="p">(</span><span class="s2">&quot;info&quot;</span><span class="p">,</span> <span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">,</span> <span class="s2">&quot;Fit the baseline&quot;</span><span class="p">)</span>
    <span class="n">msg_wrapper</span><span class="p">(</span><span class="s2">&quot;info&quot;</span><span class="p">,</span> <span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">,</span><span class="s2">&quot;-&quot;</span><span class="o">*</span><span class="mi">30</span><span class="p">)</span>
    <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;Fit = </span><span class="si">{:.3}</span><span class="s2">x + (</span><span class="si">{:.3}</span><span class="s2">), rms error = </span><span class="si">{:.3}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">driftCoeffs</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">driftCoeffs</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">driftRms</span><span class="p">)</span>
    <span class="n">msg_wrapper</span><span class="p">(</span><span class="s2">&quot;info&quot;</span><span class="p">,</span> <span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">,</span> <span class="n">msg</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">dataModel</span><span class="p">,</span> <span class="n">driftModel</span><span class="p">,</span> <span class="n">driftRes</span><span class="p">,</span> <span class="n">driftRms</span><span class="p">,</span> <span class="n">driftCoeffs</span></div>


<div class="viewcode-block" id="calc_residual_and_rms">
<a class="viewcode-back" href="../../../docs/src.common.html#src.common.fitting.calc_residual_and_rms">[docs]</a>
<span class="k">def</span> <span class="nf">calc_residual_and_rms</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">log</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Calculate the residual and rms from data</span>
<span class="sd">    </span>
<span class="sd">        Args:</span>
<span class="sd">            x (array): 1d array</span>
<span class="sd">            data representing the x-axis</span>
<span class="sd">            y (array): 1d array</span>
<span class="sd">                data representing the y-axis</span>
<span class="sd">            deg(int): degree of the polynomial</span>

<span class="sd">        Return:</span>
<span class="sd">            model (array): model of </span>
<span class="sd">            res (array):</span>
<span class="sd">            rms (float):</span>
<span class="sd">            coeff():</span>
<span class="sd">        &quot;&quot;&quot;</span>
    <span class="c1">#TODO: remove redundant code</span>
    
    <span class="c1"># fit the baseline and get best fit coeffecients</span>
    <span class="n">coeffs</span> <span class="o">=</span> <span class="n">poly_coeff</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">order</span><span class="p">)</span>

    <span class="n">msg_wrapper</span><span class="p">(</span><span class="s2">&quot;debug&quot;</span><span class="p">,</span><span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">,</span><span class="sa">f</span><span class="s1">&#39;coeffs: </span><span class="si">{</span><span class="n">coeffs</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>

    <span class="c1"># get a model for the fit using the best fit coeffecients</span>
    <span class="n">model</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">polyval</span><span class="p">(</span><span class="n">coeffs</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>

    <span class="c1"># Calculate the residual and rms</span>
    <span class="n">res</span><span class="p">,</span> <span class="n">rms</span> <span class="o">=</span> <span class="n">calc_residual</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">model</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">model</span><span class="p">,</span> <span class="n">res</span><span class="p">,</span> <span class="n">rms</span><span class="p">,</span> <span class="n">coeffs</span></div>


<div class="viewcode-block" id="calc_residual_and_rms_fit">
<a class="viewcode-back" href="../../../docs/src.common.html#src.common.fitting.calc_residual_and_rms_fit">[docs]</a>
<span class="k">def</span> <span class="nf">calc_residual_and_rms_fit</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">order</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Calculate the residual and rms from data</span>
<span class="sd">    </span>
<span class="sd">        Args:</span>
<span class="sd">            x (array): 1d array</span>
<span class="sd">            data representing the x-axis</span>
<span class="sd">            y (array): 1d array</span>
<span class="sd">                data representing the y-axis</span>
<span class="sd">            deg(int): degree of the polynomial</span>

<span class="sd">        Return:</span>
<span class="sd">            model (array): model of </span>
<span class="sd">            res (array):</span>
<span class="sd">            rms (float):</span>
<span class="sd">            coeff():</span>
<span class="sd">        &quot;&quot;&quot;</span>
    <span class="c1">#TODO: remove redundant code</span>
    
    <span class="n">nx</span><span class="o">=</span><span class="p">[]</span>
    <span class="n">ny</span><span class="o">=</span><span class="p">[]</span>
    <span class="c1"># remove nan values</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)):</span>
        <span class="c1">#print(i,y[i],type(y[i]))</span>
        <span class="k">if</span> <span class="n">y</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span> <span class="ow">or</span> <span class="nb">str</span><span class="p">(</span><span class="n">y</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">==</span><span class="s2">&quot;nan&quot;</span><span class="p">:</span>
            <span class="c1">#print(i,y[i])</span>
            <span class="k">pass</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">nx</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
            <span class="n">ny</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">y</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>

    <span class="c1"># fit the baseline and get best fit coeffecients</span>
    <span class="n">coeffs</span> <span class="o">=</span> <span class="n">poly_coeff</span><span class="p">(</span><span class="n">nx</span><span class="p">,</span> <span class="n">ny</span><span class="p">,</span> <span class="n">order</span><span class="p">)</span>

    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;coeffs: &#39;</span><span class="p">,</span><span class="n">coeffs</span><span class="p">)</span>

    <span class="c1"># get a model for the fit using the best fit coeffecients</span>
    <span class="n">model</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">polyval</span><span class="p">(</span><span class="n">coeffs</span><span class="p">,</span> <span class="n">nx</span><span class="p">)</span>

    <span class="c1">#print(&#39;model: &#39;, model)</span>

    <span class="c1"># Calculate the residual and rms</span>
    <span class="n">res</span><span class="p">,</span> <span class="n">rms</span> <span class="o">=</span> <span class="n">calc_residual</span><span class="p">(</span><span class="n">ny</span><span class="p">,</span> <span class="n">model</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">nx</span><span class="p">,</span> <span class="n">model</span><span class="p">,</span> <span class="n">res</span><span class="p">,</span> <span class="n">rms</span><span class="p">,</span> <span class="n">coeffs</span></div>

    
<div class="viewcode-block" id="poly_coeff">
<a class="viewcode-back" href="../../../docs/src.common.html#src.common.fitting.poly_coeff">[docs]</a>
<span class="k">def</span> <span class="nf">poly_coeff</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">deg</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Calculate the polynomial coeffecients depending </span>
<span class="sd">        on the degree/order of the polynomial</span>

<span class="sd">        Args:</span>
<span class="sd">            x (array): 1d array</span>
<span class="sd">                data representing the x-axis</span>
<span class="sd">            y (array): 1d array</span>
<span class="sd">                data representing the y-axis</span>
<span class="sd">            deg(int): degree of the polynomial</span>

<span class="sd">        Return:</span>
<span class="sd">            array of polynomial fitted data</span>
<span class="sd">    &#39;&#39;&#39;</span>

    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">polyfit</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">deg</span><span class="p">)</span></div>


<div class="viewcode-block" id="fit_beam">
<a class="viewcode-back" href="../../../docs/src.common.html#src.common.fitting.fit_beam">[docs]</a>
<span class="k">def</span> <span class="nf">fit_beam</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">fnbw</span><span class="p">,</span> <span class="n">force</span><span class="p">,</span> <span class="n">log</span><span class="p">,</span> <span class="n">saveTag</span><span class="p">,</span> <span class="n">fitTheoretical</span><span class="p">,</span> <span class="n">autoFit</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Fit single beam data.</span>

<span class="sd">        Parameters:</span>
<span class="sd">            x (array): 1D array of data representing the x-axis</span>
<span class="sd">            y (array): 1D array of data representing the y-axis</span>
<span class="sd">            p (list): list of initial fit parameters</span>
<span class="sd">            fnbw (float): source first null beam width from file</span>
<span class="sd">            dec (float): source declination</span>
<span class="sd">            data (dict): dictionary of source parameters</span>
<span class="sd">            scanNum (int):  Value representing the current scan</span>
<span class="sd">            force (str): String to determine whether to force a fit or not   </span>
<span class="sd">            log (object): loffing object</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># Setup parameters</span>
    <span class="n">scanLen</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>                <span class="c1"># length of the scan</span>
    <span class="n">hhpbw</span> <span class="o">=</span> <span class="n">p</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">/</span><span class="mi">2</span>                  <span class="c1"># half of the hpbw</span>
    <span class="n">hfnbw</span> <span class="o">=</span> <span class="n">fnbw</span><span class="o">/</span><span class="mi">2</span>                  <span class="c1"># half of the fnbw</span>
    <span class="n">flag</span> <span class="o">=</span> <span class="mi">0</span>                        <span class="c1"># default flag set to zero</span>
    <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>                          <span class="c1"># flag message to go on plot</span>

    <span class="c1"># Try to fit a gaussian to determine peak location</span>
    <span class="c1"># this also works as a bad scan filter</span>
    <span class="n">coeff</span><span class="p">,</span> <span class="n">fit</span><span class="p">,</span> <span class="n">flag</span> <span class="o">=</span> <span class="n">test_gauss_fit</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span><span class="n">log</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">coeff</span><span class="p">)</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">force</span><span class="o">==</span><span class="s2">&quot;y&quot;</span><span class="p">:</span>
            <span class="k">pass</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># return np.nan, [], np.nan, [], [], msg, [], [], [], [], np.nan, flag, [], [], [],np.nan,0,0</span>
            <span class="k">return</span> <span class="p">{</span><span class="s2">&quot;peakFit&quot;</span><span class="p">:</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span><span class="s2">&quot;peakModel&quot;</span><span class="p">:[],</span><span class="s2">&quot;peakRms&quot;</span><span class="p">:</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span><span class="s2">&quot;correctedData&quot;</span><span class="p">:[],</span><span class="s2">&quot;peakPts&quot;</span><span class="p">:[],</span><span class="s2">&quot;msg&quot;</span><span class="p">:</span><span class="n">msg</span><span class="p">,</span>
                        <span class="s2">&quot;driftRes&quot;</span><span class="p">:[],</span><span class="s2">&quot;driftRms&quot;</span><span class="p">:[],</span><span class="s2">&quot;driftCoeffs&quot;</span><span class="p">:[],</span><span class="s2">&quot;fitRes&quot;</span><span class="p">:[],</span><span class="s2">&quot;midXValue&quot;</span><span class="p">:</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span><span class="s2">&quot;flag&quot;</span><span class="p">:</span><span class="n">flag</span><span class="p">,</span>
                        <span class="s2">&quot;baseLocsLeft&quot;</span><span class="p">:[],</span><span class="s2">&quot;baseLocsRight&quot;</span><span class="p">:[],</span><span class="s2">&quot;baseLocsCombined&quot;</span><span class="p">:[],</span><span class="s2">&quot;peakLoc&quot;</span><span class="p">:</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span><span class="s2">&quot;baseLeft&quot;</span><span class="p">:[],</span>
                        <span class="s2">&quot;baseRight&quot;</span><span class="p">:[]}</span>

    <span class="k">if</span> <span class="n">autoFit</span> <span class="o">!=</span><span class="kc">None</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">autoFit</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">1</span><span class="p">:</span>
        <span class="c1"># If given fitting points </span>
        <span class="c1">#------------------------</span>
        
        <span class="c1">#print(autoFit, autoFit[&#39;baselocs&#39;])</span>

        <span class="c1">#print(float(autoFit[&#39;baselocs&#39;]))</span>
        <span class="c1"># fit baseline</span>
        <span class="c1"># 2) correct the drift in the data and get the residual and rms</span>
        <span class="n">baseLocs</span><span class="o">=</span><span class="p">[]</span><span class="c1">#np.where()[0]</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">autoFit</span><span class="p">[</span><span class="s1">&#39;baselocs&#39;</span><span class="p">])):</span>
            <span class="k">if</span> <span class="n">i</span><span class="o">%</span><span class="mi">2</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span>
                <span class="c1">#print(autoFit[&#39;baselocs&#39;][i],autoFit[&#39;baselocs&#39;][i+1])</span>
                <span class="k">if</span> <span class="n">i</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span>
                    <span class="n">baseLocsl</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">((</span><span class="n">x</span><span class="o">&gt;=</span><span class="n">autoFit</span><span class="p">[</span><span class="s1">&#39;baselocs&#39;</span><span class="p">][</span><span class="n">i</span><span class="p">])</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">x</span><span class="o">&lt;=</span><span class="n">autoFit</span><span class="p">[</span><span class="s1">&#39;baselocs&#39;</span><span class="p">][</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]))[</span><span class="mi">0</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">baseLocsr</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">((</span><span class="n">x</span><span class="o">&gt;=</span><span class="n">autoFit</span><span class="p">[</span><span class="s1">&#39;baselocs&#39;</span><span class="p">][</span><span class="n">i</span><span class="p">])</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">x</span><span class="o">&lt;=</span><span class="n">autoFit</span><span class="p">[</span><span class="s1">&#39;baselocs&#39;</span><span class="p">][</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]))[</span><span class="mi">0</span><span class="p">]</span>

                <span class="n">d</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">((</span><span class="n">x</span><span class="o">&gt;=</span><span class="n">autoFit</span><span class="p">[</span><span class="s1">&#39;baselocs&#39;</span><span class="p">][</span><span class="n">i</span><span class="p">])</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">x</span><span class="o">&lt;=</span><span class="n">autoFit</span><span class="p">[</span><span class="s1">&#39;baselocs&#39;</span><span class="p">][</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]))[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">baseLocs</span><span class="o">=</span><span class="n">baseLocs</span><span class="o">+</span><span class="nb">list</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>

        <span class="c1">#print(baseLocs)</span>
        <span class="c1">#baseLocsl=x[b1]</span>
        <span class="c1">#baseLocsr=x[b2]</span>
        <span class="n">lb</span><span class="o">=</span><span class="p">[</span><span class="n">baseLocsl</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">baseLocsl</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]]</span>
        <span class="n">rb</span><span class="o">=</span><span class="p">[</span><span class="n">baseLocsr</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">baseLocsr</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]]</span>
        <span class="c1">#print(lb,rb)</span>
        <span class="c1">#sys.exit()</span>
        <span class="c1"># fit baseline blocks</span>
        <span class="n">dataModel</span><span class="p">,</span> <span class="n">driftModel</span><span class="p">,</span> <span class="n">driftRes</span><span class="p">,</span> <span class="n">driftRms</span><span class="p">,</span> <span class="n">driftCoeffs</span> <span class="o">=</span> <span class="n">correct_drift</span><span class="p">(</span>
            <span class="n">x</span><span class="p">[</span><span class="n">baseLocs</span><span class="p">],</span> <span class="n">y</span><span class="p">[</span><span class="n">baseLocs</span><span class="p">],</span> <span class="n">x</span><span class="p">,</span><span class="n">log</span><span class="p">)</span>

        <span class="c1"># 4) apply a polynomial fit to the baseline data</span>
        <span class="n">lin_first_null</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">poly1d</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">polyfit</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">baseLocs</span><span class="p">],</span> <span class="n">y</span><span class="p">[</span><span class="n">baseLocs</span><span class="p">],</span> <span class="mi">1</span><span class="p">))</span>

        <span class="c1"># 5) Subtract the polynomial fitted to the baseline to get corrected beam</span>
        <span class="n">yCorrected</span> <span class="o">=</span> <span class="n">y</span> <span class="o">-</span> <span class="n">lin_first_null</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>

        <span class="c1"># 6) get sline of corrected data</span>
        <span class="n">s</span> <span class="o">=</span> <span class="n">spline</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">yCorrected</span><span class="p">)</span>

        <span class="n">plotCorrectedData</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">yCorrected</span><span class="p">,</span><span class="n">baseLocsl</span><span class="p">,</span><span class="n">baseLocsr</span><span class="p">,</span><span class="s1">&#39;Corrected data&#39;</span><span class="p">,</span><span class="s1">&#39;blocks&#39;</span><span class="p">,</span><span class="s1">&#39;Plot of baseline corrected data&#39;</span><span class="p">,</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">saveTo</span><span class="si">}</span><span class="s1">corrected.png&#39;</span><span class="p">,</span><span class="n">xlabel</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">,</span><span class="n">ylabel</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">)</span>
        <span class="n">plot_overlap</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">yCorrected</span><span class="p">,</span><span class="n">x</span><span class="p">,</span><span class="n">s</span><span class="p">,</span><span class="s1">&#39;Plot of splined data&#39;</span><span class="p">,</span><span class="s1">&#39;corrected&#39;</span><span class="p">,</span><span class="s1">&#39;spline fit&#39;</span><span class="p">,</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">saveTo</span><span class="si">}</span><span class="s1">splined.png&#39;</span><span class="p">,</span><span class="n">xlabel</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">,</span><span class="n">ylabel</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">)</span>
    
        <span class="c1"># pl.title(&quot;Baseline corrected data&quot;)</span>
        <span class="c1"># pl.xlabel(&quot;Scandist [Deg]&quot;)</span>
        <span class="c1"># pl.ylabel(&quot;Ta [K]&quot;)</span>
        <span class="c1"># #pl.plot(x,y)</span>
        <span class="c1"># pl.plot(x, yCorrected, &#39;k&#39;,label=&quot;baseline corrected data&quot;)</span>
        <span class="c1"># #pl.plot(x[main_beam], yCorrected[main_beam])</span>
        <span class="c1"># pl.plot(x[baseLocs], yCorrected[baseLocs],&quot;.&quot;)</span>
        <span class="c1"># pl.plot(x[lb], yCorrected[lb],&quot;.&quot;)</span>
        <span class="c1"># #pl.plot(x,s)</span>
        <span class="c1"># pl.plot(x,np.zeros_like(x),&#39;k&#39;)</span>
        <span class="c1"># #pl.grid()</span>
        <span class="c1"># pl.legend(loc=&quot;best&quot;)</span>
        <span class="c1"># try:</span>
        <span class="c1">#     pl.savefig(saveFolder+&quot;baseline_corrected_data.png&quot;)</span>
        <span class="c1"># except:</span>
        <span class="c1">#     pass</span>
        <span class="c1"># #pl.show()</span>
        <span class="c1"># pl.close()</span>
        <span class="c1"># #sys.exit()</span>

        <span class="c1"># fit a polynomial to peak data</span>

        <span class="n">msg_wrapper</span><span class="p">(</span><span class="s2">&quot;info&quot;</span><span class="p">,</span> <span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">,</span> <span class="s2">&quot;Fit the peak&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;*&quot;</span><span class="o">*</span><span class="mi">60</span><span class="p">)</span>
        <span class="n">hmain_beam</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">((</span><span class="n">x</span><span class="o">&gt;=</span><span class="n">autoFit</span><span class="p">[</span><span class="s1">&#39;peaklocs&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">x</span><span class="o">&lt;=</span><span class="n">autoFit</span><span class="p">[</span><span class="s1">&#39;peaklocs&#39;</span><span class="p">][</span><span class="mi">1</span><span class="p">]))[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">ypeak</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">polyval</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">polyfit</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">hmain_beam</span><span class="p">],</span>
                                    <span class="n">yCorrected</span><span class="p">[</span><span class="n">hmain_beam</span><span class="p">],</span>  <span class="mi">2</span><span class="p">),</span> <span class="n">x</span><span class="p">[</span><span class="n">hmain_beam</span><span class="p">])</span>

        <span class="c1"># get residual and rms of peak fit</span>
        <span class="n">fitRes</span><span class="p">,</span> <span class="n">err_peak</span> <span class="o">=</span> <span class="n">calc_residual</span><span class="p">(</span><span class="n">yCorrected</span><span class="p">[</span><span class="n">hmain_beam</span><span class="p">],</span> <span class="n">ypeak</span><span class="p">)</span>

        <span class="c1"># pl.title(&quot;Plot of final peak fitted data&quot;)</span>
        <span class="c1"># pl.xlabel(&quot;Scandist [Deg]&quot;)</span>
        <span class="c1"># pl.ylabel(&quot;Ta [K]&quot;)</span>
        <span class="c1"># pl.plot(x, yCorrected, &quot;k&quot;, label=&quot;corrected data&quot;)</span>
        <span class="c1"># #pl.plot(x[main_beam],yCorrected[main_beam])</span>
        <span class="c1"># pl.plot(x[hmain_beam], yCorrected[hmain_beam])</span>
        <span class="c1"># #pl.plot(x,fit)</span>
        <span class="c1"># pl.plot(x[hmain_beam],ypeak,&quot;r&quot;,label=&quot;Ta[K] = %.3f +- %.3f&quot; %(max(ypeak),err_peak))</span>
        <span class="c1"># pl.plot(x,np.zeros(scanLen),&quot;k&quot;)</span>
        <span class="c1"># #pl.grid()</span>
        <span class="c1"># pl.legend(loc=&quot;best&quot;)</span>
        <span class="c1"># try:</span>
        <span class="c1">#     pl.savefig(saveFolder+&quot;peak_fit_data.png&quot;)</span>
        <span class="c1"># except:</span>
        <span class="c1">#     pass</span>
        <span class="c1"># #pl.show()</span>
        <span class="c1"># pl.close()</span>
        <span class="c1">#sys.exit()</span>

        <span class="c1"># find final peak loc</span>
        <span class="n">ploc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">ypeak</span> <span class="o">==</span> <span class="nb">max</span><span class="p">(</span><span class="n">ypeak</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">peakLoc</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">hmain_beam</span><span class="p">])[</span><span class="n">ploc</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
        
        <span class="c1"># return max(ypeak), ypeak, err_peak, yCorrected, hmain_beam, &quot;&quot;, driftRes, driftRms, driftCoeffs, fitRes, coeff[1], </span>
        <span class="c1"># flag, baseLocsl, baseLocsr, baseLocs, peakLoc,lb,rb</span>
        <span class="n">ret</span><span class="o">=</span><span class="p">{</span>
             <span class="s2">&quot;peakFit&quot;</span><span class="p">:</span><span class="nb">max</span><span class="p">(</span><span class="n">ypeak</span><span class="p">),</span><span class="s2">&quot;peakModel&quot;</span><span class="p">:</span><span class="n">ypeak</span><span class="p">,</span> <span class="s2">&quot;peakRms&quot;</span><span class="p">:</span><span class="n">err_peak</span><span class="p">,</span><span class="s2">&quot;correctedData&quot;</span><span class="p">:</span><span class="n">yCorrected</span><span class="p">,</span><span class="s2">&quot;peakPts&quot;</span><span class="p">:</span><span class="n">hmain_beam</span><span class="p">,</span>
            <span class="s2">&quot;msg&quot;</span><span class="p">:</span><span class="s2">&quot;&quot;</span><span class="p">,</span><span class="s2">&quot;driftRes&quot;</span><span class="p">:</span><span class="n">driftRes</span><span class="p">,</span><span class="s2">&quot;driftRms&quot;</span><span class="p">:</span><span class="n">driftRms</span><span class="p">,</span><span class="s2">&quot;driftCoeffs&quot;</span><span class="p">:</span><span class="n">driftCoeffs</span><span class="p">,</span><span class="s2">&quot;fitRes&quot;</span><span class="p">:</span><span class="n">fitRes</span><span class="p">,</span><span class="s2">&quot;midXValue&quot;</span><span class="p">:</span><span class="n">coeff</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
            <span class="s2">&quot;flag&quot;</span><span class="p">:</span><span class="n">flag</span><span class="p">,</span><span class="s2">&quot;baseLocsLeft&quot;</span><span class="p">:</span><span class="n">baseLocsl</span><span class="p">,</span><span class="s2">&quot;baseLocsRight&quot;</span><span class="p">:</span><span class="n">baseLocsr</span><span class="p">,</span><span class="s2">&quot;baseLocsCombined&quot;</span><span class="p">:</span><span class="n">baseLocs</span><span class="p">,</span><span class="s2">&quot;peakLoc&quot;</span><span class="p">:</span><span class="n">peakLoc</span><span class="p">,</span>
             <span class="s2">&quot;baseLeft&quot;</span><span class="p">:</span><span class="n">lb</span><span class="p">,</span><span class="s2">&quot;baseRight&quot;</span><span class="p">:</span><span class="n">rb</span>
            <span class="p">}</span>
        <span class="k">return</span> <span class="n">ret</span>
        <span class="n">sys</span><span class="o">.</span><span class="n">exit</span><span class="p">()</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># 1. Locate baseline blocks</span>
        <span class="c1"># These are the blocks that will be used to correct the drift in the data</span>
        <span class="k">if</span> <span class="n">force</span><span class="o">==</span><span class="s2">&quot;y&quot;</span> <span class="ow">and</span> <span class="n">flag</span><span class="o">==</span><span class="mi">3</span><span class="p">:</span>
            <span class="n">baseLocsl</span><span class="o">=</span><span class="p">[]</span>
            <span class="n">baseLocsr</span><span class="o">=</span><span class="p">[]</span>
        <span class="k">else</span><span class="p">:</span>

            <span class="k">if</span> <span class="n">fitTheoretical</span><span class="o">==</span><span class="s2">&quot;y&quot;</span><span class="p">:</span>
                <span class="c1">#baseLocs, baseLocsl, baseLocsr, sidelobes, flag, msg, minPosOnLeftOfPeak, minPosOnRightOfPeak, lb, rb = locate_baseline_blocks_auto(</span>
                <span class="c1">#x, y, coeff[1], hfnbw,log)</span>
                <span class="n">baseLocs</span><span class="p">,</span> <span class="n">baseLocsl</span><span class="p">,</span> <span class="n">baseLocsr</span><span class="p">,</span> <span class="n">sidelobes</span> <span class="o">=</span> <span class="n">locate_baseline_blocks_fnbw</span><span class="p">(</span>
                <span class="n">x</span><span class="p">,</span> <span class="n">hfnbw</span><span class="p">,)</span>
                <span class="c1">#print(baseLocsl,baseLocsr)</span>
                <span class="n">flag</span> <span class="o">=</span> <span class="mi">26</span> 
                <span class="n">msg</span> <span class="o">=</span>  <span class="s2">&quot;Fitting left and right theoretical (FNBW) points&quot;</span>
                <span class="n">minPosOnLeftOfPeak</span> <span class="o">=</span> <span class="n">baseLocsl</span><span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">baseLocsl</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span><span class="p">)]</span>
                <span class="n">minPosOnRightOfPeak</span> <span class="o">=</span> <span class="n">baseLocsr</span><span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">baseLocsr</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span><span class="p">)]</span>
                <span class="n">lb</span> <span class="o">=</span> <span class="p">[</span><span class="n">baseLocsl</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">baseLocsl</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]]</span>
                <span class="n">rb</span> <span class="o">=</span> <span class="p">[</span><span class="n">baseLocsr</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">baseLocsr</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]]</span>
                <span class="c1">#sys.exit()</span>

            <span class="k">else</span><span class="p">:</span>
                <span class="n">msg_wrapper</span><span class="p">(</span><span class="s2">&quot;info&quot;</span><span class="p">,</span><span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">,</span><span class="s2">&quot;AUTO fitting started.&quot;</span><span class="p">)</span>

                <span class="n">baseLocs</span><span class="p">,</span> <span class="n">baseLocsl</span><span class="p">,</span> <span class="n">baseLocsr</span><span class="p">,</span> <span class="n">sidelobes</span><span class="p">,</span> <span class="n">flag</span><span class="p">,</span> <span class="n">msg</span><span class="p">,</span> <span class="n">minPosOnLeftOfPeak</span><span class="p">,</span> <span class="n">minPosOnRightOfPeak</span><span class="p">,</span> <span class="n">lb</span><span class="p">,</span> <span class="n">rb</span> <span class="o">=</span> <span class="n">locate_baseline_blocks_auto</span><span class="p">(</span>
                <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">coeff</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">hfnbw</span><span class="p">,</span><span class="n">log</span><span class="p">,</span> <span class="n">saveTag</span><span class="p">)</span>
                
                <span class="k">if</span> <span class="s1">&#39;int&#39;</span> <span class="ow">in</span> <span class="nb">type</span><span class="p">(</span><span class="n">minPosOnRightOfPeak</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span> <span class="ow">or</span> <span class="s1">&#39;float&#39;</span> <span class="ow">in</span> <span class="nb">type</span><span class="p">(</span><span class="n">minPosOnRightOfPeak</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">minPosOnRightOfPeak</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Failed to locate right min pos&quot;</span><span class="p">)</span>
                    <span class="n">flag</span><span class="o">=</span><span class="mi">6</span>
                    <span class="c1"># return np.nan, [], np.nan, [], [], msg, [], [], [], [], np.nan, 6, [], [], [], np.nan,0,0</span>
                    <span class="k">return</span> <span class="p">{</span><span class="s2">&quot;peakFit&quot;</span><span class="p">:</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span><span class="s2">&quot;peakModel&quot;</span><span class="p">:[],</span><span class="s2">&quot;peakRms&quot;</span><span class="p">:</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span><span class="s2">&quot;correctedData&quot;</span><span class="p">:[],</span><span class="s2">&quot;peakPts&quot;</span><span class="p">:[],</span><span class="s2">&quot;msg&quot;</span><span class="p">:</span><span class="n">msg</span><span class="p">,</span>
                        <span class="s2">&quot;driftRes&quot;</span><span class="p">:[],</span><span class="s2">&quot;driftRms&quot;</span><span class="p">:[],</span><span class="s2">&quot;driftCoeffs&quot;</span><span class="p">:[],</span><span class="s2">&quot;fitRes&quot;</span><span class="p">:[],</span><span class="s2">&quot;midXValue&quot;</span><span class="p">:</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span><span class="s2">&quot;flag&quot;</span><span class="p">:</span><span class="n">flag</span><span class="p">,</span>
                        <span class="s2">&quot;baseLocsLeft&quot;</span><span class="p">:[],</span><span class="s2">&quot;baseLocsRight&quot;</span><span class="p">:[],</span><span class="s2">&quot;baseLocsCombined&quot;</span><span class="p">:[],</span><span class="s2">&quot;peakLoc&quot;</span><span class="p">:</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span><span class="s2">&quot;baseLeft&quot;</span><span class="p">:[],</span>
                        <span class="s2">&quot;baseRight&quot;</span><span class="p">:[]}</span>
                
                <span class="k">elif</span> <span class="s1">&#39;int&#39;</span> <span class="ow">in</span> <span class="nb">type</span><span class="p">(</span><span class="n">minPosOnLeftOfPeak</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">minPosOnLeftOfPeak</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Failed to locate left min pos&quot;</span><span class="p">)</span>
                    <span class="n">flag</span><span class="o">=</span><span class="mi">7</span>
                    <span class="c1"># return np.nan, [], np.nan, [], [], msg, [], [], [], [], np.nan, 7, [], [], [], np.nan,0,0</span>
                    <span class="k">return</span> <span class="p">{</span><span class="s2">&quot;peakFit&quot;</span><span class="p">:</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span><span class="s2">&quot;peakModel&quot;</span><span class="p">:[],</span><span class="s2">&quot;peakRms&quot;</span><span class="p">:</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span><span class="s2">&quot;correctedData&quot;</span><span class="p">:[],</span><span class="s2">&quot;peakPts&quot;</span><span class="p">:[],</span><span class="s2">&quot;msg&quot;</span><span class="p">:</span><span class="n">msg</span><span class="p">,</span>
                        <span class="s2">&quot;driftRes&quot;</span><span class="p">:[],</span><span class="s2">&quot;driftRms&quot;</span><span class="p">:[],</span><span class="s2">&quot;driftCoeffs&quot;</span><span class="p">:[],</span><span class="s2">&quot;fitRes&quot;</span><span class="p">:[],</span><span class="s2">&quot;midXValue&quot;</span><span class="p">:</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span><span class="s2">&quot;flag&quot;</span><span class="p">:</span><span class="n">flag</span><span class="p">,</span>
                        <span class="s2">&quot;baseLocsLeft&quot;</span><span class="p">:[],</span><span class="s2">&quot;baseLocsRight&quot;</span><span class="p">:[],</span><span class="s2">&quot;baseLocsCombined&quot;</span><span class="p">:[],</span><span class="s2">&quot;peakLoc&quot;</span><span class="p">:</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span><span class="s2">&quot;baseLeft&quot;</span><span class="p">:[],</span>
                        <span class="s2">&quot;baseRight&quot;</span><span class="p">:[]}</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">pass</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">baseLocsl</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">baseLocsr</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>

            <span class="c1"># one side of the basline has could not be located possibly due to rfi</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;*failed to locate base locs&quot;</span>
            <span class="n">msg_wrapper</span><span class="p">(</span><span class="s2">&quot;warning&quot;</span><span class="p">,</span> <span class="n">log</span><span class="o">.</span><span class="n">warning</span><span class="p">,</span> <span class="n">msg</span><span class="p">)</span>
            <span class="n">sys</span><span class="o">.</span><span class="n">exit</span><span class="p">()</span>
            <span class="n">flag</span><span class="o">=</span><span class="mi">30</span>

            <span class="c1"># Force the fit</span>
            <span class="k">if</span> <span class="n">force</span><span class="o">==</span><span class="s2">&quot;y&quot;</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Forcing the fit&quot;</span><span class="p">)</span>

                <span class="c1"># set baseline points and fit edges or fnbw points</span>
                <span class="c1">#print()</span>

                <span class="c1"># 1. try fitting the data with the centre at 0</span>
                <span class="n">baseLocs</span><span class="p">,</span> <span class="n">baseLocsl</span><span class="p">,</span> <span class="n">baseLocsr</span><span class="p">,</span> <span class="n">sidelobes</span><span class="p">,</span> <span class="n">flag</span><span class="p">,</span> <span class="n">msg</span><span class="p">,</span> <span class="n">minPosOnLeftOfPeak</span><span class="p">,</span> <span class="n">minPosOnRightOfPeak</span><span class="p">,</span> <span class="n">lb</span><span class="p">,</span> <span class="n">rb</span> <span class="o">=</span> <span class="n">locate_baseline_blocks_auto</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">hfnbw</span><span class="p">,</span><span class="n">log</span><span class="p">)</span>
                <span class="n">msg</span><span class="o">=</span><span class="s2">&quot;force fitted local mins&quot;</span>

                

                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">baseLocsl</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">baseLocsr</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>

                    <span class="c1"># 2. try fitting the hfnbw points</span>
                    <span class="n">baseLocsl</span>  <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">x</span> <span class="o">&lt;=</span> <span class="p">(</span><span class="o">-</span><span class="n">hfnbw</span><span class="p">))[</span><span class="mi">0</span><span class="p">])</span> 
                    <span class="n">baseLocsr</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">x</span> <span class="o">&gt;=</span> <span class="p">(</span><span class="n">hfnbw</span><span class="p">))[</span><span class="mi">0</span><span class="p">])</span>
                    <span class="n">baseLocs</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">baseLocsl</span><span class="p">)</span><span class="o">+</span><span class="nb">list</span><span class="p">(</span><span class="n">baseLocsr</span><span class="p">)</span>
                    <span class="n">msg</span><span class="o">=</span><span class="s2">&quot;force fitted fnbw locs&quot;</span>
                <span class="n">sidelobes</span><span class="o">=</span><span class="mi">2</span> <span class="c1">#error fitting the data</span>

                <span class="c1"># if both methods failed, exit</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">baseLocsl</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">baseLocsr</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="c1"># return np.nan, [], np.nan, [], [], msg, [], [], [], [], np.nan, flag, [], [], [], np.nan</span>
                    <span class="k">return</span> <span class="p">{</span><span class="s2">&quot;peakFit&quot;</span><span class="p">:</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span><span class="s2">&quot;peakModel&quot;</span><span class="p">:[],</span><span class="s2">&quot;peakRms&quot;</span><span class="p">:</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span><span class="s2">&quot;correctedData&quot;</span><span class="p">:[],</span><span class="s2">&quot;peakPts&quot;</span><span class="p">:[],</span><span class="s2">&quot;msg&quot;</span><span class="p">:</span><span class="n">msg</span><span class="p">,</span>
                        <span class="s2">&quot;driftRes&quot;</span><span class="p">:[],</span><span class="s2">&quot;driftRms&quot;</span><span class="p">:[],</span><span class="s2">&quot;driftCoeffs&quot;</span><span class="p">:[],</span><span class="s2">&quot;fitRes&quot;</span><span class="p">:[],</span><span class="s2">&quot;midXValue&quot;</span><span class="p">:</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span><span class="s2">&quot;flag&quot;</span><span class="p">:</span><span class="n">flag</span><span class="p">,</span>
                        <span class="s2">&quot;baseLocsLeft&quot;</span><span class="p">:[],</span><span class="s2">&quot;baseLocsRight&quot;</span><span class="p">:[],</span><span class="s2">&quot;baseLocsCombined&quot;</span><span class="p">:[],</span><span class="s2">&quot;peakLoc&quot;</span><span class="p">:</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span><span class="s2">&quot;baseLeft&quot;</span><span class="p">:[],</span>
                        <span class="s2">&quot;baseRight&quot;</span><span class="p">:[]}</span>

<span class="w">                </span><span class="sd">&#39;&#39;&#39;pl.title(&quot;Plot of baseline corrected data&quot;)</span>
<span class="sd">                pl.xlabel(&quot;Scandist [Deg]&quot;)</span>
<span class="sd">                pl.ylabel(&quot;Ta [K]&quot;)</span>
<span class="sd">                #pl.plot(x,y)</span>
<span class="sd">                pl.plot(x, y, &#39;k&#39;,label=&quot;baseline corrected data&quot;)</span>
<span class="sd">                #pl.plot(x[main_beam], yCorrected[main_beam])</span>
<span class="sd">                pl.plot(x[baseLocs], y[baseLocs],&quot;.&quot;)</span>
<span class="sd">                pl.show()</span>
<span class="sd">                pl.close()</span>
<span class="sd">                sys.exit()&#39;&#39;&#39;</span>

                <span class="c1"># fit the baseline</span>
                <span class="n">dataModel</span><span class="p">,</span> <span class="n">driftModel</span><span class="p">,</span> <span class="n">driftRes</span><span class="p">,</span> <span class="n">driftRms</span><span class="p">,</span> <span class="n">driftCoeffs</span> <span class="o">=</span> <span class="n">correct_drift</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">baseLocs</span><span class="p">],</span> <span class="n">y</span><span class="p">[</span><span class="n">baseLocs</span><span class="p">],</span> <span class="n">x</span><span class="p">,</span><span class="n">log</span><span class="p">)</span>

                <span class="c1"># get main beam</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">main_beam</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span><span class="n">x</span> <span class="o">&gt;=</span> <span class="n">coeff</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">hfnbw</span><span class="p">,</span> <span class="n">x</span> <span class="o">&lt;=</span> <span class="n">coeff</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="n">hfnbw</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span>
                <span class="k">except</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Failed to get coeff[1], setting beam to fnbw window&quot;</span><span class="p">)</span>
                    <span class="n">main_beam</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span>
                        <span class="n">x</span> <span class="o">&gt;=</span> <span class="n">hfnbw</span><span class="p">,</span> <span class="n">x</span> <span class="o">&lt;=</span> <span class="n">hfnbw</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span>

                <span class="c1"># 4) apply a polynomial fit to the baseline data</span>
                <span class="n">lin_first_null</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">poly1d</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">polyfit</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">baseLocs</span><span class="p">],</span> <span class="n">y</span><span class="p">[</span><span class="n">baseLocs</span><span class="p">],</span> <span class="mi">1</span><span class="p">))</span>

                <span class="c1"># 5) Subtract the polynomial fitted to the baseline to get corrected beam</span>
                <span class="n">yCorrected</span> <span class="o">=</span> <span class="n">y</span> <span class="o">-</span> <span class="n">lin_first_null</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>

                <span class="c1"># 6) get sline of corrected data</span>
                <span class="n">s</span> <span class="o">=</span> <span class="n">spline</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">yCorrected</span><span class="p">)</span>

                <span class="n">pl</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s2">&quot;Plot of baseline corrected data&quot;</span><span class="p">)</span>
                <span class="n">pl</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s2">&quot;Scandist [Deg]&quot;</span><span class="p">)</span>
                <span class="n">pl</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s2">&quot;Ta [K]&quot;</span><span class="p">)</span>
                <span class="c1">#pl.plot(x,y)</span>
                <span class="n">pl</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">yCorrected</span><span class="p">,</span> <span class="s1">&#39;k&#39;</span><span class="p">,</span><span class="n">label</span><span class="o">=</span><span class="s2">&quot;baseline corrected data&quot;</span><span class="p">)</span>
                <span class="c1">#pl.plot(x[main_beam], yCorrected[main_beam])</span>
                <span class="n">pl</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">baseLocsl</span><span class="p">],</span> <span class="n">yCorrected</span><span class="p">[</span><span class="n">baseLocsl</span><span class="p">],</span><span class="s2">&quot;.&quot;</span><span class="p">)</span>
                <span class="n">pl</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">baseLocsr</span><span class="p">],</span> <span class="n">yCorrected</span><span class="p">[</span><span class="n">baseLocsr</span><span class="p">],</span><span class="s2">&quot;.&quot;</span><span class="p">)</span>
                <span class="c1">#pl.plot(x,s)</span>
                <span class="n">pl</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">x</span><span class="p">),</span><span class="s1">&#39;k&#39;</span><span class="p">)</span>
                <span class="n">pl</span><span class="o">.</span><span class="n">grid</span><span class="p">()</span>
                <span class="n">pl</span><span class="o">.</span><span class="n">legend</span><span class="p">(</span><span class="n">loc</span><span class="o">=</span><span class="s2">&quot;best&quot;</span><span class="p">)</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">pl</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="n">saveFolder</span><span class="o">+</span><span class="s2">&quot;baseline_corrected_data.png&quot;</span><span class="p">)</span>
                <span class="k">except</span><span class="p">:</span>
                    <span class="k">pass</span>
                <span class="c1">#pl.show()</span>
                <span class="n">pl</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
                <span class="c1">#sys.exit()</span>

                <span class="c1"># fit the peak</span>
                <span class="c1"># 3) GET LOCATIONS OF DATA FOR THE MAIN BEAM ONLY</span>
                <span class="c1"># this is limited by the fnbw</span>
                <span class="c1"># check peak is at centre</span>
                <span class="n">main_beam</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span>
                    <span class="n">x</span> <span class="o">&gt;=</span> <span class="o">-</span><span class="n">hfnbw</span><span class="p">,</span> <span class="n">x</span> <span class="o">&lt;=</span> <span class="n">hfnbw</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span>
                    
                <span class="c1"># 4) apply a polynomial fit to the baseline data</span>
                <span class="n">lin_first_null</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">poly1d</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">polyfit</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">baseLocs</span><span class="p">],</span> <span class="n">y</span><span class="p">[</span><span class="n">baseLocs</span><span class="p">],</span> <span class="mi">1</span><span class="p">))</span>

                <span class="c1"># 5) Subtract the polynomial fitted to the baseline to get corrected beam</span>
                <span class="n">yCorrected</span> <span class="o">=</span> <span class="n">y</span> <span class="o">-</span> <span class="n">lin_first_null</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>

                <span class="c1"># 6) get sline of corrected data</span>
                <span class="n">s</span> <span class="o">=</span> <span class="n">spline</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">yCorrected</span><span class="p">)</span>

                <span class="c1"># 7. Fit the peak</span>
                <span class="c1"># find max location</span>
                <span class="n">msg_wrapper</span><span class="p">(</span><span class="s2">&quot;info&quot;</span><span class="p">,</span> <span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">,</span> <span class="s2">&quot;Fit the peak&quot;</span><span class="p">)</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;*&quot;</span><span class="o">*</span><span class="mi">60</span><span class="p">)</span>
                <span class="n">maxp</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
                <span class="n">maxloc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">s</span> <span class="o">==</span> <span class="n">maxp</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">xmaxloc</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="n">maxloc</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>

                <span class="c1"># max is not at center, found at extreme ends of scan</span>
                <span class="k">if</span> <span class="p">(</span><span class="nb">max</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="o">==</span> <span class="n">s</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="ow">or</span> <span class="p">(</span><span class="nb">max</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="o">==</span> <span class="n">s</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]):</span>
                    <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;max of peak is not at center, failed peak fit &quot;</span>
                    <span class="n">msg_wrapper</span><span class="p">(</span><span class="s2">&quot;warning&quot;</span><span class="p">,</span> <span class="n">log</span><span class="o">.</span><span class="n">warning</span><span class="p">,</span> <span class="n">msg</span><span class="p">)</span>
                    <span class="n">flag</span>  <span class="o">=</span> <span class="mi">10</span>
                    <span class="c1"># return np.nan, [], np.nan, [], [], msg, [], [], [], [], np.nan, flag, [], [], [],np.nan,0,0</span>
                    <span class="k">return</span> <span class="p">{</span><span class="s2">&quot;peakFit&quot;</span><span class="p">:</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span><span class="s2">&quot;peakModel&quot;</span><span class="p">:[],</span><span class="s2">&quot;peakRms&quot;</span><span class="p">:</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span><span class="s2">&quot;correctedData&quot;</span><span class="p">:[],</span><span class="s2">&quot;peakPts&quot;</span><span class="p">:[],</span><span class="s2">&quot;msg&quot;</span><span class="p">:</span><span class="n">msg</span><span class="p">,</span>
                        <span class="s2">&quot;driftRes&quot;</span><span class="p">:[],</span><span class="s2">&quot;driftRms&quot;</span><span class="p">:[],</span><span class="s2">&quot;driftCoeffs&quot;</span><span class="p">:[],</span><span class="s2">&quot;fitRes&quot;</span><span class="p">:[],</span><span class="s2">&quot;midXValue&quot;</span><span class="p">:</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span><span class="s2">&quot;flag&quot;</span><span class="p">:</span><span class="n">flag</span><span class="p">,</span>
                        <span class="s2">&quot;baseLocsLeft&quot;</span><span class="p">:[],</span><span class="s2">&quot;baseLocsRight&quot;</span><span class="p">:[],</span><span class="s2">&quot;baseLocsCombined&quot;</span><span class="p">:[],</span><span class="s2">&quot;peakLoc&quot;</span><span class="p">:</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span><span class="s2">&quot;baseLeft&quot;</span><span class="p">:[],</span>
                        <span class="s2">&quot;baseRight&quot;</span><span class="p">:[]}</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">pass</span>

                <span class="c1"># 7) Get indices where the x values are within the main beam</span>
                <span class="c1"># Get top 30% of beam</span>
                <span class="n">xMainBeam</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="n">main_beam</span><span class="p">]</span>
                <span class="n">yMainBeam</span> <span class="o">=</span> <span class="n">s</span><span class="p">[</span><span class="n">main_beam</span><span class="p">]</span>
                <span class="n">maxs</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="n">main_beam</span><span class="p">])</span>

                <span class="n">loc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="n">main_beam</span><span class="p">]</span> <span class="o">==</span> <span class="n">maxs</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">midxMainBeam</span> <span class="o">=</span> <span class="n">xMainBeam</span><span class="p">[</span><span class="n">loc</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>  

                <span class="c1"># Get main beam for peak fitting</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">hmain_beamn</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span>
                        <span class="n">xMainBeam</span> <span class="o">&gt;=</span> <span class="n">coeff</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">hhpbw</span><span class="p">,</span> <span class="n">xMainBeam</span> <span class="o">&lt;=</span> <span class="n">coeff</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="n">hhpbw</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span>
                <span class="k">except</span><span class="p">:</span>
                    <span class="n">hmain_beamn</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span>
                        <span class="n">xMainBeam</span> <span class="o">&gt;=</span> <span class="o">-</span><span class="n">hhpbw</span><span class="p">,</span> <span class="n">xMainBeam</span> <span class="o">&lt;=</span> <span class="n">hhpbw</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span>

                <span class="c1"># Fit top 50% or 30% depending on sidelobe confirmation</span>
                <span class="k">if</span> <span class="n">sidelobes</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">hmain_beamp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">yMainBeam</span><span class="p">[</span><span class="n">hmain_beamn</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="mf">0.5</span><span class="o">*</span><span class="n">maxp</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
                    <span class="n">flag</span> <span class="o">=</span> <span class="mi">9</span>
                    <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;large sidelobes detected&quot;</span>
                    <span class="n">msg_wrapper</span><span class="p">(</span><span class="s2">&quot;warning&quot;</span><span class="p">,</span> <span class="n">log</span><span class="o">.</span><span class="n">warning</span><span class="p">,</span> <span class="n">msg</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">hmain_beamp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">yMainBeam</span><span class="p">[</span><span class="n">hmain_beamn</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="mf">0.7</span><span class="o">*</span><span class="n">maxp</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
                    <span class="n">flag</span> <span class="o">=</span> <span class="mi">0</span>

                <span class="k">if</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">hmain_beamp</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">hmain_beamn</span><span class="p">)</span> <span class="o">==</span><span class="mi">0</span><span class="p">:</span>
                    <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;couldn&#39;t find peak main beam data&quot;</span>
                    <span class="n">flag</span><span class="o">=</span><span class="mi">4</span>
                    <span class="n">msg_wrapper</span><span class="p">(</span><span class="s2">&quot;warning&quot;</span><span class="p">,</span> <span class="n">log</span><span class="o">.</span><span class="n">warning</span><span class="p">,</span> <span class="n">msg</span><span class="p">)</span>

                    <span class="c1"># find peak of spline</span>
                    <span class="n">sloc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">s</span> <span class="o">==</span> <span class="nb">max</span><span class="p">(</span><span class="n">s</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;sloc: &quot;</span><span class="p">,</span> <span class="n">sloc</span><span class="p">,</span> <span class="s2">&quot;, len: &quot;</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span>
                        <span class="n">yCorrected</span><span class="p">),</span> <span class="s2">&quot;, mid: &quot;</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">yCorrected</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span>

                    <span class="c1">#print(data)</span>
                    <span class="n">pl</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s2">&quot;Baseline corrected data&quot;</span><span class="p">)</span>
                    <span class="n">pl</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s2">&quot;Scandist [Deg]&quot;</span><span class="p">)</span>
                    <span class="n">pl</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s2">&quot;Ta [K]&quot;</span><span class="p">)</span>
                    <span class="n">pl</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">)</span>
                    <span class="n">pl</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">yCorrected</span><span class="p">,</span> <span class="s1">&#39;k&#39;</span><span class="p">,</span><span class="n">label</span><span class="o">=</span><span class="s2">&quot;baseline corrected data&quot;</span><span class="p">)</span>
                    <span class="n">pl</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">main_beam</span><span class="p">],</span> <span class="n">yCorrected</span><span class="p">[</span><span class="n">main_beam</span><span class="p">])</span>
                    <span class="n">pl</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">baseLocsl</span><span class="p">],</span> <span class="n">yCorrected</span><span class="p">[</span><span class="n">baseLocsl</span><span class="p">],</span><span class="s2">&quot;.&quot;</span><span class="p">)</span>
                    <span class="n">pl</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">baseLocsr</span><span class="p">],</span> <span class="n">yCorrected</span><span class="p">[</span><span class="n">baseLocsr</span><span class="p">],</span><span class="s2">&quot;.&quot;</span><span class="p">)</span>
                    <span class="c1">#pl.plot(x,s)</span>
                    <span class="n">pl</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">x</span><span class="p">),</span><span class="s1">&#39;k&#39;</span><span class="p">)</span>
                    <span class="c1">#pl.grid()</span>
                    <span class="n">pl</span><span class="o">.</span><span class="n">legend</span><span class="p">(</span><span class="n">loc</span><span class="o">=</span><span class="s2">&quot;best&quot;</span><span class="p">)</span>
                    <span class="c1">#pl.savefig(saveFolder+&quot;baseline_corrected_data.png&quot;)</span>
                    <span class="n">pl</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
                    <span class="n">pl</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>

                    <span class="n">sys</span><span class="o">.</span><span class="n">exit</span><span class="p">()</span>
                    
                    <span class="c1"># peak shifted left</span>
                    <span class="k">if</span> <span class="n">sloc</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">yCorrected</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span> <span class="ow">and</span> <span class="n">sloc</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Peak is shifted to left, but not first element&quot;</span><span class="p">)</span>
                        <span class="nb">print</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">sloc</span><span class="p">],</span> <span class="n">hhpbw</span><span class="p">)</span>

                        <span class="c1"># look for peak around new max loc</span>
                        <span class="n">beam</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span>
                            <span class="n">x</span> <span class="o">&gt;=</span> <span class="n">x</span><span class="p">[</span><span class="n">sloc</span><span class="p">]</span><span class="o">-</span><span class="n">hhpbw</span><span class="p">,</span> <span class="n">x</span> <span class="o">&lt;=</span> <span class="n">x</span><span class="p">[</span><span class="n">sloc</span><span class="p">]</span><span class="o">+</span><span class="n">hhpbw</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span>

                        <span class="c1"># fit peak</span>
                        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">beam</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                            <span class="n">ypeak</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">polyval</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">polyfit</span><span class="p">(</span>
                                    <span class="n">x</span><span class="p">[</span><span class="n">beam</span><span class="p">],</span> <span class="n">yCorrected</span><span class="p">[</span><span class="n">beam</span><span class="p">],</span>  <span class="mi">2</span><span class="p">),</span> <span class="n">x</span><span class="p">[</span><span class="n">beam</span><span class="p">])</span>

                            <span class="c1"># get residual and rms of peak fit</span>
                            <span class="n">fitRes</span><span class="p">,</span> <span class="n">err_peak</span> <span class="o">=</span> <span class="n">calc_residual</span><span class="p">(</span>
                                    <span class="n">yCorrected</span><span class="p">[</span><span class="n">beam</span><span class="p">],</span> <span class="n">ypeak</span><span class="p">)</span>

                            <span class="c1"># find final peak loc</span>
                            <span class="n">ploc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">ypeak</span> <span class="o">==</span> <span class="nb">max</span><span class="p">(</span><span class="n">ypeak</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span>
                            <span class="n">peakLoc</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">beam</span><span class="p">])[</span><span class="n">ploc</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
                            <span class="c1"># return max(ypeak), ypeak, err_peak, yCorrected, beam, msg, driftRes, driftRms, driftCoeffs, fitRes, </span>
                            <span class="c1"># np.nan, flag, baseLocsl, baseLocsr, baseLocs, peakLoc</span>
                            <span class="n">ret</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;peakFit&quot;</span><span class="p">:</span><span class="nb">max</span><span class="p">(</span><span class="n">ypeak</span><span class="p">),</span><span class="s2">&quot;peakModel&quot;</span><span class="p">:</span><span class="n">ypeak</span><span class="p">,</span> <span class="s2">&quot;peakRms&quot;</span><span class="p">:</span><span class="n">err_peak</span><span class="p">,</span><span class="s2">&quot;correctedData&quot;</span><span class="p">:</span><span class="n">yCorrected</span><span class="p">,</span><span class="s2">&quot;peakPts&quot;</span><span class="p">:</span><span class="n">beam</span><span class="p">,</span>
                                <span class="s2">&quot;msg&quot;</span><span class="p">:</span><span class="s2">&quot;&quot;</span><span class="p">,</span><span class="s2">&quot;driftRes&quot;</span><span class="p">:</span><span class="n">driftRes</span><span class="p">,</span><span class="s2">&quot;driftRms&quot;</span><span class="p">:</span><span class="n">driftRms</span><span class="p">,</span><span class="s2">&quot;driftCoeffs&quot;</span><span class="p">:</span><span class="n">driftCoeffs</span><span class="p">,</span><span class="s2">&quot;fitRes&quot;</span><span class="p">:</span><span class="n">fitRes</span><span class="p">,</span><span class="s2">&quot;midXValue&quot;</span><span class="p">:</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span>
                                <span class="s2">&quot;flag&quot;</span><span class="p">:</span><span class="n">flag</span><span class="p">,</span><span class="s2">&quot;baseLocsLeft&quot;</span><span class="p">:</span><span class="n">baseLocsl</span><span class="p">,</span><span class="s2">&quot;baseLocsRight&quot;</span><span class="p">:</span><span class="n">baseLocsr</span><span class="p">,</span><span class="s2">&quot;baseLocsCombined&quot;</span><span class="p">:</span><span class="n">baseLocs</span><span class="p">,</span><span class="s2">&quot;peakLoc&quot;</span><span class="p">:</span><span class="n">peakLoc</span><span class="p">,</span>
                                <span class="s2">&quot;baseLeft&quot;</span><span class="p">:[],</span><span class="s2">&quot;baseRight&quot;</span><span class="p">:[]</span>
                            <span class="p">}</span>
                            <span class="k">return</span> <span class="n">ret</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="c1"># couldn&#39;t locate peak</span>
                            <span class="c1"># return np.nan, [], np.nan, [], [], msg, [], [], [], [], np.nan, flag, [], [], [], np.nan,0,0</span>
                            <span class="k">return</span> <span class="p">{</span><span class="s2">&quot;peakFit&quot;</span><span class="p">:</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span><span class="s2">&quot;peakModel&quot;</span><span class="p">:[],</span><span class="s2">&quot;peakRms&quot;</span><span class="p">:</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span><span class="s2">&quot;correctedData&quot;</span><span class="p">:[],</span><span class="s2">&quot;peakPts&quot;</span><span class="p">:[],</span><span class="s2">&quot;msg&quot;</span><span class="p">:</span><span class="n">msg</span><span class="p">,</span>
                                <span class="s2">&quot;driftRes&quot;</span><span class="p">:[],</span><span class="s2">&quot;driftRms&quot;</span><span class="p">:[],</span><span class="s2">&quot;driftCoeffs&quot;</span><span class="p">:[],</span><span class="s2">&quot;fitRes&quot;</span><span class="p">:[],</span><span class="s2">&quot;midXValue&quot;</span><span class="p">:</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span><span class="s2">&quot;flag&quot;</span><span class="p">:</span><span class="n">flag</span><span class="p">,</span>
                                <span class="s2">&quot;baseLocsLeft&quot;</span><span class="p">:[],</span><span class="s2">&quot;baseLocsRight&quot;</span><span class="p">:[],</span><span class="s2">&quot;baseLocsCombined&quot;</span><span class="p">:[],</span><span class="s2">&quot;peakLoc&quot;</span><span class="p">:</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span><span class="s2">&quot;baseLeft&quot;</span><span class="p">:[],</span>
                                <span class="s2">&quot;baseRight&quot;</span><span class="p">:[]}</span>

                    <span class="k">else</span><span class="p">:</span>
                        <span class="c1"># peak shifted right</span>

                        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Peak is shifted to left, but not first element&quot;</span><span class="p">)</span>
                        <span class="nb">print</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">sloc</span><span class="p">],</span> <span class="n">hhpbw</span><span class="p">)</span>

                        <span class="c1"># look for peak around new max loc</span>
                        <span class="n">beam</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span>
                            <span class="n">x</span> <span class="o">&gt;=</span> <span class="n">x</span><span class="p">[</span><span class="n">sloc</span><span class="p">]</span><span class="o">-</span><span class="n">hhpbw</span><span class="p">,</span> <span class="n">x</span> <span class="o">&lt;=</span> <span class="n">x</span><span class="p">[</span><span class="n">sloc</span><span class="p">]</span><span class="o">+</span><span class="n">hhpbw</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span>

                        <span class="c1"># fit peak</span>
                        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">beam</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                            <span class="n">ypeak</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">polyval</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">polyfit</span><span class="p">(</span>
                                    <span class="n">x</span><span class="p">[</span><span class="n">beam</span><span class="p">],</span> <span class="n">yCorrected</span><span class="p">[</span><span class="n">beam</span><span class="p">],</span>  <span class="mi">2</span><span class="p">),</span> <span class="n">x</span><span class="p">[</span><span class="n">beam</span><span class="p">])</span>

                            <span class="c1"># get residual and rms of peak fit</span>
                            <span class="n">fitRes</span><span class="p">,</span> <span class="n">err_peak</span> <span class="o">=</span> <span class="n">calc_residual</span><span class="p">(</span>
                                    <span class="n">yCorrected</span><span class="p">[</span><span class="n">beam</span><span class="p">],</span> <span class="n">ypeak</span><span class="p">)</span>

                            <span class="c1"># find final peak loc</span>
                            <span class="n">ploc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">ypeak</span> <span class="o">==</span> <span class="nb">max</span><span class="p">(</span><span class="n">ypeak</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span>
                            <span class="n">peakLoc</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">beam</span><span class="p">])[</span><span class="n">ploc</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>

                            <span class="c1">#sys.exit()</span>
                            <span class="c1"># return max(ypeak), ypeak, err_peak, yCorrected, beam, msg, driftRes, driftRms, driftCoeffs, fitRes, np.nan, </span>
                            <span class="c1"># flag, baseLocsl, baseLocsr, baseLocs, peakLoc</span>
                            <span class="k">return</span> <span class="p">{</span><span class="s2">&quot;peakFit&quot;</span><span class="p">:</span><span class="nb">max</span><span class="p">(</span><span class="n">ypeak</span><span class="p">),</span><span class="s2">&quot;peakModel&quot;</span><span class="p">:</span><span class="n">ypeak</span><span class="p">,</span> <span class="s2">&quot;peakRms&quot;</span><span class="p">:</span><span class="n">err_peak</span><span class="p">,</span><span class="s2">&quot;correctedData&quot;</span><span class="p">:</span><span class="n">yCorrected</span><span class="p">,</span><span class="s2">&quot;peakPts&quot;</span><span class="p">:</span><span class="n">beam</span><span class="p">,</span>
                                <span class="s2">&quot;msg&quot;</span><span class="p">:</span><span class="s2">&quot;&quot;</span><span class="p">,</span><span class="s2">&quot;driftRes&quot;</span><span class="p">:</span><span class="n">driftRes</span><span class="p">,</span><span class="s2">&quot;driftRms&quot;</span><span class="p">:</span><span class="n">driftRms</span><span class="p">,</span><span class="s2">&quot;driftCoeffs&quot;</span><span class="p">:</span><span class="n">driftCoeffs</span><span class="p">,</span><span class="s2">&quot;fitRes&quot;</span><span class="p">:</span><span class="n">fitRes</span><span class="p">,</span><span class="s2">&quot;midXValue&quot;</span><span class="p">:</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span>
                                <span class="s2">&quot;flag&quot;</span><span class="p">:</span><span class="n">flag</span><span class="p">,</span><span class="s2">&quot;baseLocsLeft&quot;</span><span class="p">:</span><span class="n">baseLocsl</span><span class="p">,</span><span class="s2">&quot;baseLocsRight&quot;</span><span class="p">:</span><span class="n">baseLocsr</span><span class="p">,</span><span class="s2">&quot;baseLocsCombined&quot;</span><span class="p">:</span><span class="n">baseLocs</span><span class="p">,</span><span class="s2">&quot;peakLoc&quot;</span><span class="p">:</span><span class="n">peakLoc</span><span class="p">,</span>
                                <span class="s2">&quot;baseLeft&quot;</span><span class="p">:[],</span><span class="s2">&quot;baseRight&quot;</span><span class="p">:[]</span>
                            <span class="p">}</span>
                        
                    <span class="c1"># return np.nan, [], np.nan, [], [], msg, [], [], [], [], np.nan, flag, [], [], [],np.nan</span>
                    <span class="k">return</span> <span class="p">{</span><span class="s2">&quot;peakFit&quot;</span><span class="p">:</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span><span class="s2">&quot;peakModel&quot;</span><span class="p">:[],</span><span class="s2">&quot;peakRms&quot;</span><span class="p">:</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span><span class="s2">&quot;correctedData&quot;</span><span class="p">:[],</span><span class="s2">&quot;peakPts&quot;</span><span class="p">:[],</span><span class="s2">&quot;msg&quot;</span><span class="p">:</span><span class="n">msg</span><span class="p">,</span>
                        <span class="s2">&quot;driftRes&quot;</span><span class="p">:[],</span><span class="s2">&quot;driftRms&quot;</span><span class="p">:[],</span><span class="s2">&quot;driftCoeffs&quot;</span><span class="p">:[],</span><span class="s2">&quot;fitRes&quot;</span><span class="p">:[],</span><span class="s2">&quot;midXValue&quot;</span><span class="p">:</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span><span class="s2">&quot;flag&quot;</span><span class="p">:</span><span class="n">flag</span><span class="p">,</span>
                        <span class="s2">&quot;baseLocsLeft&quot;</span><span class="p">:[],</span><span class="s2">&quot;baseLocsRight&quot;</span><span class="p">:[],</span><span class="s2">&quot;baseLocsCombined&quot;</span><span class="p">:[],</span><span class="s2">&quot;peakLoc&quot;</span><span class="p">:</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span><span class="s2">&quot;baseLeft&quot;</span><span class="p">:[],</span>
                        <span class="s2">&quot;baseRight&quot;</span><span class="p">:[]}</span>
                
                <span class="n">hmain_beam</span> <span class="o">=</span> <span class="n">hmain_beamp</span> <span class="o">+</span> <span class="n">hmain_beamn</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">+</span><span class="n">main_beam</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

                <span class="k">if</span> <span class="n">hmain_beam</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">baseLocsr</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="ow">or</span> <span class="n">hmain_beam</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">baseLocsl</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
                    <span class="c1"># peak loctaion is beyond fnbw locations</span>
                    <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;peak location is beyond fnbw locations&quot;</span>
                    <span class="n">msg_wrapper</span><span class="p">(</span><span class="s2">&quot;warning&quot;</span><span class="p">,</span> <span class="n">log</span><span class="o">.</span><span class="n">warning</span><span class="p">,</span> <span class="n">msg</span><span class="p">)</span>
                    <span class="n">flag</span> <span class="o">=</span> <span class="mi">24</span>
                    <span class="c1"># return np.nan, [], np.nan, [], [], msg, [], [], [], [], np.nan, flag, [], [], [],np.nan</span>
                    <span class="k">return</span> <span class="p">{</span><span class="s2">&quot;peakFit&quot;</span><span class="p">:</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span><span class="s2">&quot;peakModel&quot;</span><span class="p">:[],</span><span class="s2">&quot;peakRms&quot;</span><span class="p">:</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span><span class="s2">&quot;correctedData&quot;</span><span class="p">:[],</span><span class="s2">&quot;peakPts&quot;</span><span class="p">:[],</span><span class="s2">&quot;msg&quot;</span><span class="p">:</span><span class="n">msg</span><span class="p">,</span>
                        <span class="s2">&quot;driftRes&quot;</span><span class="p">:[],</span><span class="s2">&quot;driftRms&quot;</span><span class="p">:[],</span><span class="s2">&quot;driftCoeffs&quot;</span><span class="p">:[],</span><span class="s2">&quot;fitRes&quot;</span><span class="p">:[],</span><span class="s2">&quot;midXValue&quot;</span><span class="p">:</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span><span class="s2">&quot;flag&quot;</span><span class="p">:</span><span class="n">flag</span><span class="p">,</span>
                        <span class="s2">&quot;baseLocsLeft&quot;</span><span class="p">:[],</span><span class="s2">&quot;baseLocsRight&quot;</span><span class="p">:[],</span><span class="s2">&quot;baseLocsCombined&quot;</span><span class="p">:[],</span><span class="s2">&quot;peakLoc&quot;</span><span class="p">:</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span><span class="s2">&quot;baseLeft&quot;</span><span class="p">:[],</span>
                        <span class="s2">&quot;baseRight&quot;</span><span class="p">:[]}</span>

                <span class="c1"># fit a polynomial to peak data</span>
                <span class="n">ypeak</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">polyval</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">polyfit</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">hmain_beam</span><span class="p">],</span>
                                            <span class="n">yCorrected</span><span class="p">[</span><span class="n">hmain_beam</span><span class="p">],</span>  <span class="mi">2</span><span class="p">),</span> <span class="n">x</span><span class="p">[</span><span class="n">hmain_beam</span><span class="p">])</span>

                <span class="c1"># check if peak was fit correctly</span>
                <span class="k">if</span> <span class="nb">max</span><span class="p">(</span><span class="n">ypeak</span><span class="p">)</span> <span class="o">==</span> <span class="n">ypeak</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">or</span> <span class="nb">max</span><span class="p">(</span><span class="n">ypeak</span><span class="p">)</span> <span class="o">==</span> <span class="n">ypeak</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
                    <span class="c1"># peak is concave, try fitting wider range</span>
                    <span class="n">hmain_beamp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">yMainBeam</span><span class="p">[</span><span class="n">hmain_beamn</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="mf">0.5</span><span class="o">*</span><span class="n">maxp</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
                    <span class="n">hmain_beam</span> <span class="o">=</span> <span class="n">hmain_beamp</span> <span class="o">+</span> <span class="n">hmain_beamn</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">+</span><span class="n">main_beam</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                    <span class="n">ypeak</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">polyval</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">polyfit</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">hmain_beam</span><span class="p">],</span>
                                                <span class="n">yCorrected</span><span class="p">[</span><span class="n">hmain_beam</span><span class="p">],</span>  <span class="mi">2</span><span class="p">),</span> <span class="n">x</span><span class="p">[</span><span class="n">hmain_beam</span><span class="p">])</span>

                    <span class="k">if</span> <span class="p">(</span><span class="nb">max</span><span class="p">(</span><span class="n">ypeak</span><span class="p">)</span> <span class="o">==</span> <span class="n">ypeak</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="ow">or</span> <span class="p">(</span><span class="nb">max</span><span class="p">(</span><span class="n">ypeak</span><span class="p">)</span> <span class="o">==</span> <span class="n">ypeak</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]):</span>
                        <span class="c1"># still struggling to fit ?, stop fitting</span>
                        <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;failed to accurately establish peak fit location, 1&quot;</span>
                        <span class="n">msg_wrapper</span><span class="p">(</span><span class="s2">&quot;warning&quot;</span><span class="p">,</span> <span class="n">log</span><span class="o">.</span><span class="n">warning</span><span class="p">,</span> <span class="n">msg</span><span class="p">)</span>
                        <span class="n">flag</span> <span class="o">=</span> <span class="mi">5</span>

                        <span class="n">pl</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s2">&quot;Plot of baseline corrected data&quot;</span><span class="p">)</span>
                        <span class="n">pl</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s2">&quot;Scandist [Deg]&quot;</span><span class="p">)</span>
                        <span class="n">pl</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s2">&quot;Ta [K]&quot;</span><span class="p">)</span>
                        <span class="c1">#pl.plot(x,y)</span>
                        <span class="n">pl</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">yCorrected</span><span class="p">,</span> <span class="s1">&#39;k&#39;</span><span class="p">,</span><span class="n">label</span><span class="o">=</span><span class="s2">&quot;baseline corrected data&quot;</span><span class="p">)</span>
                        <span class="n">pl</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">s</span><span class="p">)</span>
                        <span class="n">pl</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">hmain_beamp</span><span class="p">],</span> <span class="n">yCorrected</span><span class="p">[</span><span class="n">hmain_beamp</span><span class="p">],</span><span class="n">label</span><span class="o">=</span><span class="n">msg</span><span class="p">)</span>
                        <span class="n">pl</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">baseLocsl</span><span class="p">],</span> <span class="n">yCorrected</span><span class="p">[</span><span class="n">baseLocsl</span><span class="p">],</span><span class="s2">&quot;.&quot;</span><span class="p">)</span>
                        <span class="n">pl</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">baseLocsr</span><span class="p">],</span> <span class="n">yCorrected</span><span class="p">[</span><span class="n">baseLocsr</span><span class="p">],</span><span class="s2">&quot;.&quot;</span><span class="p">)</span>
                        <span class="c1">#pl.plot(x,s)</span>
                        <span class="n">pl</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">x</span><span class="p">),</span><span class="s1">&#39;k&#39;</span><span class="p">)</span>
                        <span class="n">pl</span><span class="o">.</span><span class="n">grid</span><span class="p">()</span>
                        <span class="n">pl</span><span class="o">.</span><span class="n">legend</span><span class="p">(</span><span class="n">loc</span><span class="o">=</span><span class="s2">&quot;best&quot;</span><span class="p">)</span>
                        <span class="c1">#pl.savefig(saveFolder+&quot;baseline_corrected_data.png&quot;)</span>
                        <span class="c1">#pl.show()</span>
                        <span class="n">pl</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
                        <span class="c1">#sys.exit()</span>
                        
                        <span class="c1"># find peak of spline</span>
                        <span class="n">sloc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">s</span><span class="o">==</span><span class="nb">max</span><span class="p">(</span><span class="n">s</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span>
                        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;sloc: &quot;</span><span class="p">,</span><span class="n">sloc</span><span class="p">,</span><span class="s2">&quot;, len: &quot;</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">yCorrected</span><span class="p">),</span><span class="s2">&quot;, mid: &quot;</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="n">yCorrected</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span>

                        <span class="c1"># peak shifted left</span>
                        <span class="k">if</span> <span class="n">sloc</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">yCorrected</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span> <span class="ow">and</span> <span class="n">sloc</span><span class="o">!=</span><span class="mi">0</span><span class="p">:</span>
                            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Peak is shifted to left, but not first element&quot;</span><span class="p">)</span>
                            <span class="nb">print</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">sloc</span><span class="p">],</span><span class="n">hhpbw</span><span class="p">)</span>

                            <span class="c1"># look for peak around new max loc</span>
                            <span class="n">beam</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span>
                                <span class="n">x</span> <span class="o">&gt;=</span> <span class="n">x</span><span class="p">[</span><span class="n">sloc</span><span class="p">]</span><span class="o">-</span><span class="n">hhpbw</span><span class="p">,</span> <span class="n">x</span> <span class="o">&lt;=</span> <span class="n">x</span><span class="p">[</span><span class="n">sloc</span><span class="p">]</span><span class="o">+</span><span class="n">hhpbw</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span>

                            <span class="c1"># fit peak</span>
                            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">beam</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                                <span class="n">ypeak</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">polyval</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">polyfit</span><span class="p">(</span>
                                    <span class="n">x</span><span class="p">[</span><span class="n">beam</span><span class="p">],</span> <span class="n">yCorrected</span><span class="p">[</span><span class="n">beam</span><span class="p">],</span>  <span class="mi">2</span><span class="p">),</span> <span class="n">x</span><span class="p">[</span><span class="n">beam</span><span class="p">])</span>

                                <span class="c1"># get residual and rms of peak fit</span>
                                <span class="n">fitRes</span><span class="p">,</span> <span class="n">err_peak</span> <span class="o">=</span> <span class="n">calc_residual</span><span class="p">(</span><span class="n">yCorrected</span><span class="p">[</span><span class="n">beam</span><span class="p">],</span> <span class="n">ypeak</span><span class="p">)</span>

                                <span class="c1"># find final peak loc</span>
                                <span class="n">ploc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">ypeak</span> <span class="o">==</span> <span class="nb">max</span><span class="p">(</span><span class="n">ypeak</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span>
                                <span class="n">peakLoc</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">beam</span><span class="p">])[</span><span class="n">ploc</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
                                

                                <span class="c1"># return max(ypeak), ypeak, err_peak, yCorrected, beam, msg, driftRes, driftRms, driftCoeffs, fitRes, np.nan, </span>
                                <span class="c1"># flag, baseLocsl, baseLocsr, baseLocs,peakLoc</span>
                                <span class="k">return</span> <span class="p">{</span>
                                    <span class="s2">&quot;peakFit&quot;</span><span class="p">:</span><span class="nb">max</span><span class="p">(</span><span class="n">ypeak</span><span class="p">),</span><span class="s2">&quot;peakModel&quot;</span><span class="p">:</span><span class="n">ypeak</span><span class="p">,</span> <span class="s2">&quot;peakRms&quot;</span><span class="p">:</span><span class="n">err_peak</span><span class="p">,</span><span class="s2">&quot;correctedData&quot;</span><span class="p">:</span><span class="n">yCorrected</span><span class="p">,</span><span class="s2">&quot;peakPts&quot;</span><span class="p">:</span><span class="n">beam</span><span class="p">,</span>
                                    <span class="s2">&quot;msg&quot;</span><span class="p">:</span><span class="s2">&quot;&quot;</span><span class="p">,</span><span class="s2">&quot;driftRes&quot;</span><span class="p">:</span><span class="n">driftRes</span><span class="p">,</span><span class="s2">&quot;driftRms&quot;</span><span class="p">:</span><span class="n">driftRms</span><span class="p">,</span><span class="s2">&quot;driftCoeffs&quot;</span><span class="p">:</span><span class="n">driftCoeffs</span><span class="p">,</span><span class="s2">&quot;fitRes&quot;</span><span class="p">:</span><span class="n">fitRes</span><span class="p">,</span><span class="s2">&quot;midXValue&quot;</span><span class="p">:</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span>
                                    <span class="s2">&quot;flag&quot;</span><span class="p">:</span><span class="n">flag</span><span class="p">,</span><span class="s2">&quot;baseLocsLeft&quot;</span><span class="p">:</span><span class="n">baseLocsl</span><span class="p">,</span><span class="s2">&quot;baseLocsRight&quot;</span><span class="p">:</span><span class="n">baseLocsr</span><span class="p">,</span><span class="s2">&quot;baseLocsCombined&quot;</span><span class="p">:</span><span class="n">baseLocs</span><span class="p">,</span><span class="s2">&quot;peakLoc&quot;</span><span class="p">:</span><span class="n">peakLoc</span><span class="p">,</span>
                                    <span class="s2">&quot;baseLeft&quot;</span><span class="p">:[],</span><span class="s2">&quot;baseRight&quot;</span><span class="p">:[],</span>
                                <span class="p">}</span>
                            <span class="k">else</span><span class="p">:</span>
                                <span class="c1"># couldn&#39;t locate peak</span>
                                <span class="c1"># return np.nan, [], np.nan, [], [], msg, [], [], [], [], np.nan, flag, [], [], [],np.nan</span>
                                <span class="k">return</span> <span class="p">{</span><span class="s2">&quot;peakFit&quot;</span><span class="p">:</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span><span class="s2">&quot;peakModel&quot;</span><span class="p">:[],</span><span class="s2">&quot;peakRms&quot;</span><span class="p">:</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span><span class="s2">&quot;correctedData&quot;</span><span class="p">:[],</span><span class="s2">&quot;peakPts&quot;</span><span class="p">:[],</span><span class="s2">&quot;msg&quot;</span><span class="p">:</span><span class="n">msg</span><span class="p">,</span>
                                    <span class="s2">&quot;driftRes&quot;</span><span class="p">:[],</span><span class="s2">&quot;driftRms&quot;</span><span class="p">:[],</span><span class="s2">&quot;driftCoeffs&quot;</span><span class="p">:[],</span><span class="s2">&quot;fitRes&quot;</span><span class="p">:[],</span><span class="s2">&quot;midXValue&quot;</span><span class="p">:</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span><span class="s2">&quot;flag&quot;</span><span class="p">:</span><span class="n">flag</span><span class="p">,</span>
                                    <span class="s2">&quot;baseLocsLeft&quot;</span><span class="p">:[],</span><span class="s2">&quot;baseLocsRight&quot;</span><span class="p">:[],</span><span class="s2">&quot;baseLocsCombined&quot;</span><span class="p">:[],</span><span class="s2">&quot;peakLoc&quot;</span><span class="p">:</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span><span class="s2">&quot;baseLeft&quot;</span><span class="p">:[],</span>
                                    <span class="s2">&quot;baseRight&quot;</span><span class="p">:[]}</span>

                        <span class="n">sys</span><span class="o">.</span><span class="n">exit</span><span class="p">()</span>
                        <span class="c1"># return np.nan, [], np.nan, [], [], msg, [], [], [], [], np.nan, flag, [], [], [],np.nan</span>
                        <span class="k">return</span> <span class="p">{</span><span class="s2">&quot;peakFit&quot;</span><span class="p">:</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span><span class="s2">&quot;peakModel&quot;</span><span class="p">:[],</span><span class="s2">&quot;peakRms&quot;</span><span class="p">:</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span><span class="s2">&quot;correctedData&quot;</span><span class="p">:[],</span><span class="s2">&quot;peakPts&quot;</span><span class="p">:[],</span><span class="s2">&quot;msg&quot;</span><span class="p">:</span><span class="n">msg</span><span class="p">,</span>
                            <span class="s2">&quot;driftRes&quot;</span><span class="p">:[],</span><span class="s2">&quot;driftRms&quot;</span><span class="p">:[],</span><span class="s2">&quot;driftCoeffs&quot;</span><span class="p">:[],</span><span class="s2">&quot;fitRes&quot;</span><span class="p">:[],</span><span class="s2">&quot;midXValue&quot;</span><span class="p">:</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span><span class="s2">&quot;flag&quot;</span><span class="p">:</span><span class="n">flag</span><span class="p">,</span>
                            <span class="s2">&quot;baseLocsLeft&quot;</span><span class="p">:[],</span><span class="s2">&quot;baseLocsRight&quot;</span><span class="p">:[],</span><span class="s2">&quot;baseLocsCombined&quot;</span><span class="p">:[],</span><span class="s2">&quot;peakLoc&quot;</span><span class="p">:</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span><span class="s2">&quot;baseLeft&quot;</span><span class="p">:[],</span>
                            <span class="s2">&quot;baseRight&quot;</span><span class="p">:[]}</span>

                <span class="c1"># get residual and rms of peak fit</span>
                <span class="n">fitRes</span><span class="p">,</span> <span class="n">err_peak</span> <span class="o">=</span> <span class="n">calc_residual</span><span class="p">(</span><span class="n">yCorrected</span><span class="p">[</span><span class="n">hmain_beam</span><span class="p">],</span> <span class="n">ypeak</span><span class="p">)</span>

                <span class="c1"># find final peak loc</span>
                <span class="n">ploc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">ypeak</span> <span class="o">==</span> <span class="nb">max</span><span class="p">(</span><span class="n">ypeak</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">peakLoc</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">hmain_beam</span><span class="p">])[</span><span class="n">ploc</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
                
                <span class="c1"># return max(ypeak), ypeak, err_peak, yCorrected, hmain_beam, &quot;&quot;, driftRes, driftRms, driftCoeffs, fitRes, np.nan, </span>
                <span class="c1"># flag, baseLocsl, baseLocsr, baseLocs,peakLoc</span>
                <span class="k">return</span> <span class="p">{</span>
                        <span class="s2">&quot;peakFit&quot;</span><span class="p">:</span><span class="nb">max</span><span class="p">(</span><span class="n">ypeak</span><span class="p">),</span><span class="s2">&quot;peakModel&quot;</span><span class="p">:</span><span class="n">ypeak</span><span class="p">,</span> <span class="s2">&quot;peakRms&quot;</span><span class="p">:</span><span class="n">err_peak</span><span class="p">,</span><span class="s2">&quot;correctedData&quot;</span><span class="p">:</span><span class="n">yCorrected</span><span class="p">,</span><span class="s2">&quot;peakPts&quot;</span><span class="p">:</span><span class="n">hmain_beam</span><span class="p">,</span>
                        <span class="s2">&quot;msg&quot;</span><span class="p">:</span><span class="s2">&quot;&quot;</span><span class="p">,</span><span class="s2">&quot;driftRes&quot;</span><span class="p">:</span><span class="n">driftRes</span><span class="p">,</span><span class="s2">&quot;driftRms&quot;</span><span class="p">:</span><span class="n">driftRms</span><span class="p">,</span><span class="s2">&quot;driftCoeffs&quot;</span><span class="p">:</span><span class="n">driftCoeffs</span><span class="p">,</span><span class="s2">&quot;fitRes&quot;</span><span class="p">:</span><span class="n">fitRes</span><span class="p">,</span><span class="s2">&quot;midXValue&quot;</span><span class="p">:</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span>
                        <span class="s2">&quot;flag&quot;</span><span class="p">:</span><span class="n">flag</span><span class="p">,</span><span class="s2">&quot;baseLocsLeft&quot;</span><span class="p">:</span><span class="n">baseLocsl</span><span class="p">,</span><span class="s2">&quot;baseLocsRight&quot;</span><span class="p">:</span><span class="n">baseLocsr</span><span class="p">,</span><span class="s2">&quot;baseLocsCombined&quot;</span><span class="p">:</span><span class="n">baseLocs</span><span class="p">,</span><span class="s2">&quot;peakLoc&quot;</span><span class="p">:</span><span class="n">peakLoc</span><span class="p">,</span>
                        <span class="s2">&quot;baseLeft&quot;</span><span class="p">:[],</span><span class="s2">&quot;baseRight&quot;</span><span class="p">:[]</span>
                    <span class="p">}</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">flag</span> <span class="o">=</span> <span class="mi">37</span>
                <span class="c1"># return np.nan, [], np.nan, [], [], msg, [], [], [], [], np.nan, flag, [], [], [],np.nan,0,0</span>
                <span class="k">return</span> <span class="p">{</span><span class="s2">&quot;peakFit&quot;</span><span class="p">:</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span><span class="s2">&quot;peakModel&quot;</span><span class="p">:[],</span><span class="s2">&quot;peakRms&quot;</span><span class="p">:</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span><span class="s2">&quot;correctedData&quot;</span><span class="p">:[],</span><span class="s2">&quot;peakPts&quot;</span><span class="p">:[],</span><span class="s2">&quot;msg&quot;</span><span class="p">:</span><span class="n">msg</span><span class="p">,</span>
                        <span class="s2">&quot;driftRes&quot;</span><span class="p">:[],</span><span class="s2">&quot;driftRms&quot;</span><span class="p">:[],</span><span class="s2">&quot;driftCoeffs&quot;</span><span class="p">:[],</span><span class="s2">&quot;fitRes&quot;</span><span class="p">:[],</span><span class="s2">&quot;midXValue&quot;</span><span class="p">:</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span><span class="s2">&quot;flag&quot;</span><span class="p">:</span><span class="n">flag</span><span class="p">,</span>
                        <span class="s2">&quot;baseLocsLeft&quot;</span><span class="p">:[],</span><span class="s2">&quot;baseLocsRight&quot;</span><span class="p">:[],</span><span class="s2">&quot;baseLocsCombined&quot;</span><span class="p">:[],</span><span class="s2">&quot;peakLoc&quot;</span><span class="p">:</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span><span class="s2">&quot;baseLeft&quot;</span><span class="p">:[],</span>
                        <span class="s2">&quot;baseRight&quot;</span><span class="p">:[]}</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">pass</span>

        <span class="c1"># 2) correct the drift in the data and get the residual and rms</span>
        <span class="n">dataModel</span><span class="p">,</span> <span class="n">driftModel</span><span class="p">,</span> <span class="n">driftRes</span><span class="p">,</span> <span class="n">driftRms</span><span class="p">,</span> <span class="n">driftCoeffs</span> <span class="o">=</span> <span class="n">correct_drift</span><span class="p">(</span>
            <span class="n">x</span><span class="p">[</span><span class="n">baseLocs</span><span class="p">],</span> <span class="n">y</span><span class="p">[</span><span class="n">baseLocs</span><span class="p">],</span> <span class="n">x</span><span class="p">,</span><span class="n">log</span><span class="p">)</span>

        <span class="c1"># 3) GET LOCATIONS OF DATA FOR THE MAIN BEAM ONLY</span>
        <span class="c1"># this is limited by the fnbw</span>
        <span class="c1"># check peak is at centre</span>
        <span class="n">main_beam</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span>
            <span class="n">x</span> <span class="o">&gt;=</span> <span class="n">coeff</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">hfnbw</span><span class="p">,</span> <span class="n">x</span> <span class="o">&lt;=</span> <span class="n">coeff</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="n">hfnbw</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">lin_first_null</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">poly1d</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">polyfit</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">baseLocs</span><span class="p">],</span> <span class="n">y</span><span class="p">[</span><span class="n">baseLocs</span><span class="p">],</span> <span class="mi">1</span><span class="p">))</span> <span class="c1"># 4) apply a polynomial fit to the baseline data</span>
        <span class="n">yCorrected</span> <span class="o">=</span> <span class="n">y</span> <span class="o">-</span> <span class="n">lin_first_null</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="c1"># 5) Subtract the polynomial fitted to the baseline to get corrected beam</span>
        <span class="n">s</span> <span class="o">=</span> <span class="n">spline</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">yCorrected</span><span class="p">)</span> <span class="c1"># 6) get spline of corrected data</span>

        <span class="n">saveTo</span><span class="o">=</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">saveTag</span><span class="si">}</span><span class="s1">corrected.png&#39;</span>
        <span class="n">plotCorrectedData</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">yCorrected</span><span class="p">,</span><span class="n">baseLocsl</span><span class="p">,</span><span class="n">baseLocsr</span><span class="p">,</span><span class="s2">&quot;baseline corrected data&quot;</span><span class="p">,</span><span class="s1">&#39;baseLocs&#39;</span><span class="p">,</span><span class="s1">&#39;Plot of corrected data&#39;</span><span class="p">,</span><span class="n">saveTo</span><span class="p">)</span>

        <span class="c1"># 7. Fit the peak</span>
        <span class="c1"># find max location</span>
        <span class="n">msg_wrapper</span><span class="p">(</span><span class="s2">&quot;info&quot;</span><span class="p">,</span> <span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">,</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="n">msg_wrapper</span><span class="p">(</span><span class="s2">&quot;info&quot;</span><span class="p">,</span> <span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">,</span> <span class="s2">&quot;-&quot;</span><span class="o">*</span><span class="mi">30</span><span class="p">)</span>
        <span class="n">msg_wrapper</span><span class="p">(</span><span class="s2">&quot;info&quot;</span><span class="p">,</span> <span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">,</span> <span class="s2">&quot;Fit the peak&quot;</span><span class="p">)</span>
        <span class="n">msg_wrapper</span><span class="p">(</span><span class="s2">&quot;info&quot;</span><span class="p">,</span> <span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">,</span><span class="s2">&quot;-&quot;</span><span class="o">*</span><span class="mi">30</span><span class="p">)</span>
        <span class="n">maxp</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
        <span class="n">maxloc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">s</span> <span class="o">==</span> <span class="n">maxp</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="c1"># xmaxloc = x[maxloc[0]]</span>

        <span class="c1"># max is not at center, found at extreme ends of scan</span>
        <span class="k">if</span> <span class="p">(</span><span class="nb">max</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="o">==</span> <span class="n">s</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="ow">or</span> <span class="p">(</span><span class="nb">max</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="o">==</span> <span class="n">s</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]):</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;max of peak is not at center, failed peak fit &quot;</span>
            <span class="n">msg_wrapper</span><span class="p">(</span><span class="s2">&quot;warning&quot;</span><span class="p">,</span> <span class="n">log</span><span class="o">.</span><span class="n">warning</span><span class="p">,</span> <span class="n">msg</span><span class="p">)</span>
            <span class="n">flag</span>  <span class="o">=</span> <span class="mi">10</span>
            <span class="c1"># return np.nan, [], np.nan, [], [], msg, [], [], [], [], np.nan, flag, [], [], [],np.nan,0,0</span>
            <span class="k">return</span> <span class="p">{</span><span class="s2">&quot;peakFit&quot;</span><span class="p">:</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span><span class="s2">&quot;peakModel&quot;</span><span class="p">:[],</span><span class="s2">&quot;peakRms&quot;</span><span class="p">:</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span><span class="s2">&quot;correctedData&quot;</span><span class="p">:[],</span><span class="s2">&quot;peakPts&quot;</span><span class="p">:[],</span><span class="s2">&quot;msg&quot;</span><span class="p">:</span><span class="n">msg</span><span class="p">,</span>
                        <span class="s2">&quot;driftRes&quot;</span><span class="p">:[],</span><span class="s2">&quot;driftRms&quot;</span><span class="p">:[],</span><span class="s2">&quot;driftCoeffs&quot;</span><span class="p">:[],</span><span class="s2">&quot;fitRes&quot;</span><span class="p">:[],</span><span class="s2">&quot;midXValue&quot;</span><span class="p">:</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span><span class="s2">&quot;flag&quot;</span><span class="p">:</span><span class="n">flag</span><span class="p">,</span>
                        <span class="s2">&quot;baseLocsLeft&quot;</span><span class="p">:[],</span><span class="s2">&quot;baseLocsRight&quot;</span><span class="p">:[],</span><span class="s2">&quot;baseLocsCombined&quot;</span><span class="p">:[],</span><span class="s2">&quot;peakLoc&quot;</span><span class="p">:</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span><span class="s2">&quot;baseLeft&quot;</span><span class="p">:[],</span>
                        <span class="s2">&quot;baseRight&quot;</span><span class="p">:[]}</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">pass</span>

        <span class="c1"># 7) Get indices where the x values are within the main beam</span>
        <span class="c1"># Get top 30% of beam</span>
        <span class="n">xMainBeam</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="n">main_beam</span><span class="p">]</span>
        <span class="n">yMainBeam</span> <span class="o">=</span> <span class="n">s</span><span class="p">[</span><span class="n">main_beam</span><span class="p">]</span>
    
        <span class="k">try</span><span class="p">:</span>
            <span class="n">maxs</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="n">main_beam</span><span class="p">])</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;max of peak is not at center, failed peak fit &quot;</span>
            <span class="n">msg_wrapper</span><span class="p">(</span><span class="s2">&quot;warning&quot;</span><span class="p">,</span> <span class="n">log</span><span class="o">.</span><span class="n">warning</span><span class="p">,</span> <span class="n">msg</span><span class="p">)</span>
            <span class="n">flag</span>  <span class="o">=</span> <span class="mi">10</span>
            <span class="c1"># return np.nan, [], np.nan, [], [], msg, [], [], [], [], np.nan, flag, [], [], [],np.nan,0,0</span>
            <span class="k">return</span> <span class="p">{</span><span class="s2">&quot;peakFit&quot;</span><span class="p">:</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span><span class="s2">&quot;peakModel&quot;</span><span class="p">:[],</span><span class="s2">&quot;peakRms&quot;</span><span class="p">:</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span><span class="s2">&quot;correctedData&quot;</span><span class="p">:[],</span><span class="s2">&quot;peakPts&quot;</span><span class="p">:[],</span><span class="s2">&quot;msg&quot;</span><span class="p">:</span><span class="n">msg</span><span class="p">,</span>
                        <span class="s2">&quot;driftRes&quot;</span><span class="p">:[],</span><span class="s2">&quot;driftRms&quot;</span><span class="p">:[],</span><span class="s2">&quot;driftCoeffs&quot;</span><span class="p">:[],</span><span class="s2">&quot;fitRes&quot;</span><span class="p">:[],</span><span class="s2">&quot;midXValue&quot;</span><span class="p">:</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span><span class="s2">&quot;flag&quot;</span><span class="p">:</span><span class="n">flag</span><span class="p">,</span>
                        <span class="s2">&quot;baseLocsLeft&quot;</span><span class="p">:[],</span><span class="s2">&quot;baseLocsRight&quot;</span><span class="p">:[],</span><span class="s2">&quot;baseLocsCombined&quot;</span><span class="p">:[],</span><span class="s2">&quot;peakLoc&quot;</span><span class="p">:</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span><span class="s2">&quot;baseLeft&quot;</span><span class="p">:[],</span>
                        <span class="s2">&quot;baseRight&quot;</span><span class="p">:[]}</span>
            
        <span class="n">loc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="n">main_beam</span><span class="p">]</span> <span class="o">==</span> <span class="n">maxs</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">midxMainBeam</span> <span class="o">=</span> <span class="n">xMainBeam</span><span class="p">[</span><span class="n">loc</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>  

        <span class="c1"># Try to fit a gaussian to confirm center peak location after correction of scan</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">p0</span><span class="o">=</span><span class="p">[</span><span class="n">maxs</span><span class="p">,</span> <span class="n">midxMainBeam</span><span class="p">,</span> <span class="n">p</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
            <span class="n">coeff</span><span class="p">,</span> <span class="n">covarMatrix</span> <span class="o">=</span> <span class="n">curve_fit</span><span class="p">(</span><span class="n">gauss_lin</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span><span class="n">yCorrected</span><span class="p">,</span> <span class="n">p0</span><span class="p">)</span>
            <span class="n">fit</span> <span class="o">=</span> <span class="n">gauss_lin</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="o">*</span><span class="n">coeff</span><span class="p">)</span>
            <span class="c1"># coeff, fit = fit_gauss_lin(</span>
            <span class="c1">#     x, yCorrected, [maxs, midxMainBeam, p[2], 0, 0])</span>
        <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;couldnt find max in main beam&quot;</span>
            <span class="n">msg_wrapper</span><span class="p">(</span><span class="s2">&quot;warning&quot;</span><span class="p">,</span> <span class="n">log</span><span class="o">.</span><span class="n">warning</span><span class="p">,</span> <span class="n">msg</span><span class="p">)</span>
            <span class="n">flag</span> <span class="o">=</span> <span class="mi">11</span>
            <span class="c1"># return np.nan, [], np.nan, [], [], msg, [], [], [], [], np.nan, flag, [], [], [],np.nan,0,0</span>
            <span class="k">return</span> <span class="p">{</span><span class="s2">&quot;peakFit&quot;</span><span class="p">:</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span><span class="s2">&quot;peakModel&quot;</span><span class="p">:[],</span><span class="s2">&quot;peakRms&quot;</span><span class="p">:</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span><span class="s2">&quot;correctedData&quot;</span><span class="p">:[],</span><span class="s2">&quot;peakPts&quot;</span><span class="p">:[],</span><span class="s2">&quot;msg&quot;</span><span class="p">:</span><span class="n">msg</span><span class="p">,</span>
                        <span class="s2">&quot;driftRes&quot;</span><span class="p">:[],</span><span class="s2">&quot;driftRms&quot;</span><span class="p">:[],</span><span class="s2">&quot;driftCoeffs&quot;</span><span class="p">:[],</span><span class="s2">&quot;fitRes&quot;</span><span class="p">:[],</span><span class="s2">&quot;midXValue&quot;</span><span class="p">:</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span><span class="s2">&quot;flag&quot;</span><span class="p">:</span><span class="n">flag</span><span class="p">,</span>
                        <span class="s2">&quot;baseLocsLeft&quot;</span><span class="p">:[],</span><span class="s2">&quot;baseLocsRight&quot;</span><span class="p">:[],</span><span class="s2">&quot;baseLocsCombined&quot;</span><span class="p">:[],</span><span class="s2">&quot;peakLoc&quot;</span><span class="p">:</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span><span class="s2">&quot;baseLeft&quot;</span><span class="p">:[],</span>
                        <span class="s2">&quot;baseRight&quot;</span><span class="p">:[]}</span>

        <span class="c1"># Get main beam for peak fitting</span>
        <span class="n">hmain_beamn</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span>
            <span class="n">xMainBeam</span> <span class="o">&gt;=</span> <span class="n">coeff</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">hhpbw</span><span class="p">,</span> <span class="n">xMainBeam</span> <span class="o">&lt;=</span> <span class="n">coeff</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="n">hhpbw</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span>

        <span class="c1"># Fit top 50% or 30% depending on sidelobe confirmation</span>
        <span class="k">if</span> <span class="n">sidelobes</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">hmain_beamp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">yMainBeam</span><span class="p">[</span><span class="n">hmain_beamn</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="mf">0.5</span><span class="o">*</span><span class="n">maxp</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">flag</span> <span class="o">=</span> <span class="mi">9</span>
            <span class="n">msg_wrapper</span><span class="p">(</span><span class="s2">&quot;warning&quot;</span><span class="p">,</span> <span class="n">log</span><span class="o">.</span><span class="n">warning</span><span class="p">,</span> <span class="s2">&quot;large sidelobes detected&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">hmain_beamp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">yMainBeam</span><span class="p">[</span><span class="n">hmain_beamn</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="mf">0.7</span><span class="o">*</span><span class="n">maxp</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">flag</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="k">if</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">hmain_beamp</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">hmain_beamn</span><span class="p">)</span> <span class="o">==</span><span class="mi">0</span><span class="p">:</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;couldn&#39;t find peak main beam data&quot;</span>
            <span class="n">flag</span><span class="o">=</span><span class="mi">4</span>
            <span class="n">msg_wrapper</span><span class="p">(</span><span class="s2">&quot;warning&quot;</span><span class="p">,</span> <span class="n">log</span><span class="o">.</span><span class="n">warning</span><span class="p">,</span> <span class="n">msg</span><span class="p">)</span>
            <span class="c1"># sys.exit()</span>
            <span class="c1">#print(data)</span>
            <span class="c1"># pl.title(&quot;Baseline corrected data&quot;)</span>
            <span class="c1"># pl.xlabel(&quot;Scandist [Deg]&quot;)</span>
            <span class="c1"># pl.ylabel(&quot;Ta [K]&quot;)</span>
            <span class="c1"># pl.plot(x,y)</span>
            <span class="c1"># #pl.plot(x, yCorrected, &#39;k&#39;,label=&quot;baseline corrected data&quot;)</span>
            <span class="c1"># pl.plot(x[main_beam], yCorrected[main_beam])</span>
            <span class="c1"># pl.plot(x[baseLocsl], yCorrected[baseLocsl],&quot;.&quot;)</span>
            <span class="c1"># pl.plot(x[baseLocsr], yCorrected[baseLocsr],&quot;.&quot;)</span>
            <span class="c1"># #pl.plot(x,s)</span>
            <span class="c1"># pl.plot(x,np.zeros_like(x),&#39;k&#39;)</span>
            <span class="c1"># #pl.grid()</span>
            <span class="c1"># pl.legend(loc=&quot;best&quot;)</span>
            <span class="c1"># #pl.savefig(saveFolder+&quot;baseline_corrected_data.png&quot;)</span>
            <span class="c1"># #pl.show()</span>
            <span class="c1"># pl.close()</span>
            <span class="c1"># #sys.exit()</span>
            <span class="c1"># #sys.exit()</span>
            
            <span class="c1"># return np.nan, [], np.nan, [], [], msg, [], [], [], [], np.nan, flag, [], [], [], np.nan,0,0</span>
            <span class="k">return</span> <span class="p">{</span><span class="s2">&quot;peakFit&quot;</span><span class="p">:</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span><span class="s2">&quot;peakModel&quot;</span><span class="p">:[],</span><span class="s2">&quot;peakRms&quot;</span><span class="p">:</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span><span class="s2">&quot;correctedData&quot;</span><span class="p">:[],</span><span class="s2">&quot;peakPts&quot;</span><span class="p">:[],</span><span class="s2">&quot;msg&quot;</span><span class="p">:</span><span class="n">msg</span><span class="p">,</span>
                        <span class="s2">&quot;driftRes&quot;</span><span class="p">:[],</span><span class="s2">&quot;driftRms&quot;</span><span class="p">:[],</span><span class="s2">&quot;driftCoeffs&quot;</span><span class="p">:[],</span><span class="s2">&quot;fitRes&quot;</span><span class="p">:[],</span><span class="s2">&quot;midXValue&quot;</span><span class="p">:</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span><span class="s2">&quot;flag&quot;</span><span class="p">:</span><span class="n">flag</span><span class="p">,</span>
                        <span class="s2">&quot;baseLocsLeft&quot;</span><span class="p">:[],</span><span class="s2">&quot;baseLocsRight&quot;</span><span class="p">:[],</span><span class="s2">&quot;baseLocsCombined&quot;</span><span class="p">:[],</span><span class="s2">&quot;peakLoc&quot;</span><span class="p">:</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span><span class="s2">&quot;baseLeft&quot;</span><span class="p">:[],</span>
                        <span class="s2">&quot;baseRight&quot;</span><span class="p">:[]}</span>
        
        <span class="k">if</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">hmain_beamp</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mf">0.5</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="n">hmain_beamn</span><span class="p">)):</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;peak main beam data too noisy&quot;</span>
            <span class="n">flag</span> <span class="o">=</span> <span class="mi">23</span>
            <span class="n">msg_wrapper</span><span class="p">(</span><span class="s2">&quot;warning&quot;</span><span class="p">,</span> <span class="n">log</span><span class="o">.</span><span class="n">warning</span><span class="p">,</span> <span class="n">msg</span><span class="p">)</span>
            <span class="c1"># sys.exit()</span>
            <span class="c1"># return np.nan, [], np.nan, [], [], msg, [], [], [], [], np.nan, flag, [], [], [],np.nan,0,0</span>
            <span class="k">return</span> <span class="p">{</span><span class="s2">&quot;peakFit&quot;</span><span class="p">:</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span><span class="s2">&quot;peakModel&quot;</span><span class="p">:[],</span><span class="s2">&quot;peakRms&quot;</span><span class="p">:</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span><span class="s2">&quot;correctedData&quot;</span><span class="p">:[],</span><span class="s2">&quot;peakPts&quot;</span><span class="p">:[],</span><span class="s2">&quot;msg&quot;</span><span class="p">:</span><span class="n">msg</span><span class="p">,</span>
                        <span class="s2">&quot;driftRes&quot;</span><span class="p">:[],</span><span class="s2">&quot;driftRms&quot;</span><span class="p">:[],</span><span class="s2">&quot;driftCoeffs&quot;</span><span class="p">:[],</span><span class="s2">&quot;fitRes&quot;</span><span class="p">:[],</span><span class="s2">&quot;midXValue&quot;</span><span class="p">:</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span><span class="s2">&quot;flag&quot;</span><span class="p">:</span><span class="n">flag</span><span class="p">,</span>
                        <span class="s2">&quot;baseLocsLeft&quot;</span><span class="p">:[],</span><span class="s2">&quot;baseLocsRight&quot;</span><span class="p">:[],</span><span class="s2">&quot;baseLocsCombined&quot;</span><span class="p">:[],</span><span class="s2">&quot;peakLoc&quot;</span><span class="p">:</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span><span class="s2">&quot;baseLeft&quot;</span><span class="p">:[],</span>
                        <span class="s2">&quot;baseRight&quot;</span><span class="p">:[]}</span>
        
        <span class="n">hmain_beam</span> <span class="o">=</span> <span class="n">hmain_beamp</span> <span class="o">+</span> <span class="n">hmain_beamn</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">+</span><span class="n">main_beam</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">hmain_beam</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">baseLocsr</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="ow">or</span> <span class="n">hmain_beam</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">baseLocsl</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
            <span class="c1"># peak loctaion is beyond fnbw locations</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;peak location is beyond fnbw locations&quot;</span>
            <span class="n">msg_wrapper</span><span class="p">(</span><span class="s2">&quot;warning&quot;</span><span class="p">,</span> <span class="n">log</span><span class="o">.</span><span class="n">warning</span><span class="p">,</span> <span class="n">msg</span><span class="p">)</span>
            <span class="n">flag</span> <span class="o">=</span> <span class="mi">24</span>
            <span class="c1"># sys.exit()</span>
            <span class="c1"># return np.nan, [], np.nan, [], [], msg, [], [], [], [], np.nan, flag, [], [], [],np.nan,0,0</span>
            <span class="k">return</span> <span class="p">{</span><span class="s2">&quot;peakFit&quot;</span><span class="p">:</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span><span class="s2">&quot;peakModel&quot;</span><span class="p">:[],</span><span class="s2">&quot;peakRms&quot;</span><span class="p">:</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span><span class="s2">&quot;correctedData&quot;</span><span class="p">:[],</span><span class="s2">&quot;peakPts&quot;</span><span class="p">:[],</span><span class="s2">&quot;msg&quot;</span><span class="p">:</span><span class="n">msg</span><span class="p">,</span>
                        <span class="s2">&quot;driftRes&quot;</span><span class="p">:[],</span><span class="s2">&quot;driftRms&quot;</span><span class="p">:[],</span><span class="s2">&quot;driftCoeffs&quot;</span><span class="p">:[],</span><span class="s2">&quot;fitRes&quot;</span><span class="p">:[],</span><span class="s2">&quot;midXValue&quot;</span><span class="p">:</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span><span class="s2">&quot;flag&quot;</span><span class="p">:</span><span class="n">flag</span><span class="p">,</span>
                        <span class="s2">&quot;baseLocsLeft&quot;</span><span class="p">:[],</span><span class="s2">&quot;baseLocsRight&quot;</span><span class="p">:[],</span><span class="s2">&quot;baseLocsCombined&quot;</span><span class="p">:[],</span><span class="s2">&quot;peakLoc&quot;</span><span class="p">:</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span><span class="s2">&quot;baseLeft&quot;</span><span class="p">:[],</span>
                        <span class="s2">&quot;baseRight&quot;</span><span class="p">:[]}</span>

        <span class="c1"># fit a polynomial to peak data</span>
        <span class="n">ypeak</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">polyval</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">polyfit</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">hmain_beam</span><span class="p">],</span>
                                    <span class="n">yCorrected</span><span class="p">[</span><span class="n">hmain_beam</span><span class="p">],</span>  <span class="mi">2</span><span class="p">),</span> <span class="n">x</span><span class="p">[</span><span class="n">hmain_beam</span><span class="p">])</span>

        <span class="c1"># # check if peak was fit correctly</span>
        <span class="n">msg</span><span class="o">=</span><span class="sa">f</span><span class="s1">&#39;Test fit makes sense - left: </span><span class="si">{</span><span class="n">ypeak</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">:</span><span class="s1">.3f</span><span class="si">}</span><span class="s1">, center: </span><span class="si">{</span><span class="nb">max</span><span class="p">(</span><span class="n">ypeak</span><span class="p">)</span><span class="si">:</span><span class="s1">.3f</span><span class="si">}</span><span class="s1">, right: </span><span class="si">{</span><span class="n">ypeak</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="si">:</span><span class="s1">.3f</span><span class="si">}</span><span class="s1">&#39;</span>
        <span class="n">msg_wrapper</span><span class="p">(</span><span class="s2">&quot;debug&quot;</span><span class="p">,</span> <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">,</span> <span class="n">msg</span><span class="p">)</span>
        <span class="c1"># print(max(ypeak),ypeak[0],ypeak[-1])</span>
        <span class="k">if</span> <span class="nb">max</span><span class="p">(</span><span class="n">ypeak</span><span class="p">)</span> <span class="o">==</span> <span class="n">ypeak</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">or</span> <span class="nb">max</span><span class="p">(</span><span class="n">ypeak</span><span class="p">)</span> <span class="o">==</span> <span class="n">ypeak</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>

            <span class="c1"># peak is concave, try fitting wider range</span>
            <span class="n">hmain_beamp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">yMainBeam</span><span class="p">[</span><span class="n">hmain_beamn</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="mf">0.5</span><span class="o">*</span><span class="n">maxp</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">hmain_beam</span> <span class="o">=</span> <span class="n">hmain_beamp</span> <span class="o">+</span> <span class="n">hmain_beamn</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">+</span><span class="n">main_beam</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">ypeak</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">polyval</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">polyfit</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">hmain_beam</span><span class="p">],</span>
                                        <span class="n">yCorrected</span><span class="p">[</span><span class="n">hmain_beam</span><span class="p">],</span>  <span class="mi">2</span><span class="p">),</span> <span class="n">x</span><span class="p">[</span><span class="n">hmain_beam</span><span class="p">])</span>

            <span class="k">if</span> <span class="p">(</span><span class="nb">max</span><span class="p">(</span><span class="n">ypeak</span><span class="p">)</span> <span class="o">==</span> <span class="n">ypeak</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="ow">or</span> <span class="p">(</span><span class="nb">max</span><span class="p">(</span><span class="n">ypeak</span><span class="p">)</span> <span class="o">==</span> <span class="n">ypeak</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]):</span>
                <span class="c1"># still struggling to fit ?, try this then stop fitting</span>

                <span class="k">try</span><span class="p">:</span>
                    <span class="c1"># LOCATE LOCAL MINUMUM/MAXIMUM POSITIONS</span>
                    <span class="c1"># these values are used to figure out where to</span>
                    <span class="c1"># select our baseline points/locations</span>
                    <span class="n">localMinPositions</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sign</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">s</span><span class="p">)))</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">nonzero</span><span class="p">()[</span>
                        <span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span>  <span class="c1"># local min positions / first nulls</span>
                    <span class="n">localMaxPositions</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sign</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">s</span><span class="p">)))</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">nonzero</span><span class="p">()[</span>
                        <span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span>  <span class="c1"># local max positions / peak</span>

                    <span class="n">msg</span><span class="o">=</span><span class="sa">f</span><span class="s1">&#39;mins: </span><span class="si">{</span><span class="n">localMinPositions</span><span class="si">}</span><span class="s1">, maxs: </span><span class="si">{</span><span class="n">localMaxPositions</span><span class="si">}</span><span class="s1">&#39;</span>
                    <span class="n">msg_wrapper</span><span class="p">(</span><span class="s2">&quot;debug&quot;</span><span class="p">,</span> <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">,</span> <span class="n">msg</span><span class="p">)</span>


                    <span class="c1"># find peak closest to zero</span>
                    <span class="n">locs</span><span class="o">=</span><span class="n">x</span><span class="p">[</span><span class="n">localMaxPositions</span><span class="p">]</span>
                    <span class="n">k</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">locs</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span><span class="nb">abs</span><span class="p">(</span><span class="n">x</span><span class="o">-</span><span class="mi">0</span><span class="p">))</span>
                    <span class="n">locs</span><span class="o">=</span><span class="nb">list</span><span class="p">(</span><span class="n">locs</span><span class="p">)</span>
                    <span class="c1">#print(f&#39;locs: {locs}, k: {k}&#39;)</span>
                    <span class="n">msg</span><span class="o">=</span><span class="sa">f</span><span class="s1">&#39;pos of possible center peak: </span><span class="si">{</span><span class="n">locs</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">k</span><span class="p">)</span><span class="si">}</span><span class="s1">&#39;</span>
                    <span class="n">msg_wrapper</span><span class="p">(</span><span class="s2">&quot;debug&quot;</span><span class="p">,</span> <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">,</span> <span class="n">msg</span><span class="p">)</span>

                    <span class="c1"># use this peak as the main peak</span>
                    <span class="n">kpos</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">x</span><span class="o">==</span><span class="n">k</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
                    <span class="n">msg</span><span class="o">=</span><span class="sa">f</span><span class="s1">&#39;peak is at loc: </span><span class="si">{</span><span class="n">kpos</span><span class="si">}</span><span class="s1">&#39;</span>
                    <span class="n">msg_wrapper</span><span class="p">(</span><span class="s2">&quot;debug&quot;</span><span class="p">,</span> <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">,</span> <span class="n">msg</span><span class="p">)</span>
                    <span class="n">ymax</span><span class="o">=</span><span class="n">s</span><span class="p">[</span><span class="n">kpos</span><span class="p">]</span> <span class="c1">#max(s)</span>
                    <span class="n">yhalf</span><span class="o">=</span> <span class="n">ymax</span><span class="o">/</span><span class="mi">2</span>

                    <span class="c1"># find surrounding mins</span>
                    <span class="n">l</span><span class="o">=</span><span class="nb">min</span><span class="p">(</span><span class="n">localMinPositions</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span><span class="nb">abs</span><span class="p">(</span><span class="n">x</span><span class="o">-</span><span class="n">kpos</span><span class="p">))</span>
                    <span class="n">ppos</span><span class="o">=</span><span class="nb">list</span><span class="p">(</span><span class="n">localMinPositions</span><span class="p">)</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">l</span><span class="p">)</span>
                    <span class="c1"># print(l,ppos,kpos)</span>
                    <span class="c1"># print(localMinPositions)</span>
                    <span class="k">if</span> <span class="n">l</span><span class="o">&gt;</span><span class="n">kpos</span><span class="p">:</span>
                        <span class="n">v</span><span class="o">=</span><span class="p">[</span><span class="n">localMinPositions</span><span class="p">[</span><span class="n">ppos</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span><span class="n">localMinPositions</span><span class="p">[</span><span class="n">ppos</span><span class="p">]]</span>
                        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;window - &#39;</span><span class="p">,</span><span class="n">localMinPositions</span><span class="p">[</span><span class="n">ppos</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span><span class="n">kpos</span><span class="p">,</span><span class="n">localMinPositions</span><span class="p">[</span><span class="n">ppos</span><span class="p">])</span>
                        <span class="n">left</span><span class="o">=</span><span class="n">localMinPositions</span><span class="p">[</span><span class="n">ppos</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                        <span class="n">right</span><span class="o">=</span><span class="n">localMinPositions</span><span class="p">[</span><span class="n">ppos</span><span class="p">]</span>
                    <span class="k">elif</span> <span class="n">l</span> <span class="o">&lt;</span> <span class="n">kpos</span><span class="p">:</span>
                        <span class="nb">print</span><span class="p">(</span><span class="n">localMinPositions</span><span class="p">[</span><span class="n">ppos</span><span class="p">],</span><span class="n">kpos</span><span class="p">,</span><span class="n">localMinPositions</span><span class="p">[</span><span class="n">ppos</span><span class="o">+</span><span class="mi">1</span><span class="p">])</span>
                        <span class="n">left</span><span class="o">=</span><span class="n">localMinPositions</span><span class="p">[</span><span class="n">ppos</span><span class="p">]</span>
                        <span class="n">right</span><span class="o">=</span><span class="n">localMinPositions</span><span class="p">[</span><span class="n">ppos</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span>
                        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;l &lt; kpos&#39;</span><span class="p">)</span>
                        <span class="c1">#sys.exit()</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="nb">print</span><span class="p">(</span><span class="n">localMinPositions</span><span class="p">[</span><span class="n">ppos</span><span class="p">],</span><span class="n">kpos</span><span class="p">,</span><span class="n">localMinPositions</span><span class="p">[</span><span class="n">ppos</span><span class="o">+</span><span class="mi">1</span><span class="p">])</span>
                        <span class="n">left</span><span class="o">=</span><span class="n">localMinPositions</span><span class="p">[</span><span class="n">ppos</span><span class="p">]</span>
                        <span class="n">right</span><span class="o">=</span><span class="n">localMinPositions</span><span class="p">[</span><span class="n">ppos</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span>
                        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;l ? kpos&#39;</span><span class="p">)</span>
                        <span class="n">sys</span><span class="o">.</span><span class="n">exit</span><span class="p">()</span>
                    <span class="n">top</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">((</span><span class="n">s</span> <span class="o">&gt;=</span> <span class="n">yhalf</span><span class="p">)</span><span class="o">&amp;</span><span class="p">(</span><span class="n">x</span><span class="o">&gt;</span><span class="n">x</span><span class="p">[</span><span class="n">left</span><span class="p">])</span><span class="o">&amp;</span><span class="p">(</span><span class="n">x</span><span class="o">&lt;</span><span class="n">x</span><span class="p">[</span><span class="n">right</span><span class="p">]))</span>
                
                    <span class="c1"># peak is concave, try fitting wider range</span>
                    <span class="n">hmain_beamp</span> <span class="o">=</span> <span class="n">top</span><span class="c1">#np.where(yMainBeam[hmain_beamn] &gt;= 0.5*maxp)[0]</span>
                    <span class="c1">#hmain_beam = hmain_beamp + hmain_beamn[0]+main_beam[0]</span>
                    <span class="n">ypeak</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">polyval</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">polyfit</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">hmain_beamp</span><span class="p">],</span>
                                                <span class="n">yCorrected</span><span class="p">[</span><span class="n">hmain_beamp</span><span class="p">],</span>  <span class="mi">2</span><span class="p">),</span> <span class="n">x</span><span class="p">[</span><span class="n">hmain_beamp</span><span class="p">])</span>
                                                
                    <span class="c1"># get residual and rms of peak fit</span>
                    <span class="n">fitRes</span><span class="p">,</span> <span class="n">err_peak</span> <span class="o">=</span> <span class="n">calc_residual</span><span class="p">(</span><span class="n">yCorrected</span><span class="p">[</span><span class="n">hmain_beamp</span><span class="p">],</span> <span class="n">ypeak</span><span class="p">)</span>

                    <span class="c1"># find final peak loc</span>
                    <span class="c1">#ploc = np.where(ypeak == max(ypeak))[0]</span>
                    <span class="n">peakLoc</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">kpos</span><span class="p">])</span><span class="c1">#[ploc[0]]</span>
                    
                    <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;attempted to accurately establish peak fit location&quot;</span>
                    <span class="n">msg_wrapper</span><span class="p">(</span><span class="s2">&quot;warning&quot;</span><span class="p">,</span> <span class="n">log</span><span class="o">.</span><span class="n">warning</span><span class="p">,</span> <span class="n">msg</span><span class="p">)</span>
                    <span class="n">flag</span> <span class="o">=</span> <span class="mi">37</span>

                    
                    <span class="n">sys</span><span class="o">.</span><span class="n">exit</span><span class="p">()</span>
                    <span class="n">pl</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s2">&quot;Plot of final peak fitted data&quot;</span><span class="p">)</span>
                    <span class="n">pl</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s2">&quot;Scandist [Deg]&quot;</span><span class="p">)</span>
                    <span class="n">pl</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s2">&quot;Ta [K]&quot;</span><span class="p">)</span>
                    <span class="n">pl</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">yCorrected</span><span class="p">,</span> <span class="s2">&quot;k&quot;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s2">&quot;corrected data&quot;</span><span class="p">)</span>
                    <span class="c1">#pl.plot(x[main_beam],yCorrected[main_beam])</span>
                    <span class="n">pl</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">hmain_beamp</span><span class="p">],</span> <span class="n">yCorrected</span><span class="p">[</span><span class="n">hmain_beamp</span><span class="p">])</span>
                    <span class="c1">#pl.plot(x,fit)</span>
                    <span class="n">pl</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">hmain_beamp</span><span class="p">],</span><span class="n">ypeak</span><span class="p">,</span><span class="s2">&quot;r&quot;</span><span class="p">,</span><span class="n">label</span><span class="o">=</span><span class="s2">&quot;Ta[K] = </span><span class="si">%.3f</span><span class="s2"> +- </span><span class="si">%.3f</span><span class="s2">&quot;</span> <span class="o">%</span><span class="p">(</span><span class="nb">max</span><span class="p">(</span><span class="n">ypeak</span><span class="p">),</span><span class="n">err_peak</span><span class="p">))</span>
                    <span class="n">pl</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">scanLen</span><span class="p">),</span><span class="s2">&quot;k&quot;</span><span class="p">)</span>
                    <span class="c1">#pl.grid()</span>
                    <span class="n">pl</span><span class="o">.</span><span class="n">legend</span><span class="p">(</span><span class="n">loc</span><span class="o">=</span><span class="s2">&quot;best&quot;</span><span class="p">)</span>
                    <span class="k">try</span><span class="p">:</span>
                        <span class="n">pl</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="n">saveFolder</span><span class="o">+</span><span class="s2">&quot;peak_fit_data.png&quot;</span><span class="p">)</span>
                    <span class="k">except</span><span class="p">:</span>
                        <span class="k">pass</span>
                    <span class="c1">#pl.show()</span>
                    <span class="n">pl</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
                    <span class="c1">#sys.exit()</span>

                    <span class="k">return</span> <span class="p">{</span>
                        <span class="s2">&quot;peakFit&quot;</span><span class="p">:</span><span class="nb">max</span><span class="p">(</span><span class="n">ypeak</span><span class="p">),</span><span class="s2">&quot;peakModel&quot;</span><span class="p">:</span><span class="n">ypeak</span><span class="p">,</span> <span class="s2">&quot;peakRms&quot;</span><span class="p">:</span><span class="n">err_peak</span><span class="p">,</span><span class="s2">&quot;correctedData&quot;</span><span class="p">:</span><span class="n">yCorrected</span><span class="p">,</span><span class="s2">&quot;peakPts&quot;</span><span class="p">:</span><span class="n">hmain_beamp</span><span class="p">,</span>
                        <span class="s2">&quot;msg&quot;</span><span class="p">:</span><span class="s2">&quot;&quot;</span><span class="p">,</span><span class="s2">&quot;driftRes&quot;</span><span class="p">:</span><span class="n">driftRes</span><span class="p">,</span><span class="s2">&quot;driftRms&quot;</span><span class="p">:</span><span class="n">driftRms</span><span class="p">,</span><span class="s2">&quot;driftCoeffs&quot;</span><span class="p">:</span><span class="n">driftCoeffs</span><span class="p">,</span><span class="s2">&quot;fitRes&quot;</span><span class="p">:</span><span class="n">fitRes</span><span class="p">,</span><span class="s2">&quot;midXValue&quot;</span><span class="p">:</span><span class="n">coeff</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
                        <span class="s2">&quot;flag&quot;</span><span class="p">:</span><span class="n">flag</span><span class="p">,</span><span class="s2">&quot;baseLocsLeft&quot;</span><span class="p">:</span><span class="n">baseLocsl</span><span class="p">,</span><span class="s2">&quot;baseLocsRight&quot;</span><span class="p">:</span><span class="n">baseLocsr</span><span class="p">,</span><span class="s2">&quot;baseLocsCombined&quot;</span><span class="p">:</span><span class="n">baseLocs</span><span class="p">,</span><span class="s2">&quot;peakLoc&quot;</span><span class="p">:</span><span class="n">peakLoc</span><span class="p">,</span>
                        <span class="s2">&quot;baseLeft&quot;</span><span class="p">:</span><span class="n">lb</span><span class="p">,</span><span class="s2">&quot;baseRight&quot;</span><span class="p">:</span><span class="n">rb</span><span class="p">,</span>
                    <span class="p">}</span>
                    <span class="c1"># return max(ypeak), ypeak, err_peak, yCorrected, hmain_beamp, &quot;&quot;, driftRes, driftRms, driftCoeffs, fitRes, </span>
                    <span class="c1"># coeff[1], flag, baseLocsl, baseLocsr, baseLocs, peakLoc,lb,rb</span>
                    
                <span class="k">except</span><span class="p">:</span>
                    <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;failed to accurately establish peak fit location&quot;</span>
                    <span class="n">msg_wrapper</span><span class="p">(</span><span class="s2">&quot;warning&quot;</span><span class="p">,</span> <span class="n">log</span><span class="o">.</span><span class="n">warning</span><span class="p">,</span> <span class="n">msg</span><span class="p">)</span>
                    <span class="n">flag</span> <span class="o">=</span> <span class="mi">5</span>
                    <span class="nb">print</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
                    <span class="c1"># sys.exit()</span>
                    <span class="c1"># return np.nan, [], np.nan, [], [], msg, [], [], [], [], np.nan, flag, [], [], [],np.nan,0,0</span>
                    <span class="k">return</span> <span class="p">{</span><span class="s2">&quot;peakFit&quot;</span><span class="p">:</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span><span class="s2">&quot;peakModel&quot;</span><span class="p">:[],</span><span class="s2">&quot;peakRms&quot;</span><span class="p">:</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span><span class="s2">&quot;correctedData&quot;</span><span class="p">:[],</span><span class="s2">&quot;peakPts&quot;</span><span class="p">:[],</span><span class="s2">&quot;msg&quot;</span><span class="p">:</span><span class="n">msg</span><span class="p">,</span>
                        <span class="s2">&quot;driftRes&quot;</span><span class="p">:[],</span><span class="s2">&quot;driftRms&quot;</span><span class="p">:[],</span><span class="s2">&quot;driftCoeffs&quot;</span><span class="p">:[],</span><span class="s2">&quot;fitRes&quot;</span><span class="p">:[],</span><span class="s2">&quot;midXValue&quot;</span><span class="p">:</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span><span class="s2">&quot;flag&quot;</span><span class="p">:</span><span class="n">flag</span><span class="p">,</span>
                        <span class="s2">&quot;baseLocsLeft&quot;</span><span class="p">:[],</span><span class="s2">&quot;baseLocsRight&quot;</span><span class="p">:[],</span><span class="s2">&quot;baseLocsCombined&quot;</span><span class="p">:[],</span><span class="s2">&quot;peakLoc&quot;</span><span class="p">:</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span><span class="s2">&quot;baseLeft&quot;</span><span class="p">:[],</span>
                        <span class="s2">&quot;baseRight&quot;</span><span class="p">:[]}</span>

        <span class="c1"># print(max(ypeak),ypeak[0],ypeak[-1],abs(min(yCorrected)) &gt; max(yCorrected))</span>
        <span class="k">if</span> <span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="nb">min</span><span class="p">(</span><span class="n">yCorrected</span><span class="p">))</span> <span class="o">&gt;</span> <span class="nb">max</span><span class="p">(</span><span class="n">yCorrected</span><span class="p">)):</span>
            <span class="c1"># still struggling to fit ?, stop fitting</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;min &gt; max&quot;</span>
            <span class="n">msg_wrapper</span><span class="p">(</span><span class="s2">&quot;warning&quot;</span><span class="p">,</span> <span class="n">log</span><span class="o">.</span><span class="n">warning</span><span class="p">,</span> <span class="n">msg</span><span class="p">)</span>
            <span class="n">flag</span> <span class="o">=</span> <span class="mi">25</span>
            <span class="c1"># sys.exit()</span>
            <span class="k">if</span> <span class="n">force</span><span class="o">==</span><span class="s2">&quot;y&quot;</span><span class="p">:</span>
                <span class="k">pass</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># return np.nan, [], np.nan, [], [], msg, [], [], [], [], np.nan, flag, [], [], [],np.nan,0,0</span>
                <span class="k">return</span> <span class="p">{</span><span class="s2">&quot;peakFit&quot;</span><span class="p">:</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span><span class="s2">&quot;peakModel&quot;</span><span class="p">:[],</span><span class="s2">&quot;peakRms&quot;</span><span class="p">:</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span><span class="s2">&quot;correctedData&quot;</span><span class="p">:[],</span><span class="s2">&quot;peakPts&quot;</span><span class="p">:[],</span><span class="s2">&quot;msg&quot;</span><span class="p">:</span><span class="n">msg</span><span class="p">,</span>
                        <span class="s2">&quot;driftRes&quot;</span><span class="p">:[],</span><span class="s2">&quot;driftRms&quot;</span><span class="p">:[],</span><span class="s2">&quot;driftCoeffs&quot;</span><span class="p">:[],</span><span class="s2">&quot;fitRes&quot;</span><span class="p">:[],</span><span class="s2">&quot;midXValue&quot;</span><span class="p">:</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span><span class="s2">&quot;flag&quot;</span><span class="p">:</span><span class="n">flag</span><span class="p">,</span>
                        <span class="s2">&quot;baseLocsLeft&quot;</span><span class="p">:[],</span><span class="s2">&quot;baseLocsRight&quot;</span><span class="p">:[],</span><span class="s2">&quot;baseLocsCombined&quot;</span><span class="p">:[],</span><span class="s2">&quot;peakLoc&quot;</span><span class="p">:</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span><span class="s2">&quot;baseLeft&quot;</span><span class="p">:[],</span>
                        <span class="s2">&quot;baseRight&quot;</span><span class="p">:[]}</span>
        
        <span class="k">else</span><span class="p">:</span>
            <span class="k">pass</span>

        <span class="c1"># get residual and rms of peak fit</span>
        <span class="n">fitRes</span><span class="p">,</span> <span class="n">err_peak</span> <span class="o">=</span> <span class="n">calc_residual</span><span class="p">(</span><span class="n">yCorrected</span><span class="p">[</span><span class="n">hmain_beam</span><span class="p">],</span> <span class="n">ypeak</span><span class="p">)</span>
        <span class="n">saveTo</span><span class="o">=</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">saveTag</span><span class="si">}</span><span class="s1">_peak_fit.png&#39;</span>
        <span class="n">plotPeakFit</span><span class="p">(</span><span class="s2">&quot;Plot of final peak fitted data&quot;</span><span class="p">,</span><span class="n">x</span><span class="p">,</span><span class="n">yCorrected</span><span class="p">,</span><span class="n">ypeak</span><span class="p">,</span><span class="n">err_peak</span><span class="p">,</span><span class="n">hmain_beam</span><span class="p">,</span><span class="n">saveTo</span><span class="p">)</span>

        <span class="c1"># find final peak loc</span>
        <span class="n">ploc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">ypeak</span> <span class="o">==</span> <span class="nb">max</span><span class="p">(</span><span class="n">ypeak</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">peakLoc</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">hmain_beam</span><span class="p">])[</span><span class="n">ploc</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
        <span class="c1"># print(&#39;out&#39;)</span>
        <span class="k">return</span> <span class="p">{</span>
            <span class="s2">&quot;peakFit&quot;</span><span class="p">:</span><span class="nb">max</span><span class="p">(</span><span class="n">ypeak</span><span class="p">),</span><span class="s2">&quot;peakModel&quot;</span><span class="p">:</span><span class="n">ypeak</span><span class="p">,</span> <span class="s2">&quot;peakRms&quot;</span><span class="p">:</span><span class="n">err_peak</span><span class="p">,</span><span class="s2">&quot;correctedData&quot;</span><span class="p">:</span><span class="n">yCorrected</span><span class="p">,</span><span class="s2">&quot;peakPts&quot;</span><span class="p">:</span><span class="n">hmain_beam</span><span class="p">,</span>
            <span class="s2">&quot;msg&quot;</span><span class="p">:</span><span class="s2">&quot;&quot;</span><span class="p">,</span><span class="s2">&quot;driftRes&quot;</span><span class="p">:</span><span class="n">driftRes</span><span class="p">,</span><span class="s2">&quot;driftRms&quot;</span><span class="p">:</span><span class="n">driftRms</span><span class="p">,</span><span class="s2">&quot;driftCoeffs&quot;</span><span class="p">:</span><span class="n">driftCoeffs</span><span class="p">,</span><span class="s2">&quot;fitRes&quot;</span><span class="p">:</span><span class="n">fitRes</span><span class="p">,</span><span class="s2">&quot;midXValue&quot;</span><span class="p">:</span><span class="n">coeff</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
            <span class="s2">&quot;flag&quot;</span><span class="p">:</span><span class="n">flag</span><span class="p">,</span><span class="s2">&quot;baseLocsLeft&quot;</span><span class="p">:</span><span class="n">baseLocsl</span><span class="p">,</span><span class="s2">&quot;baseLocsRight&quot;</span><span class="p">:</span><span class="n">baseLocsr</span><span class="p">,</span><span class="s2">&quot;baseLocsCombined&quot;</span><span class="p">:</span><span class="n">baseLocs</span><span class="p">,</span><span class="s2">&quot;peakLoc&quot;</span><span class="p">:</span><span class="n">peakLoc</span><span class="p">,</span>
            <span class="s2">&quot;baseLeft&quot;</span><span class="p">:</span><span class="n">lb</span><span class="p">,</span><span class="s2">&quot;baseRight&quot;</span><span class="p">:</span><span class="n">rb</span><span class="p">,</span>
        <span class="p">}</span></div>

        <span class="c1"># return max(ypeak), ypeak, err_peak, yCorrected, hmain_beam, &quot;&quot;, driftRes, driftRms, driftCoeffs, fitRes, coeff[1], flag, baseLocsl, baseLocsr, baseLocs, peakLoc,lb,rb</span>

<div class="viewcode-block" id="fit_dual_beam">
<a class="viewcode-back" href="../../../docs/src.common.html#src.common.fitting.fit_dual_beam">[docs]</a>
<span class="k">def</span> <span class="nf">fit_dual_beam</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">hpbw</span><span class="p">,</span> <span class="n">fnbw</span><span class="p">,</span> <span class="n">factor</span><span class="p">,</span><span class="n">saveTo</span><span class="p">,</span><span class="n">log</span><span class="p">):</span> <span class="c1">#, npts, dec, srcType, data, scanNum, force, log):</span>
    
    <span class="c1"># Setup parameters</span>
    <span class="n">scanLen</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>              <span class="c1"># length of the scan</span>
    <span class="n">midLeftLoc</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">scanLen</span><span class="o">/</span><span class="mi">4</span><span class="p">)</span>   <span class="c1"># estimated location of peak on left beam</span>
    <span class="n">midRightLoc</span> <span class="o">=</span> <span class="n">midLeftLoc</span> <span class="o">*</span> <span class="mi">3</span>  <span class="c1"># estimated location of peak on right beam</span>
    <span class="n">hhpbw</span> <span class="o">=</span> <span class="n">hpbw</span><span class="o">/</span><span class="mi">2</span>                <span class="c1"># half of the hpbw</span>
    <span class="n">hfnbw</span> <span class="o">=</span> <span class="n">fnbw</span><span class="o">/</span><span class="mi">2</span>                <span class="c1"># half of the fnbw</span>
    <span class="n">factoredfnbw</span> <span class="o">=</span> <span class="p">(</span><span class="n">fnbw</span><span class="o">*</span><span class="n">factor</span><span class="p">)</span>  <span class="c1"># fnbw multiplied by factor</span>
    <span class="n">flag</span><span class="o">=</span><span class="mi">0</span>                        <span class="c1"># default flag set to zero</span>
    <span class="n">msg</span><span class="o">=</span><span class="s2">&quot;&quot;</span>                        <span class="c1"># flag message to go on plot image</span>
    <span class="c1"># saveFolder=&quot;currentScanPlots/&quot;</span>
    <span class="n">fl</span> <span class="o">=</span> <span class="mi">0</span>                        <span class="c1"># failed left gaussian fit</span>
    <span class="n">fr</span> <span class="o">=</span> <span class="mi">0</span>                        <span class="c1"># failed right gaussian fit</span>

    <span class="c1"># LOCATE BASELINE BLOCKS</span>
    <span class="n">msg_wrapper</span><span class="p">(</span><span class="s2">&quot;debug&quot;</span><span class="p">,</span> <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">,</span> <span class="s2">&quot;-- Locate baseline blocks&quot;</span><span class="p">)</span>
    
    <span class="c1"># we don&#39;t worry about sidelobes here so baseline</span>
    <span class="c1"># blocks are set to edges or fnbw points</span>

    <span class="n">ptLimit</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">scanLen</span><span class="o">*</span><span class="mf">0.04</span><span class="p">)</span> <span class="c1"># Point limit, number of allowed points per base block</span>
    <span class="n">baseLocsLeft</span>  <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">ptLimit</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">baseLocsRight</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">scanLen</span><span class="o">-</span><span class="n">ptLimit</span><span class="p">,</span><span class="n">scanLen</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">baseLocs</span>      <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">baseLocsLeft</span><span class="p">)</span><span class="o">+</span><span class="nb">list</span><span class="p">(</span><span class="n">baseLocsRight</span><span class="p">)</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">baseLocsLeft</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">baseLocsRight</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;failed to locate base locs&quot;</span>
        <span class="n">flag</span> <span class="o">=</span> <span class="mi">30</span>
        <span class="n">msg_wrapper</span><span class="p">(</span><span class="s2">&quot;warning&quot;</span><span class="p">,</span> <span class="n">log</span><span class="o">.</span><span class="n">warning</span><span class="p">,</span> <span class="n">msg</span><span class="p">)</span>
        <span class="c1"># sys.exit()</span>
        <span class="k">return</span> <span class="p">{</span><span class="s2">&quot;correctedData&quot;</span><span class="p">:[],</span><span class="s2">&quot;driftRes&quot;</span><span class="p">:[],</span><span class="s2">&quot;driftRms&quot;</span><span class="p">:</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span>
                        <span class="s2">&quot;driftCoeffs&quot;</span><span class="p">:[],</span> <span class="s2">&quot;baseLocsCombined&quot;</span><span class="p">:[],</span>
                        <span class="s2">&quot;baseLocsLeft&quot;</span><span class="p">:[],</span><span class="s2">&quot;baseLocsRight&quot;</span><span class="p">:[],</span>
                    <span class="s2">&quot;leftPeakData&quot;</span><span class="p">:[],</span><span class="s2">&quot;leftPeakModelData&quot;</span><span class="p">:[],</span>
                    <span class="s2">&quot;leftPeakFit&quot;</span><span class="p">:</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="s2">&quot;leftPeakFitErr&quot;</span><span class="p">:</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span><span class="s2">&quot;leftPeakFitRes&quot;</span><span class="p">:[],</span>
                    <span class="s2">&quot;rightPeakData&quot;</span><span class="p">:[],</span><span class="s2">&quot;rightPeakModelData&quot;</span><span class="p">:[],</span>
                    <span class="s2">&quot;rightPeakFit&quot;</span><span class="p">:</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="s2">&quot;rightPeakFitErr&quot;</span><span class="p">:[],</span><span class="s2">&quot;rightPeakFitRes&quot;</span><span class="p">:[],</span>
                    <span class="s2">&quot;msg&quot;</span><span class="p">:</span><span class="s2">&quot;&quot;</span><span class="p">,</span><span class="s2">&quot;midXValueLeft&quot;</span><span class="p">:[],</span><span class="s2">&quot;midXValueRight&quot;</span><span class="p">:[],</span>
                    <span class="s2">&quot;flag&quot;</span><span class="p">:</span><span class="n">flag</span>
                    <span class="p">}</span>
    
    <span class="n">msg_wrapper</span><span class="p">(</span><span class="s2">&quot;debug&quot;</span><span class="p">,</span> <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">,</span>
                <span class="sa">f</span><span class="s1">&#39;BaseLocsLeft: </span><span class="si">{</span><span class="n">baseLocsLeft</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s1"> to </span><span class="si">{</span><span class="n">baseLocsLeft</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="si">}</span><span class="s1"> = </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">baseLocsLeft</span><span class="p">)</span><span class="si">}</span><span class="s1"> pts&#39;</span><span class="p">)</span>
    <span class="n">msg_wrapper</span><span class="p">(</span><span class="s2">&quot;debug&quot;</span><span class="p">,</span> <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">,</span>
                <span class="sa">f</span><span class="s1">&#39;BaseLocsLeft: </span><span class="si">{</span><span class="n">baseLocsRight</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s1"> to </span><span class="si">{</span><span class="n">baseLocsRight</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="si">}</span><span class="s1"> = </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">baseLocsRight</span><span class="p">)</span><span class="si">}</span><span class="s1"> pts&#39;</span><span class="p">)</span>
  
    <span class="n">dataModel</span><span class="p">,</span> <span class="n">driftModel</span><span class="p">,</span> <span class="n">driftRes</span><span class="p">,</span> <span class="n">driftRms</span><span class="p">,</span> <span class="n">driftCoeffs</span> <span class="o">=</span> <span class="n">correct_drift</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">baseLocs</span><span class="p">],</span> <span class="n">y</span><span class="p">[</span><span class="n">baseLocs</span><span class="p">],</span> <span class="n">x</span><span class="p">,</span><span class="n">log</span><span class="p">)</span>

    <span class="c1"># Correct the data and get global max/min</span>
    <span class="n">yCorrected</span> <span class="o">=</span> <span class="n">y</span><span class="o">-</span><span class="n">dataModel</span>
    <span class="n">maxyloc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">yCorrected</span><span class="p">)</span>
    <span class="n">minyloc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">yCorrected</span><span class="p">)</span>
    <span class="n">maxy</span> <span class="o">=</span> <span class="n">yCorrected</span><span class="p">[</span><span class="n">maxyloc</span><span class="p">]</span>
    <span class="n">miny</span> <span class="o">=</span> <span class="n">yCorrected</span><span class="p">[</span><span class="n">minyloc</span><span class="p">]</span>

    <span class="c1"># Spline the data and get global max/min</span>
    <span class="n">yspl</span> <span class="o">=</span> <span class="n">spline</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">yCorrected</span><span class="p">)</span>
    <span class="n">ysplmaxloc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">yspl</span><span class="p">)</span>
    <span class="n">ysplminloc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">yspl</span><span class="p">)</span>
    <span class="n">ysplmax</span> <span class="o">=</span> <span class="n">yspl</span><span class="p">[</span><span class="n">ysplmaxloc</span><span class="p">]</span>
    <span class="n">ysplmin</span> <span class="o">=</span> <span class="n">yspl</span><span class="p">[</span><span class="n">ysplminloc</span><span class="p">]</span> 

    <span class="c1"># make plots</span>
    <span class="n">plotCorrectedData</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">yCorrected</span><span class="p">,</span><span class="n">baseLocsLeft</span><span class="p">,</span><span class="n">baseLocsRight</span><span class="p">,</span><span class="s1">&#39;Corrected data&#39;</span><span class="p">,</span><span class="s1">&#39;Baseline blocks&#39;</span><span class="p">,</span><span class="s1">&#39;Plot of baseline corrected data&#39;</span><span class="p">,</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">saveTo</span><span class="si">}</span><span class="s1">corrected.png&#39;</span><span class="p">,</span><span class="n">xlabel</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">,</span><span class="n">ylabel</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">)</span>
    <span class="n">plot_overlap</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">yCorrected</span><span class="p">,</span><span class="n">x</span><span class="p">,</span><span class="n">yspl</span><span class="p">,</span><span class="s1">&#39;Plot of splined data&#39;</span><span class="p">,</span><span class="s1">&#39;corrected&#39;</span><span class="p">,</span><span class="s1">&#39;spline fit&#39;</span><span class="p">,</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">saveTo</span><span class="si">}</span><span class="s1">splined.png&#39;</span><span class="p">,</span><span class="n">xlabel</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">,</span><span class="n">ylabel</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">)</span>
    <span class="c1"># sys.exit()</span>
    <span class="n">msg_wrapper</span><span class="p">(</span><span class="s2">&quot;debug&quot;</span><span class="p">,</span> <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">,</span> <span class="s2">&quot;maxyloc: </span><span class="si">{}</span><span class="s2">, maxy: </span><span class="si">{:.3f}</span><span class="s2">, minyloc: </span><span class="si">{}</span><span class="s2">, miny: </span><span class="si">{:.3f}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">maxyloc</span><span class="p">,</span> <span class="n">maxy</span><span class="p">,</span> <span class="n">minyloc</span><span class="p">,</span> <span class="n">miny</span><span class="p">))</span>
    <span class="n">msg_wrapper</span><span class="p">(</span><span class="s2">&quot;debug&quot;</span><span class="p">,</span> <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">,</span> <span class="s2">&quot;maxyloc: </span><span class="si">{}</span><span class="s2">, maxy: </span><span class="si">{:.3f}</span><span class="s2">, minyloc: </span><span class="si">{}</span><span class="s2">, miny: </span><span class="si">{:.3f}</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">ysplmaxloc</span><span class="p">,</span> <span class="n">ysplmax</span><span class="p">,</span> <span class="n">ysplminloc</span><span class="p">,</span> <span class="n">ysplmin</span><span class="p">))</span>
    <span class="n">msg_wrapper</span><span class="p">(</span><span class="s2">&quot;debug&quot;</span><span class="p">,</span> <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">,</span> <span class="s2">&quot;A beam peakloc: </span><span class="si">{}</span><span class="s2"> </span><span class="se">\n</span><span class="s2"># B beam peakloc: </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">ysplmaxloc</span><span class="p">,</span> <span class="n">ysplminloc</span><span class="p">))</span>


    <span class="c1"># A/B BEAM DATA PROCESSING</span>
    <span class="n">AbeamScan</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span><span class="n">x</span> <span class="o">&gt;</span> <span class="o">-</span><span class="n">factoredfnbw</span><span class="p">,</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">BbeamScan</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span><span class="n">x</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">,</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="n">factoredfnbw</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">AbeamScan</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">BbeamScan</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">msg</span><span class="o">=</span><span class="s2">&quot;A/B beam scan data == 0, no data&quot;</span>
        <span class="n">flag</span> <span class="o">=</span> <span class="mi">8</span>
        <span class="n">msg_wrapper</span><span class="p">(</span><span class="s2">&quot;warning&quot;</span><span class="p">,</span> <span class="n">log</span><span class="o">.</span><span class="n">warning</span><span class="p">,</span> <span class="n">msg</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">{</span><span class="s2">&quot;correctedData&quot;</span><span class="p">:[],</span><span class="s2">&quot;driftRes&quot;</span><span class="p">:[],</span><span class="s2">&quot;driftRms&quot;</span><span class="p">:</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span>
                        <span class="s2">&quot;driftCoeffs&quot;</span><span class="p">:[],</span> <span class="s2">&quot;baseLocsCombined&quot;</span><span class="p">:[],</span>
                        <span class="s2">&quot;baseLocsLeft&quot;</span><span class="p">:[],</span><span class="s2">&quot;baseLocsRight&quot;</span><span class="p">:[],</span>
                    <span class="s2">&quot;leftPeakData&quot;</span><span class="p">:[],</span><span class="s2">&quot;leftPeakModelData&quot;</span><span class="p">:[],</span>
                    <span class="s2">&quot;leftPeakFit&quot;</span><span class="p">:</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="s2">&quot;leftPeakFitErr&quot;</span><span class="p">:</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span><span class="s2">&quot;leftPeakFitRes&quot;</span><span class="p">:[],</span>
                    <span class="s2">&quot;rightPeakData&quot;</span><span class="p">:[],</span><span class="s2">&quot;rightPeakModelData&quot;</span><span class="p">:[],</span>
                    <span class="s2">&quot;rightPeakFit&quot;</span><span class="p">:</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="s2">&quot;rightPeakFitErr&quot;</span><span class="p">:[],</span><span class="s2">&quot;rightPeakFitRes&quot;</span><span class="p">:[],</span>
                    <span class="s2">&quot;msg&quot;</span><span class="p">:</span><span class="s2">&quot;&quot;</span><span class="p">,</span><span class="s2">&quot;midXValueLeft&quot;</span><span class="p">:[],</span><span class="s2">&quot;midXValueRight&quot;</span><span class="p">:[],</span>
                    <span class="s2">&quot;flag&quot;</span><span class="p">:</span><span class="n">flag</span>
                    <span class="p">}</span>
    
    <span class="n">msg_wrapper</span><span class="p">(</span><span class="s2">&quot;debug&quot;</span><span class="p">,</span> <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">,</span> <span class="s2">&quot;- Beam seperation:&quot;</span><span class="p">)</span>
    <span class="n">msg_wrapper</span><span class="p">(</span><span class="s2">&quot;debug&quot;</span><span class="p">,</span> <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">,</span> <span class="s2">&quot;Left beam indeces: </span><span class="si">{}</span><span class="s2"> to </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">AbeamScan</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">AbeamScan</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]))</span>
    <span class="n">msg_wrapper</span><span class="p">(</span><span class="s2">&quot;debug&quot;</span><span class="p">,</span> <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">,</span> <span class="s2">&quot;Right beam indeces: </span><span class="si">{}</span><span class="s2"> to </span><span class="si">{}</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
        <span class="n">BbeamScan</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">BbeamScan</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]))</span>

    <span class="n">msg_wrapper</span><span class="p">(</span><span class="s2">&quot;debug&quot;</span><span class="p">,</span> <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">,</span> <span class="s2">&quot;- Data Limits&quot;</span><span class="p">)</span>
    <span class="n">msg_wrapper</span><span class="p">(</span><span class="s2">&quot;debug&quot;</span><span class="p">,</span> <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">,</span> <span class="s2">&quot;base left: </span><span class="si">{}</span><span class="s2">, drift A left: </span><span class="si">{}</span><span class="s2">, peak A: </span><span class="si">{}</span><span class="s2">, drift A right: </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">baseLocsLeft</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">AbeamScan</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">ysplminloc</span><span class="p">,</span> <span class="n">AbeamScan</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]))</span>
    <span class="n">msg_wrapper</span><span class="p">(</span><span class="s2">&quot;debug&quot;</span><span class="p">,</span> <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">,</span> <span class="s2">&quot;drift B left: </span><span class="si">{}</span><span class="s2">, peak B: </span><span class="si">{}</span><span class="s2">, drift B right: </span><span class="si">{}</span><span class="s2">, base right: </span><span class="si">{}</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
        <span class="n">BbeamScan</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">ysplmaxloc</span><span class="p">,</span> <span class="n">BbeamScan</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">baseLocsRight</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>

    <span class="c1"># figure out orientation of beam. With some scans the beams</span>
    <span class="c1"># are flipped e.g, pks2326-502, A beam is positive, whereas</span>
    <span class="c1"># j0450-81 A beam is negative.</span>
    <span class="c1"># find value closest to zero and use the other value to determine</span>
    <span class="c1"># which side to fit positive/negative peak</span>
    <span class="n">lstA</span><span class="o">=</span><span class="p">[</span><span class="nb">min</span><span class="p">(</span><span class="n">yspl</span><span class="p">[</span><span class="n">AbeamScan</span><span class="p">]),</span> <span class="nb">max</span><span class="p">(</span><span class="n">yspl</span><span class="p">[</span><span class="n">AbeamScan</span><span class="p">])]</span>
    <span class="n">minA</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">lstA</span><span class="p">,</span><span class="n">key</span><span class="o">=</span><span class="nb">abs</span><span class="p">)</span>
    <span class="n">fa</span><span class="o">=</span><span class="s2">&quot;&quot;</span>
    <span class="k">if</span> <span class="n">minA</span><span class="o">==</span><span class="nb">min</span><span class="p">(</span><span class="n">yspl</span><span class="p">[</span><span class="n">AbeamScan</span><span class="p">]):</span>
        <span class="c1"># fit A beam positive B beam negative</span>
        <span class="c1">#print(&quot;Fitting positive&quot;)</span>
        <span class="n">fa</span><span class="o">=</span><span class="s2">&quot;p&quot;</span>

        
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># fit A beam negative B beam positive</span>
        <span class="c1">#print(&quot;Fitting negative&quot;)</span>
        <span class="n">fa</span><span class="o">=</span><span class="s2">&quot;n&quot;</span>

    <span class="n">beamCut</span> <span class="o">=</span> <span class="mf">0.6</span> <span class="c1"># fitting top 40%, 0.7 (30% for cals) or 0.5 (50% for targets) should make this an option</span>

    <span class="c1"># Ensure peak is within accepted limits</span>
    <span class="k">if</span> <span class="n">fa</span><span class="o">==</span><span class="s2">&quot;p&quot;</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">ysplmaxloc</span> <span class="o">&gt;</span> <span class="n">AbeamScan</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span><span class="c1"># or ysplminloc &gt; beamScan[0]:</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;Max is beyond left baseline block&quot;</span>
            <span class="n">flag</span> <span class="o">=</span> <span class="mi">31</span>
            <span class="n">msg_wrapper</span><span class="p">(</span><span class="s2">&quot;warning&quot;</span><span class="p">,</span> <span class="n">log</span><span class="o">.</span><span class="n">warning</span><span class="p">,</span> <span class="n">msg</span><span class="p">)</span>
            <span class="k">return</span> <span class="p">{</span><span class="s2">&quot;correctedData&quot;</span><span class="p">:[],</span><span class="s2">&quot;driftRes&quot;</span><span class="p">:[],</span><span class="s2">&quot;driftRms&quot;</span><span class="p">:</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span>
                        <span class="s2">&quot;driftCoeffs&quot;</span><span class="p">:[],</span> <span class="s2">&quot;baseLocsCombined&quot;</span><span class="p">:[],</span>
                        <span class="s2">&quot;baseLocsLeft&quot;</span><span class="p">:[],</span><span class="s2">&quot;baseLocsRight&quot;</span><span class="p">:[],</span>
                    <span class="s2">&quot;leftPeakData&quot;</span><span class="p">:[],</span><span class="s2">&quot;leftPeakModelData&quot;</span><span class="p">:[],</span>
                    <span class="s2">&quot;leftPeakFit&quot;</span><span class="p">:</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="s2">&quot;leftPeakFitErr&quot;</span><span class="p">:</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span><span class="s2">&quot;leftPeakFitRes&quot;</span><span class="p">:[],</span>
                    <span class="s2">&quot;rightPeakData&quot;</span><span class="p">:[],</span><span class="s2">&quot;rightPeakModelData&quot;</span><span class="p">:[],</span>
                    <span class="s2">&quot;rightPeakFit&quot;</span><span class="p">:</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="s2">&quot;rightPeakFitErr&quot;</span><span class="p">:[],</span><span class="s2">&quot;rightPeakFitRes&quot;</span><span class="p">:[],</span>
                    <span class="s2">&quot;msg&quot;</span><span class="p">:</span><span class="s2">&quot;&quot;</span><span class="p">,</span><span class="s2">&quot;midXValueLeft&quot;</span><span class="p">:[],</span><span class="s2">&quot;midXValueRight&quot;</span><span class="p">:[],</span>
                    <span class="s2">&quot;flag&quot;</span><span class="p">:</span><span class="n">flag</span>
                    <span class="p">}</span>

        <span class="k">if</span> <span class="n">ysplminloc</span> <span class="o">&lt;</span> <span class="n">BbeamScan</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span><span class="c1">#baseLocsRight[0]:  # ysplminloc &lt; BbeamScan[0] or</span>
            <span class="n">msg</span><span class="o">=</span><span class="s2">&quot;Min is beyond right baseline block&quot;</span>
            <span class="c1"># print(msg)</span>
            <span class="n">flag</span><span class="o">=</span><span class="mi">32</span>
            <span class="n">msg_wrapper</span><span class="p">(</span><span class="s2">&quot;warning&quot;</span><span class="p">,</span> <span class="n">log</span><span class="o">.</span><span class="n">warning</span><span class="p">,</span> <span class="n">msg</span><span class="p">)</span>
            <span class="k">return</span> <span class="p">{</span><span class="s2">&quot;correctedData&quot;</span><span class="p">:[],</span><span class="s2">&quot;driftRes&quot;</span><span class="p">:[],</span><span class="s2">&quot;driftRms&quot;</span><span class="p">:</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span>
                        <span class="s2">&quot;driftCoeffs&quot;</span><span class="p">:[],</span> <span class="s2">&quot;baseLocsCombined&quot;</span><span class="p">:[],</span>
                        <span class="s2">&quot;baseLocsLeft&quot;</span><span class="p">:[],</span><span class="s2">&quot;baseLocsRight&quot;</span><span class="p">:[],</span>
                    <span class="s2">&quot;leftPeakData&quot;</span><span class="p">:[],</span><span class="s2">&quot;leftPeakModelData&quot;</span><span class="p">:[],</span>
                    <span class="s2">&quot;leftPeakFit&quot;</span><span class="p">:</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="s2">&quot;leftPeakFitErr&quot;</span><span class="p">:</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span><span class="s2">&quot;leftPeakFitRes&quot;</span><span class="p">:[],</span>
                    <span class="s2">&quot;rightPeakData&quot;</span><span class="p">:[],</span><span class="s2">&quot;rightPeakModelData&quot;</span><span class="p">:[],</span>
                    <span class="s2">&quot;rightPeakFit&quot;</span><span class="p">:</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="s2">&quot;rightPeakFitErr&quot;</span><span class="p">:[],</span><span class="s2">&quot;rightPeakFitRes&quot;</span><span class="p">:[],</span>
                    <span class="s2">&quot;msg&quot;</span><span class="p">:</span><span class="s2">&quot;&quot;</span><span class="p">,</span><span class="s2">&quot;midXValueLeft&quot;</span><span class="p">:[],</span><span class="s2">&quot;midXValueRight&quot;</span><span class="p">:[],</span>
                    <span class="s2">&quot;flag&quot;</span><span class="p">:</span><span class="n">flag</span>
                    <span class="p">}</span>

        <span class="c1"># Try to fit a gaussian to determine peak parameters</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="c1"># set initial parameters for data fitting</span>
            <span class="n">p</span> <span class="o">=</span> <span class="p">[</span><span class="nb">max</span><span class="p">(</span><span class="n">y</span><span class="p">),</span> <span class="n">x</span><span class="p">[</span><span class="n">midLeftLoc</span><span class="p">],</span> <span class="n">hpbw</span><span class="p">,</span> <span class="mf">.01</span><span class="p">,</span> <span class="mf">.0</span><span class="p">]</span>
            <span class="c1"># Try to fit a gaussian to determine peak location</span>
            <span class="c1"># this also works as a bad scan filter</span>
            <span class="n">coeffl</span><span class="p">,</span> <span class="n">fitl</span><span class="p">,</span> <span class="n">flagl</span> <span class="o">=</span> <span class="n">test_gauss_fit</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">AbeamScan</span><span class="p">],</span> <span class="n">y</span><span class="p">[</span><span class="n">AbeamScan</span><span class="p">],</span> <span class="n">p</span><span class="p">,</span><span class="n">log</span><span class="p">)</span>
            <span class="c1"># coeffl, covar_matrixl, fitLeft = fit_gauss_lin(</span>
                <span class="c1"># x[AbeamScan], y[AbeamScan], p)</span>
        <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
            <span class="n">fl</span><span class="o">=</span><span class="mi">1</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;gaussian curve_fit algorithm failed&quot;</span>
            <span class="n">msg_wrapper</span><span class="p">(</span><span class="s2">&quot;debug&quot;</span><span class="p">,</span> <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">,</span> <span class="n">msg</span><span class="p">)</span>
            <span class="n">fitLeft</span> <span class="o">=</span> <span class="n">y</span><span class="p">[</span><span class="n">AbeamScan</span><span class="p">]</span>
            <span class="n">flag</span> <span class="o">=</span> <span class="mi">3</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="c1"># set initial parameters for data fitting</span>
            <span class="n">p</span> <span class="o">=</span> <span class="p">[</span><span class="nb">min</span><span class="p">(</span><span class="n">y</span><span class="p">),</span> <span class="n">x</span><span class="p">[</span><span class="n">midRightLoc</span><span class="p">],</span> <span class="n">hpbw</span><span class="p">,</span> <span class="mf">.01</span><span class="p">,</span> <span class="mf">.0</span><span class="p">]</span>
            <span class="n">coeffr</span><span class="p">,</span> <span class="n">fitr</span><span class="p">,</span> <span class="n">flagr</span> <span class="o">=</span> <span class="n">test_gauss_fit</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">AbeamScan</span><span class="p">],</span> <span class="n">y</span><span class="p">[</span><span class="n">AbeamScan</span><span class="p">],</span> <span class="n">p</span><span class="p">,</span><span class="n">log</span><span class="p">)</span>
            
            <span class="c1"># coeffr, covar_matrixr, fitRight = fit_gauss_lin(</span>
                <span class="c1"># x[BbeamScan], y[BbeamScan], p)</span>
        <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
            <span class="n">fr</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;gaussian curve_fit algorithm failed&quot;</span>
            <span class="n">msg_wrapper</span><span class="p">(</span><span class="s2">&quot;debug&quot;</span><span class="p">,</span> <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">,</span> <span class="n">msg</span><span class="p">)</span>
            <span class="n">fitRight</span> <span class="o">=</span> <span class="n">y</span><span class="p">[</span><span class="n">BbeamScan</span><span class="p">]</span>
            <span class="n">flag</span> <span class="o">=</span> <span class="mi">3</span>

        <span class="c1"># Determine peak fitting location</span>
        <span class="n">BbeamLeftLimit</span>  <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="n">ysplminloc</span><span class="p">]</span><span class="o">-</span><span class="n">hhpbw</span> <span class="c1">#coeffl[1] - hhpbw  # *2*.6</span>
        <span class="n">BbeamRightLimit</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="n">ysplminloc</span><span class="p">]</span><span class="o">+</span><span class="n">hhpbw</span>
        <span class="n">AbeamLeftLimit</span>  <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="n">ysplmaxloc</span><span class="p">]</span><span class="o">-</span><span class="n">hhpbw</span> <span class="c1">#coeffl[1] - hhpbw  # *2*.6</span>
        <span class="n">AbeamRightLimit</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="n">ysplmaxloc</span><span class="p">]</span><span class="o">+</span><span class="n">hhpbw</span>

        <span class="n">leftlocs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span>
            <span class="n">x</span> <span class="o">&gt;=</span> <span class="n">AbeamLeftLimit</span><span class="p">,</span> <span class="n">x</span> <span class="o">&lt;=</span> <span class="n">AbeamRightLimit</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">rightlocs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span>
            <span class="n">x</span> <span class="o">&gt;=</span> <span class="n">BbeamLeftLimit</span><span class="p">,</span> <span class="n">x</span> <span class="o">&lt;=</span> <span class="n">BbeamRightLimit</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span>
        
        
        <span class="c1"># select part of beam to fit</span>
        <span class="k">if</span> <span class="n">ysplmax</span> <span class="o">&lt;</span> <span class="mf">0.1</span><span class="p">:</span>
            <span class="n">flag</span> <span class="o">=</span> <span class="mi">36</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;fit entire left beam, max yspl &lt; 0.1&quot;</span>
            <span class="n">msg_wrapper</span><span class="p">(</span><span class="s2">&quot;warning&quot;</span><span class="p">,</span> <span class="n">log</span><span class="o">.</span><span class="n">warning</span><span class="p">,</span> <span class="n">msg</span><span class="p">)</span>
            <span class="n">leftMainBeamLocs</span> <span class="o">=</span> <span class="n">leftlocs</span>
            
        <span class="k">else</span><span class="p">:</span>
            <span class="n">topCut</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">yspl</span><span class="p">[</span><span class="n">leftlocs</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">ysplmax</span><span class="o">*</span><span class="n">beamCut</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">leftMainBeamLocs</span> <span class="o">=</span> <span class="n">leftlocs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">+</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">topCut</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">ysplmin</span> <span class="o">&gt;</span> <span class="o">-</span><span class="mf">0.1</span><span class="p">:</span>
            <span class="n">flag</span> <span class="o">=</span> <span class="mi">35</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;fit entire right beam, min yspl &gt; -0.1&quot;</span>
            <span class="n">msg_wrapper</span><span class="p">(</span><span class="s2">&quot;warning&quot;</span><span class="p">,</span> <span class="n">log</span><span class="o">.</span><span class="n">warning</span><span class="p">,</span> <span class="n">msg</span><span class="p">)</span>
            <span class="n">rightMainBeamLocs</span> <span class="o">=</span> <span class="n">rightlocs</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">bottomCut</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">yspl</span><span class="p">[</span><span class="n">rightlocs</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">ysplmin</span><span class="o">*</span><span class="n">beamCut</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">rightMainBeamLocs</span> <span class="o">=</span> <span class="n">rightlocs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">+</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">bottomCut</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">fa</span><span class="o">==</span><span class="s2">&quot;n&quot;</span><span class="p">:</span>
        <span class="c1"># A beam is min</span>
        <span class="k">if</span> <span class="n">ysplmaxloc</span> <span class="o">&lt;</span> <span class="n">AbeamScan</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span><span class="c1"># or ysplminloc &gt; beamScan[0]:</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;Max is beyond left baseline block&quot;</span>
            <span class="n">flag</span> <span class="o">=</span> <span class="mi">31</span>
            <span class="n">msg_wrapper</span><span class="p">(</span><span class="s2">&quot;warning&quot;</span><span class="p">,</span> <span class="n">log</span><span class="o">.</span><span class="n">warning</span><span class="p">,</span> <span class="n">msg</span><span class="p">)</span>
            <span class="k">return</span> <span class="p">{</span><span class="s2">&quot;correctedData&quot;</span><span class="p">:[],</span><span class="s2">&quot;driftRes&quot;</span><span class="p">:[],</span><span class="s2">&quot;driftRms&quot;</span><span class="p">:</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span>
                        <span class="s2">&quot;driftCoeffs&quot;</span><span class="p">:[],</span> <span class="s2">&quot;baseLocsCombined&quot;</span><span class="p">:[],</span>
                        <span class="s2">&quot;baseLocsLeft&quot;</span><span class="p">:[],</span><span class="s2">&quot;baseLocsRight&quot;</span><span class="p">:[],</span>
                    <span class="s2">&quot;leftPeakData&quot;</span><span class="p">:[],</span><span class="s2">&quot;leftPeakModelData&quot;</span><span class="p">:[],</span>
                    <span class="s2">&quot;leftPeakFit&quot;</span><span class="p">:</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="s2">&quot;leftPeakFitErr&quot;</span><span class="p">:</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span><span class="s2">&quot;leftPeakFitRes&quot;</span><span class="p">:[],</span>
                    <span class="s2">&quot;rightPeakData&quot;</span><span class="p">:[],</span><span class="s2">&quot;rightPeakModelData&quot;</span><span class="p">:[],</span>
                    <span class="s2">&quot;rightPeakFit&quot;</span><span class="p">:</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="s2">&quot;rightPeakFitErr&quot;</span><span class="p">:[],</span><span class="s2">&quot;rightPeakFitRes&quot;</span><span class="p">:[],</span>
                    <span class="s2">&quot;msg&quot;</span><span class="p">:</span><span class="s2">&quot;&quot;</span><span class="p">,</span><span class="s2">&quot;midXValueLeft&quot;</span><span class="p">:[],</span><span class="s2">&quot;midXValueRight&quot;</span><span class="p">:[],</span>
                    <span class="s2">&quot;flag&quot;</span><span class="p">:</span><span class="n">flag</span>
                    <span class="p">}</span>

        <span class="k">if</span> <span class="n">ysplminloc</span> <span class="o">&gt;</span> <span class="n">BbeamScan</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span><span class="c1">#baseLocsRight[0]:  # ysplminloc &lt; BbeamScan[0] or</span>
            <span class="n">msg</span><span class="o">=</span><span class="s2">&quot;Min is beyond right baseline block&quot;</span>
            <span class="c1"># print(msg)</span>
            <span class="n">flag</span><span class="o">=</span><span class="mi">32</span>
            <span class="n">msg_wrapper</span><span class="p">(</span><span class="s2">&quot;warning&quot;</span><span class="p">,</span> <span class="n">log</span><span class="o">.</span><span class="n">warning</span><span class="p">,</span> <span class="n">msg</span><span class="p">)</span>
            <span class="k">return</span> <span class="p">{</span><span class="s2">&quot;correctedData&quot;</span><span class="p">:[],</span><span class="s2">&quot;driftRes&quot;</span><span class="p">:[],</span><span class="s2">&quot;driftRms&quot;</span><span class="p">:</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span>
                        <span class="s2">&quot;driftCoeffs&quot;</span><span class="p">:[],</span> <span class="s2">&quot;baseLocsCombined&quot;</span><span class="p">:[],</span>
                        <span class="s2">&quot;baseLocsLeft&quot;</span><span class="p">:[],</span><span class="s2">&quot;baseLocsRight&quot;</span><span class="p">:[],</span>
                    <span class="s2">&quot;leftPeakData&quot;</span><span class="p">:[],</span><span class="s2">&quot;leftPeakModelData&quot;</span><span class="p">:[],</span>
                    <span class="s2">&quot;leftPeakFit&quot;</span><span class="p">:</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="s2">&quot;leftPeakFitErr&quot;</span><span class="p">:</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span><span class="s2">&quot;leftPeakFitRes&quot;</span><span class="p">:[],</span>
                    <span class="s2">&quot;rightPeakData&quot;</span><span class="p">:[],</span><span class="s2">&quot;rightPeakModelData&quot;</span><span class="p">:[],</span>
                    <span class="s2">&quot;rightPeakFit&quot;</span><span class="p">:</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="s2">&quot;rightPeakFitErr&quot;</span><span class="p">:[],</span><span class="s2">&quot;rightPeakFitRes&quot;</span><span class="p">:[],</span>
                    <span class="s2">&quot;msg&quot;</span><span class="p">:</span><span class="s2">&quot;&quot;</span><span class="p">,</span><span class="s2">&quot;midXValueLeft&quot;</span><span class="p">:[],</span><span class="s2">&quot;midXValueRight&quot;</span><span class="p">:[],</span>
                    <span class="s2">&quot;flag&quot;</span><span class="p">:</span><span class="n">flag</span>
                    <span class="p">}</span>

        <span class="c1"># Try to fit a gaussian to determine peak parameters</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="c1"># set initial parameters for data fitting</span>
            <span class="n">p</span> <span class="o">=</span> <span class="p">[</span><span class="nb">min</span><span class="p">(</span><span class="n">y</span><span class="p">),</span> <span class="n">x</span><span class="p">[</span><span class="n">midLeftLoc</span><span class="p">],</span> <span class="n">hpbw</span><span class="p">,</span> <span class="mf">.01</span><span class="p">,</span> <span class="mf">.0</span><span class="p">]</span>
            <span class="n">coeffl</span><span class="p">,</span> <span class="n">fitl</span><span class="p">,</span> <span class="n">flag</span> <span class="o">=</span> <span class="n">test_gauss_fit</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">AbeamScan</span><span class="p">],</span> <span class="n">y</span><span class="p">[</span><span class="n">AbeamScan</span><span class="p">],</span> <span class="n">p</span><span class="p">,</span><span class="n">log</span><span class="p">)</span>
            <span class="c1"># coeffl, covar_matrixl, fitLeft = fit_gauss_lin(</span>
            <span class="c1">#     x[AbeamScan], y[AbeamScan], p)</span>
        <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
            <span class="n">fl</span><span class="o">=</span><span class="mi">1</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;gaussian curve_fit algorithm failed&quot;</span>
            <span class="n">msg_wrapper</span><span class="p">(</span><span class="s2">&quot;debug&quot;</span><span class="p">,</span> <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">,</span> <span class="n">msg</span><span class="p">)</span>
            <span class="n">fitLeft</span> <span class="o">=</span> <span class="n">y</span><span class="p">[</span><span class="n">AbeamScan</span><span class="p">]</span>
            <span class="n">flag</span> <span class="o">=</span> <span class="mi">3</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="c1"># set initial parameters for data fitting</span>
            <span class="n">p</span> <span class="o">=</span> <span class="p">[</span><span class="nb">max</span><span class="p">(</span><span class="n">y</span><span class="p">),</span> <span class="n">x</span><span class="p">[</span><span class="n">midRightLoc</span><span class="p">],</span> <span class="n">hpbw</span><span class="p">,</span> <span class="mf">.01</span><span class="p">,</span> <span class="mf">.0</span><span class="p">]</span>
            <span class="n">coeffr</span><span class="p">,</span> <span class="n">fitr</span><span class="p">,</span> <span class="n">flagr</span> <span class="o">=</span> <span class="n">test_gauss_fit</span><span class="p">(</span> <span class="n">x</span><span class="p">[</span><span class="n">BbeamScan</span><span class="p">],</span> <span class="n">y</span><span class="p">[</span><span class="n">BbeamScan</span><span class="p">],</span> <span class="n">p</span><span class="p">,</span><span class="n">log</span><span class="p">)</span>
            <span class="c1"># coeffr, covar_matrixr, fitRight = fit_gauss_lin(</span>
            <span class="c1">#     x[BbeamScan], y[BbeamScan], p)</span>
        <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
            <span class="n">fr</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;gaussian curve_fit algorithm failed&quot;</span>
            <span class="n">msg_wrapper</span><span class="p">(</span><span class="s2">&quot;debug&quot;</span><span class="p">,</span> <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">,</span> <span class="n">msg</span><span class="p">)</span>
            <span class="n">fitRight</span> <span class="o">=</span> <span class="n">y</span><span class="p">[</span><span class="n">BbeamScan</span><span class="p">]</span>
            <span class="n">flag</span> <span class="o">=</span> <span class="mi">3</span>

    
        <span class="c1"># Determine peak fitting location</span>
        <span class="n">AbeamLeftLimit</span>  <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="n">ysplminloc</span><span class="p">]</span><span class="o">-</span><span class="n">hhpbw</span> <span class="c1">#coeffl[1] - hhpbw  # *2*.6</span>
        <span class="n">AbeamRightLimit</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="n">ysplminloc</span><span class="p">]</span><span class="o">+</span><span class="n">hhpbw</span>
        <span class="n">BbeamLeftLimit</span>  <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="n">ysplmaxloc</span><span class="p">]</span><span class="o">-</span><span class="n">hhpbw</span> <span class="c1">#coeffl[1] - hhpbw  # *2*.6</span>
        <span class="n">BbeamRightLimit</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="n">ysplmaxloc</span><span class="p">]</span><span class="o">+</span><span class="n">hhpbw</span>


        <span class="n">leftlocs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span>
            <span class="n">x</span> <span class="o">&gt;=</span> <span class="n">AbeamLeftLimit</span><span class="p">,</span> <span class="n">x</span> <span class="o">&lt;=</span> <span class="n">AbeamRightLimit</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">rightlocs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span>
            <span class="n">x</span> <span class="o">&gt;=</span> <span class="n">BbeamLeftLimit</span><span class="p">,</span> <span class="n">x</span> <span class="o">&lt;=</span> <span class="n">BbeamRightLimit</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span>


        <span class="c1">#select part of beam to fit</span>
        <span class="k">if</span> <span class="n">ysplmax</span> <span class="o">&lt;</span> <span class="mf">0.1</span><span class="p">:</span>
            <span class="n">flag</span> <span class="o">=</span> <span class="mi">36</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;fit entire left beam, max yspl &lt; 0.1&quot;</span>
            <span class="n">msg_wrapper</span><span class="p">(</span><span class="s2">&quot;warning&quot;</span><span class="p">,</span> <span class="n">log</span><span class="o">.</span><span class="n">warning</span><span class="p">,</span> <span class="n">msg</span><span class="p">)</span>
            <span class="n">rightMainBeamLocs</span> <span class="o">=</span> <span class="n">rightlocs</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">topCut</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">yspl</span><span class="p">[</span><span class="n">rightlocs</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">ysplmax</span><span class="o">*</span><span class="n">beamCut</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">rightMainBeamLocs</span> <span class="o">=</span> <span class="n">rightlocs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">+</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">topCut</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">ysplmin</span> <span class="o">&gt;</span> <span class="o">-</span><span class="mf">0.1</span><span class="p">:</span>
            <span class="n">flag</span> <span class="o">=</span> <span class="mi">35</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;fit entire right beam, min yspl &gt; -0.1&quot;</span>
            <span class="n">msg_wrapper</span><span class="p">(</span><span class="s2">&quot;warning&quot;</span><span class="p">,</span> <span class="n">log</span><span class="o">.</span><span class="n">warning</span><span class="p">,</span> <span class="n">msg</span><span class="p">)</span>
            <span class="n">leftMainBeamLocs</span> <span class="o">=</span> <span class="n">leftlocs</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">bottomCut</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">yspl</span><span class="p">[</span><span class="n">leftlocs</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">ysplmin</span><span class="o">*</span><span class="n">beamCut</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">leftMainBeamLocs</span> <span class="o">=</span> <span class="n">leftlocs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">+</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">bottomCut</span><span class="p">)</span>

    <span class="c1"># fit left peak</span>
    <span class="n">ypeakl</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">polyval</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">polyfit</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">leftMainBeamLocs</span><span class="p">],</span> <span class="n">yCorrected</span><span class="p">[</span><span class="n">leftMainBeamLocs</span><span class="p">],</span>  <span class="mi">2</span><span class="p">),</span> <span class="n">x</span><span class="p">[</span><span class="n">leftMainBeamLocs</span><span class="p">])</span>
    <span class="n">fitResl</span><span class="p">,</span> <span class="n">err_peakl</span> <span class="o">=</span> <span class="n">calc_residual</span><span class="p">(</span><span class="n">yCorrected</span><span class="p">[</span><span class="n">leftMainBeamLocs</span><span class="p">],</span> <span class="n">ypeakl</span><span class="p">)</span>

    <span class="c1"># fit right peak</span>
    <span class="n">ypeakr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">polyval</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">polyfit</span><span class="p">(</span>
        <span class="n">x</span><span class="p">[</span><span class="n">rightMainBeamLocs</span><span class="p">],</span> <span class="n">yCorrected</span><span class="p">[</span><span class="n">rightMainBeamLocs</span><span class="p">],</span>  <span class="mi">2</span><span class="p">),</span> <span class="n">x</span><span class="p">[</span><span class="n">rightMainBeamLocs</span><span class="p">])</span>
    <span class="n">fitResr</span><span class="p">,</span> <span class="n">err_peakr</span> <span class="o">=</span> <span class="n">calc_residual</span><span class="p">(</span><span class="n">yCorrected</span><span class="p">[</span><span class="n">rightMainBeamLocs</span><span class="p">],</span> <span class="n">ypeakr</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">fa</span><span class="o">==</span><span class="s2">&quot;p&quot;</span><span class="p">:</span>
        <span class="n">ymin</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">ypeakr</span><span class="p">)</span>
        <span class="n">ymax</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">ypeakl</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">ymin</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">ypeakl</span><span class="p">)</span>
        <span class="n">ymax</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">ypeakr</span><span class="p">)</span>

    <span class="n">msg_wrapper</span><span class="p">(</span><span class="s2">&quot;debug&quot;</span><span class="p">,</span> <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">,</span> <span class="s2">&quot;A/B beam peak&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">fa</span><span class="o">==</span><span class="s2">&quot;p&quot;</span><span class="p">:</span>
        <span class="n">msg_wrapper</span><span class="p">(</span><span class="s2">&quot;debug&quot;</span><span class="p">,</span> <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">,</span> <span class="s2">&quot;left: </span><span class="si">{:.3f}</span><span class="s2">, max: </span><span class="si">{:.3f}</span><span class="s2">, right: </span><span class="si">{:.3f}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
            <span class="n">ypeakl</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">ymax</span><span class="p">,</span> <span class="n">ypeakl</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]))</span>
        <span class="n">msg_wrapper</span><span class="p">(</span><span class="s2">&quot;debug&quot;</span><span class="p">,</span> <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">,</span> <span class="s2">&quot;left: </span><span class="si">{:.3f}</span><span class="s2">, min: </span><span class="si">{:.3f}</span><span class="s2">, right</span><span class="si">{:.3f}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
            <span class="n">ypeakr</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">ymin</span><span class="p">,</span> <span class="n">ypeakr</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]))</span>

        <span class="n">ypeakrdata</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="n">rightMainBeamLocs</span><span class="p">]</span>
        <span class="n">ypeakldata</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="n">leftMainBeamLocs</span><span class="p">]</span>

        <span class="c1"># check data doesn&#39;t overlap</span>
        <span class="n">overlapRight</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">baseLocsRight</span><span class="p">)</span> <span class="o">&amp;</span> <span class="nb">set</span><span class="p">(</span><span class="n">rightMainBeamLocs</span><span class="p">)</span>
        <span class="n">overlapLeft</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">baseLocsLeft</span><span class="p">)</span> <span class="o">&amp;</span> <span class="nb">set</span><span class="p">(</span><span class="n">leftMainBeamLocs</span><span class="p">)</span>
        <span class="c1"># overlapbeams = set(leftMainBeamLocs) &amp; set(rightMainBeamLocs)</span>

        <span class="n">msg</span><span class="o">=</span><span class="p">(</span><span class="s2">&quot;checking for overlapping beams: &quot;</span><span class="p">)</span>
        <span class="n">msg_wrapper</span><span class="p">(</span><span class="s2">&quot;debug&quot;</span><span class="p">,</span> <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">,</span> <span class="n">msg</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">overlapLeft</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;beams don&#39;t overlap on left&quot;</span>
            <span class="n">msg_wrapper</span><span class="p">(</span><span class="s2">&quot;debug&quot;</span><span class="p">,</span> <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">,</span> <span class="n">msg</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">leftMainBeamLocs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">baseLocsLeft</span><span class="p">[</span><span class="nb">int</span><span class="p">(</span>
                    <span class="nb">len</span><span class="p">(</span><span class="n">baseLocsLeft</span><span class="p">)</span><span class="o">*</span><span class="mf">.8</span><span class="p">)]:</span>
                <span class="k">pass</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">overlap</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="nb">iter</span><span class="p">(</span><span class="n">overlapLeft</span><span class="p">))</span>
                <span class="n">shift</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">leftMainBeamLocs</span><span class="p">)</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">overlap</span><span class="p">))</span>
                <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;Overlap found on A beam&quot;</span>
                <span class="n">flag</span> <span class="o">=</span> <span class="mi">33</span>
                <span class="n">msg_wrapper</span><span class="p">(</span><span class="s2">&quot;warning&quot;</span><span class="p">,</span> <span class="n">log</span><span class="o">.</span><span class="n">warning</span><span class="p">,</span> <span class="n">msg</span><span class="p">)</span>

                <span class="c1"># move beam to the left</span>
                <span class="n">f</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">leftMainBeamLocs</span><span class="p">)</span><span class="o">-</span><span class="n">shift</span><span class="p">)</span>
                <span class="n">leftMainBeamLocs</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">leftMainBeamLocs</span><span class="o">+</span><span class="n">f</span><span class="p">)</span>

                <span class="c1"># fit left peak</span>
                <span class="n">ypeakl</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">polyval</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">polyfit</span><span class="p">(</span>
                    <span class="n">x</span><span class="p">[</span><span class="n">leftMainBeamLocs</span><span class="p">],</span> <span class="n">yCorrected</span><span class="p">[</span><span class="n">leftMainBeamLocs</span><span class="p">],</span>  <span class="mi">2</span><span class="p">),</span> <span class="n">x</span><span class="p">[</span><span class="n">leftMainBeamLocs</span><span class="p">])</span>
                <span class="n">fitResl</span><span class="p">,</span> <span class="n">err_peakl</span> <span class="o">=</span> <span class="n">calc_residual</span><span class="p">(</span>
                    <span class="n">yCorrected</span><span class="p">[</span><span class="n">leftMainBeamLocs</span><span class="p">],</span> <span class="n">ypeakl</span><span class="p">)</span>

                <span class="n">ymax</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">ypeakl</span><span class="p">)</span>
                <span class="n">msg</span><span class="o">=</span><span class="s2">&quot;left: </span><span class="si">{:.3f}</span><span class="s2">, max: </span><span class="si">{:.3f}</span><span class="s2">, right: </span><span class="si">{:.3f}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                    <span class="n">ypeakl</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">ymax</span><span class="p">,</span> <span class="n">ypeakl</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
                <span class="n">msg_wrapper</span><span class="p">(</span><span class="s2">&quot;debug&quot;</span><span class="p">,</span> <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">,</span> <span class="n">msg</span><span class="p">)</span>

                <span class="k">if</span><span class="p">(</span><span class="n">ypeakl</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">ymax</span> <span class="ow">or</span> <span class="n">ypeakl</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">ymax</span><span class="p">):</span>
                    <span class="n">ymax</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
                    <span class="n">err_peakl</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">flag</span> <span class="o">=</span> <span class="mi">36</span>
                    <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;fit entire left beam&quot;</span>
                    <span class="n">msg_wrapper</span><span class="p">(</span><span class="s2">&quot;debug&quot;</span><span class="p">,</span> <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">,</span> <span class="n">msg</span><span class="p">)</span>

                <span class="k">return</span> <span class="p">{</span><span class="s2">&quot;correctedData&quot;</span><span class="p">:[],</span><span class="s2">&quot;driftRes&quot;</span><span class="p">:[],</span><span class="s2">&quot;driftRms&quot;</span><span class="p">:</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span>
                        <span class="s2">&quot;driftCoeffs&quot;</span><span class="p">:[],</span> <span class="s2">&quot;baseLocsCombined&quot;</span><span class="p">:[],</span>
                        <span class="s2">&quot;baseLocsLeft&quot;</span><span class="p">:[],</span><span class="s2">&quot;baseLocsRight&quot;</span><span class="p">:[],</span>
                    <span class="s2">&quot;leftPeakData&quot;</span><span class="p">:[],</span><span class="s2">&quot;leftPeakModelData&quot;</span><span class="p">:[],</span>
                    <span class="s2">&quot;leftPeakFit&quot;</span><span class="p">:</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="s2">&quot;leftPeakFitErr&quot;</span><span class="p">:</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span><span class="s2">&quot;leftPeakFitRes&quot;</span><span class="p">:[],</span>
                    <span class="s2">&quot;rightPeakData&quot;</span><span class="p">:[],</span><span class="s2">&quot;rightPeakModelData&quot;</span><span class="p">:[],</span>
                    <span class="s2">&quot;rightPeakFit&quot;</span><span class="p">:</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="s2">&quot;rightPeakFitErr&quot;</span><span class="p">:[],</span><span class="s2">&quot;rightPeakFitRes&quot;</span><span class="p">:[],</span>
                    <span class="s2">&quot;msg&quot;</span><span class="p">:</span><span class="s2">&quot;&quot;</span><span class="p">,</span><span class="s2">&quot;midXValueLeft&quot;</span><span class="p">:[],</span><span class="s2">&quot;midXValueRight&quot;</span><span class="p">:[],</span>
                    <span class="s2">&quot;flag&quot;</span><span class="p">:</span><span class="n">flag</span>
                    <span class="p">}</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">overlapRight</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>

            <span class="n">overlap</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="nb">iter</span><span class="p">(</span><span class="n">overlapRight</span><span class="p">))</span>
            <span class="n">shift</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">rightMainBeamLocs</span><span class="p">)</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">overlap</span><span class="p">))</span>

            <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;Overlap found on B beam&quot;</span>
            <span class="n">flag</span> <span class="o">=</span> <span class="mi">34</span>
            <span class="n">msg_wrapper</span><span class="p">(</span><span class="s2">&quot;warning&quot;</span><span class="p">,</span> <span class="n">log</span><span class="o">.</span><span class="n">warning</span><span class="p">,</span> <span class="n">msg</span><span class="p">)</span>

            <span class="c1"># move beam to the RIGHT</span>
            <span class="n">f</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">rightMainBeamLocs</span><span class="p">)</span><span class="o">-</span><span class="n">shift</span><span class="p">)</span>
            <span class="n">rightMainBeamLocs</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">rightMainBeamLocs</span><span class="o">-</span><span class="n">f</span><span class="p">)</span>

            <span class="n">msg</span><span class="o">=</span><span class="s2">&quot;beam shifted to left by </span><span class="si">{}</span><span class="s2"> points&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
            <span class="n">msg_wrapper</span><span class="p">(</span><span class="s2">&quot;debug&quot;</span><span class="p">,</span> <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">,</span> <span class="n">msg</span><span class="p">)</span>

            <span class="c1"># fit right peak</span>
            <span class="n">ypeakr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">polyval</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">polyfit</span><span class="p">(</span>
                <span class="n">x</span><span class="p">[</span><span class="n">rightMainBeamLocs</span><span class="p">],</span> <span class="n">yCorrected</span><span class="p">[</span><span class="n">rightMainBeamLocs</span><span class="p">],</span>  <span class="mi">2</span><span class="p">),</span> <span class="n">x</span><span class="p">[</span><span class="n">rightMainBeamLocs</span><span class="p">])</span>
            <span class="n">fitResr</span><span class="p">,</span> <span class="n">err_peakr</span> <span class="o">=</span> <span class="n">calc_residual</span><span class="p">(</span>
                <span class="n">yCorrected</span><span class="p">[</span><span class="n">rightMainBeamLocs</span><span class="p">],</span> <span class="n">ypeakr</span><span class="p">)</span>

            <span class="n">ymin</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">ypeakr</span><span class="p">)</span>

            <span class="n">msg</span><span class="o">=</span><span class="s2">&quot;left: </span><span class="si">{:.3f}</span><span class="s2">, min: </span><span class="si">{:.3f}</span><span class="s2">, right</span><span class="si">{:.3f}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                <span class="n">ypeakr</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">ymin</span><span class="p">,</span> <span class="n">ypeakr</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
            <span class="n">msg_wrapper</span><span class="p">(</span><span class="s2">&quot;debug&quot;</span><span class="p">,</span> <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">,</span> <span class="n">msg</span><span class="p">)</span>

            <span class="k">if</span><span class="p">(</span><span class="n">ypeakr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">ymin</span> <span class="ow">or</span> <span class="n">ypeakr</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">ymin</span><span class="p">):</span>
                <span class="n">ymin</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
                <span class="n">err_peakr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>

            <span class="k">else</span><span class="p">:</span>
                <span class="n">flag</span> <span class="o">=</span> <span class="mi">35</span>
                <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;fit entire right beam&quot;</span>
                <span class="n">msg_wrapper</span><span class="p">(</span><span class="s2">&quot;debug&quot;</span><span class="p">,</span> <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">,</span> <span class="n">msg</span><span class="p">)</span>

            <span class="n">ypeakrdata</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="n">rightMainBeamLocs</span><span class="p">]</span>

            <span class="c1">#pl.plot(x, yCorrected)</span>

<span class="w">            </span><span class="sd">&#39;&#39;&#39;#pl.plot(x[leftlocs],yCorrected[leftlocs])</span>
<span class="sd">            #pl.plot(x[leftMainBeamLocs], yCorrected[leftMainBeamLocs])</span>
<span class="sd">            #pl.plot(x[rightlocs],yCorrected[rightlocs])</span>
<span class="sd">            pl.plot(x[rightMainBeamLocs], yCorrected[rightMainBeamLocs])</span>
<span class="sd">            #pl.plot(x[leftMainBeamLocs], ypeakl)</span>
<span class="sd">            pl.plot(x[rightMainBeamLocs], ypeakr)</span>
<span class="sd">            pl.plot(x, np.zeros(scanLen))</span>
<span class="sd">            pl.plot(x[baseLocs], yCorrected[baseLocs], &quot;.&quot;)</span>
<span class="sd">            #pl.show()</span>
<span class="sd">            pl.close()</span>
<span class="sd">            #sys.exit()&#39;&#39;&#39;</span>

            <span class="k">return</span> <span class="p">{</span><span class="s2">&quot;correctedData&quot;</span><span class="p">:[],</span><span class="s2">&quot;driftRes&quot;</span><span class="p">:[],</span><span class="s2">&quot;driftRms&quot;</span><span class="p">:</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span>
                        <span class="s2">&quot;driftCoeffs&quot;</span><span class="p">:[],</span> <span class="s2">&quot;baseLocsCombined&quot;</span><span class="p">:[],</span>
                        <span class="s2">&quot;baseLocsLeft&quot;</span><span class="p">:[],</span><span class="s2">&quot;baseLocsRight&quot;</span><span class="p">:[],</span>
                    <span class="s2">&quot;leftPeakData&quot;</span><span class="p">:[],</span><span class="s2">&quot;leftPeakModelData&quot;</span><span class="p">:[],</span>
                    <span class="s2">&quot;leftPeakFit&quot;</span><span class="p">:</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="s2">&quot;leftPeakFitErr&quot;</span><span class="p">:</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span><span class="s2">&quot;leftPeakFitRes&quot;</span><span class="p">:[],</span>
                    <span class="s2">&quot;rightPeakData&quot;</span><span class="p">:[],</span><span class="s2">&quot;rightPeakModelData&quot;</span><span class="p">:[],</span>
                    <span class="s2">&quot;rightPeakFit&quot;</span><span class="p">:</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="s2">&quot;rightPeakFitErr&quot;</span><span class="p">:[],</span><span class="s2">&quot;rightPeakFitRes&quot;</span><span class="p">:[],</span>
                    <span class="s2">&quot;msg&quot;</span><span class="p">:</span><span class="s2">&quot;&quot;</span><span class="p">,</span><span class="s2">&quot;midXValueLeft&quot;</span><span class="p">:[],</span><span class="s2">&quot;midXValueRight&quot;</span><span class="p">:[],</span>
                    <span class="s2">&quot;flag&quot;</span><span class="p">:</span><span class="n">flag</span>
                    <span class="p">}</span>

        <span class="k">if</span> <span class="p">((</span><span class="n">x</span><span class="p">[</span><span class="n">leftMainBeamLocs</span><span class="p">])[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">):</span>
            <span class="n">flag</span> <span class="o">=</span> <span class="mi">28</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;left beam data goes beyond midpoint&quot;</span>
            <span class="n">msg_wrapper</span><span class="p">(</span><span class="s2">&quot;warning&quot;</span><span class="p">,</span> <span class="n">log</span><span class="o">.</span><span class="n">warning</span><span class="p">,</span> <span class="n">msg</span><span class="p">)</span>
            <span class="k">return</span> <span class="p">{</span><span class="s2">&quot;correctedData&quot;</span><span class="p">:[],</span><span class="s2">&quot;driftRes&quot;</span><span class="p">:[],</span><span class="s2">&quot;driftRms&quot;</span><span class="p">:</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span>
                        <span class="s2">&quot;driftCoeffs&quot;</span><span class="p">:[],</span> <span class="s2">&quot;baseLocsCombined&quot;</span><span class="p">:[],</span>
                        <span class="s2">&quot;baseLocsLeft&quot;</span><span class="p">:[],</span><span class="s2">&quot;baseLocsRight&quot;</span><span class="p">:[],</span>
                    <span class="s2">&quot;leftPeakData&quot;</span><span class="p">:[],</span><span class="s2">&quot;leftPeakModelData&quot;</span><span class="p">:[],</span>
                    <span class="s2">&quot;leftPeakFit&quot;</span><span class="p">:</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="s2">&quot;leftPeakFitErr&quot;</span><span class="p">:</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span><span class="s2">&quot;leftPeakFitRes&quot;</span><span class="p">:[],</span>
                    <span class="s2">&quot;rightPeakData&quot;</span><span class="p">:[],</span><span class="s2">&quot;rightPeakModelData&quot;</span><span class="p">:[],</span>
                    <span class="s2">&quot;rightPeakFit&quot;</span><span class="p">:</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="s2">&quot;rightPeakFitErr&quot;</span><span class="p">:[],</span><span class="s2">&quot;rightPeakFitRes&quot;</span><span class="p">:[],</span>
                    <span class="s2">&quot;msg&quot;</span><span class="p">:</span><span class="s2">&quot;&quot;</span><span class="p">,</span><span class="s2">&quot;midXValueLeft&quot;</span><span class="p">:[],</span><span class="s2">&quot;midXValueRight&quot;</span><span class="p">:[],</span>
                    <span class="s2">&quot;flag&quot;</span><span class="p">:</span><span class="n">flag</span>
                    <span class="p">}</span>

        <span class="k">if</span> <span class="p">((</span><span class="n">x</span><span class="p">[</span><span class="n">rightMainBeamLocs</span><span class="p">])[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">):</span>
            <span class="n">flag</span> <span class="o">=</span> <span class="mi">29</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;right beam data goes beyond midpoint&quot;</span>
            <span class="n">msg_wrapper</span><span class="p">(</span><span class="s2">&quot;warning&quot;</span><span class="p">,</span> <span class="n">log</span><span class="o">.</span><span class="n">warning</span><span class="p">,</span> <span class="n">msg</span><span class="p">)</span>
            <span class="k">return</span> <span class="p">{</span><span class="s2">&quot;correctedData&quot;</span><span class="p">:[],</span><span class="s2">&quot;driftRes&quot;</span><span class="p">:[],</span><span class="s2">&quot;driftRms&quot;</span><span class="p">:</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span>
                        <span class="s2">&quot;driftCoeffs&quot;</span><span class="p">:[],</span> <span class="s2">&quot;baseLocsCombined&quot;</span><span class="p">:[],</span>
                        <span class="s2">&quot;baseLocsLeft&quot;</span><span class="p">:[],</span><span class="s2">&quot;baseLocsRight&quot;</span><span class="p">:[],</span>
                    <span class="s2">&quot;leftPeakData&quot;</span><span class="p">:[],</span><span class="s2">&quot;leftPeakModelData&quot;</span><span class="p">:[],</span>
                    <span class="s2">&quot;leftPeakFit&quot;</span><span class="p">:</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="s2">&quot;leftPeakFitErr&quot;</span><span class="p">:</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span><span class="s2">&quot;leftPeakFitRes&quot;</span><span class="p">:[],</span>
                    <span class="s2">&quot;rightPeakData&quot;</span><span class="p">:[],</span><span class="s2">&quot;rightPeakModelData&quot;</span><span class="p">:[],</span>
                    <span class="s2">&quot;rightPeakFit&quot;</span><span class="p">:</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="s2">&quot;rightPeakFitErr&quot;</span><span class="p">:[],</span><span class="s2">&quot;rightPeakFitRes&quot;</span><span class="p">:[],</span>
                    <span class="s2">&quot;msg&quot;</span><span class="p">:</span><span class="s2">&quot;&quot;</span><span class="p">,</span><span class="s2">&quot;midXValueLeft&quot;</span><span class="p">:[],</span><span class="s2">&quot;midXValueRight&quot;</span><span class="p">:[],</span>
                    <span class="s2">&quot;flag&quot;</span><span class="p">:</span><span class="n">flag</span>
                    <span class="p">}</span>

        <span class="c1"># import matplotlib.pyplot as pl</span>
        <span class="c1"># pl.plot(x, yCorrected, label=&quot;corrected data&quot;)</span>
        <span class="c1"># pl.plot(x[leftlocs], yCorrected[leftlocs], label=&quot;peakl data&quot;)</span>
        <span class="c1"># pl.plot(x[leftMainBeamLocs], yCorrected[leftMainBeamLocs])</span>
        <span class="c1"># pl.plot(x[rightlocs], yCorrected[rightlocs], label=&quot;peakr data&quot;)</span>
        <span class="c1"># pl.plot(x[rightMainBeamLocs], yCorrected[rightMainBeamLocs])</span>
        <span class="c1"># pl.plot(x[leftMainBeamLocs],</span>
        <span class="c1">#         ypeakl, label=&quot;peak fitl: {:.3f} +- {:.3f}&quot;.format(ymax, err_peakl))</span>
        <span class="c1"># pl.plot(x[rightMainBeamLocs], ypeakr,</span>
        <span class="c1">#         label=&quot;peak fitr: {:.3f} +- {:.3f}&quot;.format(ymin, err_peakr))</span>
        <span class="c1"># pl.plot(x[baseLocs], yCorrected[baseLocs], &quot;.&quot;, label=&quot;baselocs&quot;)</span>
        <span class="c1"># pl.plot(x, np.zeros(scanLen))</span>
        <span class="c1"># pl.legend(loc=&quot;best&quot;)</span>
        <span class="c1"># pl.grid()</span>
        <span class="c1"># #pl.show()</span>
        <span class="c1"># try:</span>
        <span class="c1">#     pl.savefig(saveFolder+&quot;fitted.png&quot;)</span>
        <span class="c1"># except:</span>
        <span class="c1">#     pass</span>
        <span class="c1"># pl.close()</span>
        <span class="c1"># sys.exit()</span>
        
        <span class="n">msg_wrapper</span><span class="p">(</span><span class="s2">&quot;info&quot;</span><span class="p">,</span> <span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">,</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="n">msg_wrapper</span><span class="p">(</span><span class="s2">&quot;info&quot;</span><span class="p">,</span> <span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">,</span> <span class="s2">&quot;-&quot;</span><span class="o">*</span><span class="mi">30</span><span class="p">)</span>
        <span class="n">msg_wrapper</span><span class="p">(</span><span class="s2">&quot;info&quot;</span><span class="p">,</span> <span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">,</span> <span class="s2">&quot;Fit the peaks&quot;</span><span class="p">)</span>
        <span class="n">msg_wrapper</span><span class="p">(</span><span class="s2">&quot;info&quot;</span><span class="p">,</span> <span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">,</span><span class="s2">&quot;-&quot;</span><span class="o">*</span><span class="mi">30</span><span class="p">)</span>

        <span class="n">msg</span><span class="o">=</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">peak left: </span><span class="si">{:.3f}</span><span class="s2"> +- </span><span class="si">{:.3f}</span><span class="s2"> K</span><span class="se">\n</span><span class="s2">peak right: </span><span class="si">{:.3f}</span><span class="s2"> +- </span><span class="si">{:.3f}</span><span class="s2"> K</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
            <span class="n">ymax</span><span class="p">,</span> <span class="n">err_peakl</span><span class="p">,</span> <span class="n">ymin</span><span class="p">,</span> <span class="n">err_peakr</span><span class="p">)</span>
        <span class="n">msg_wrapper</span><span class="p">(</span><span class="s2">&quot;info&quot;</span><span class="p">,</span> <span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">,</span> <span class="n">msg</span><span class="p">)</span>
        
        <span class="c1"># find final peak loc</span>
        <span class="n">ploca</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">ypeakl</span> <span class="o">==</span> <span class="n">ymax</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">ploca</span><span class="p">)</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span>
            <span class="n">peakLoca</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">peakLoca</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">leftMainBeamLocs</span><span class="p">])[</span><span class="n">ploca</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>

        <span class="c1"># find final peak loc</span>
        <span class="n">plocb</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">ypeakr</span> <span class="o">==</span> <span class="n">ymin</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> 
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">plocb</span><span class="p">)</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span>    
            <span class="n">peakLocb</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">peakLocb</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">rightMainBeamLocs</span><span class="p">])[</span><span class="n">plocb</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>


        <span class="k">return</span> <span class="p">{</span><span class="s2">&quot;correctedData&quot;</span><span class="p">:</span><span class="n">yCorrected</span><span class="p">,</span><span class="s2">&quot;driftRes&quot;</span><span class="p">:</span><span class="n">driftRes</span><span class="p">,</span><span class="s2">&quot;driftRms&quot;</span><span class="p">:</span><span class="n">driftRms</span><span class="p">,</span>
                        <span class="s2">&quot;driftCoeffs&quot;</span><span class="p">:</span><span class="n">driftCoeffs</span><span class="p">,</span> <span class="s2">&quot;baseLocsCombined&quot;</span><span class="p">:</span><span class="n">baseLocs</span><span class="p">,</span>
                        <span class="s2">&quot;baseLocsLeft&quot;</span><span class="p">:</span><span class="n">leftMainBeamLocs</span><span class="p">,</span><span class="s2">&quot;baseLocsRight&quot;</span><span class="p">:</span><span class="n">rightMainBeamLocs</span><span class="p">,</span>
                    <span class="s2">&quot;leftPeakData&quot;</span><span class="p">:</span><span class="n">ypeakldata</span><span class="p">,</span><span class="s2">&quot;leftPeakModelData&quot;</span><span class="p">:</span><span class="n">ypeakl</span><span class="p">,</span>
                    <span class="s2">&quot;leftPeakFit&quot;</span><span class="p">:</span><span class="n">ymax</span><span class="p">,</span> <span class="s2">&quot;leftPeakFitErr&quot;</span><span class="p">:</span><span class="n">err_peakl</span><span class="p">,</span><span class="s2">&quot;leftPeakFitRes&quot;</span><span class="p">:</span><span class="n">fitResl</span><span class="p">,</span>
                    <span class="s2">&quot;rightPeakData&quot;</span><span class="p">:</span><span class="n">ypeakrdata</span><span class="p">,</span><span class="s2">&quot;rightPeakModelData&quot;</span><span class="p">:</span><span class="n">ypeakr</span><span class="p">,</span>
                    <span class="s2">&quot;rightPeakFit&quot;</span><span class="p">:</span><span class="n">ymin</span><span class="p">,</span> <span class="s2">&quot;rightPeakFitErr&quot;</span><span class="p">:</span><span class="n">err_peakr</span><span class="p">,</span><span class="s2">&quot;rightPeakFitRes&quot;</span><span class="p">:</span><span class="n">fitResr</span><span class="p">,</span>
                    <span class="s2">&quot;msg&quot;</span><span class="p">:</span><span class="s2">&quot;&quot;</span><span class="p">,</span><span class="s2">&quot;midXValueLeft&quot;</span><span class="p">:</span><span class="n">peakLoca</span><span class="p">,</span><span class="s2">&quot;midXValueRight&quot;</span><span class="p">:</span><span class="n">peakLocb</span><span class="p">,</span>
                    <span class="s2">&quot;flag&quot;</span><span class="p">:</span><span class="n">flag</span>
                    <span class="p">}</span>

    <span class="k">else</span><span class="p">:</span>
        <span class="n">msg_wrapper</span><span class="p">(</span><span class="s2">&quot;debug&quot;</span><span class="p">,</span> <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">,</span> <span class="s2">&quot;left: </span><span class="si">{:.3f}</span><span class="s2">, min: </span><span class="si">{:.3f}</span><span class="s2">, right: </span><span class="si">{:.3f}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
            <span class="n">ypeakl</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">ymin</span><span class="p">,</span> <span class="n">ypeakl</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]))</span>
        <span class="n">msg_wrapper</span><span class="p">(</span><span class="s2">&quot;debug&quot;</span><span class="p">,</span> <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">,</span> <span class="s2">&quot;left: </span><span class="si">{:.3f}</span><span class="s2">, max: </span><span class="si">{:.3f}</span><span class="s2">, right</span><span class="si">{:.3f}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
            <span class="n">ypeakr</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">ymax</span><span class="p">,</span> <span class="n">ypeakr</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]))</span>

        <span class="n">ypeakrdata</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="n">rightMainBeamLocs</span><span class="p">]</span>
        <span class="n">ypeakldata</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="n">leftMainBeamLocs</span><span class="p">]</span>

        <span class="c1"># check data doesn&#39;t overlap</span>
        <span class="n">overlapRight</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">baseLocsRight</span><span class="p">)</span> <span class="o">&amp;</span> <span class="nb">set</span><span class="p">(</span><span class="n">rightMainBeamLocs</span><span class="p">)</span>
        <span class="n">overlapLeft</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">baseLocsLeft</span><span class="p">)</span> <span class="o">&amp;</span> <span class="nb">set</span><span class="p">(</span><span class="n">leftMainBeamLocs</span><span class="p">)</span>
        <span class="c1"># overlapbeams = set(leftMainBeamLocs) &amp; set(rightMainBeamLocs)</span>

        <span class="n">msg</span><span class="o">=</span><span class="p">(</span><span class="s2">&quot;checking for overlapping beams: &quot;</span><span class="p">)</span>
        <span class="n">msg_wrapper</span><span class="p">(</span><span class="s2">&quot;debug&quot;</span><span class="p">,</span> <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">,</span> <span class="n">msg</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">overlapLeft</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;beams don&#39;t overlap on left&quot;</span>
            <span class="n">msg_wrapper</span><span class="p">(</span><span class="s2">&quot;debug&quot;</span><span class="p">,</span> <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">,</span> <span class="n">msg</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">leftMainBeamLocs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">baseLocsLeft</span><span class="p">[</span><span class="nb">int</span><span class="p">(</span>
                    <span class="nb">len</span><span class="p">(</span><span class="n">baseLocsLeft</span><span class="p">)</span><span class="o">*</span><span class="mf">.8</span><span class="p">)]:</span>
                <span class="k">pass</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">overlap</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="nb">iter</span><span class="p">(</span><span class="n">overlapLeft</span><span class="p">))</span>
                <span class="n">shift</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">leftMainBeamLocs</span><span class="p">)</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">overlap</span><span class="p">))</span>
                <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;Overlap found on A beam&quot;</span>
                <span class="n">flag</span> <span class="o">=</span> <span class="mi">33</span>
                <span class="n">msg_wrapper</span><span class="p">(</span><span class="s2">&quot;warning&quot;</span><span class="p">,</span> <span class="n">log</span><span class="o">.</span><span class="n">warning</span><span class="p">,</span> <span class="n">msg</span><span class="p">)</span>

                <span class="c1"># move beam to the left</span>
                <span class="n">f</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">leftMainBeamLocs</span><span class="p">)</span><span class="o">-</span><span class="n">shift</span><span class="p">)</span>
                <span class="n">leftMainBeamLocs</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">leftMainBeamLocs</span><span class="o">+</span><span class="n">f</span><span class="p">)</span>

                <span class="c1"># fit left peak</span>
                <span class="n">ypeakl</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">polyval</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">polyfit</span><span class="p">(</span>
                    <span class="n">x</span><span class="p">[</span><span class="n">leftMainBeamLocs</span><span class="p">],</span> <span class="n">yCorrected</span><span class="p">[</span><span class="n">leftMainBeamLocs</span><span class="p">],</span>  <span class="mi">2</span><span class="p">),</span> <span class="n">x</span><span class="p">[</span><span class="n">leftMainBeamLocs</span><span class="p">])</span>
                <span class="n">fitResl</span><span class="p">,</span> <span class="n">err_peakl</span> <span class="o">=</span> <span class="n">calc_residual</span><span class="p">(</span>
                    <span class="n">yCorrected</span><span class="p">[</span><span class="n">leftMainBeamLocs</span><span class="p">],</span> <span class="n">ypeakl</span><span class="p">)</span>

                <span class="n">ymax</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">ypeakl</span><span class="p">)</span>
                <span class="n">msg</span><span class="o">=</span><span class="s2">&quot;left: </span><span class="si">{:.3f}</span><span class="s2">, max: </span><span class="si">{:.3f}</span><span class="s2">, right: </span><span class="si">{:.3f}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                    <span class="n">ypeakl</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">ymax</span><span class="p">,</span> <span class="n">ypeakl</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
                <span class="n">msg_wrapper</span><span class="p">(</span><span class="s2">&quot;debug&quot;</span><span class="p">,</span> <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">,</span> <span class="n">msg</span><span class="p">)</span>

                <span class="k">if</span><span class="p">(</span><span class="n">ypeakl</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">ymax</span> <span class="ow">or</span> <span class="n">ypeakl</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">ymax</span><span class="p">):</span>
                    <span class="n">ymax</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
                    <span class="n">err_peakl</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">flag</span> <span class="o">=</span> <span class="mi">36</span>
                    <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;fit entire left beam&quot;</span>
                    <span class="n">msg_wrapper</span><span class="p">(</span><span class="s2">&quot;debug&quot;</span><span class="p">,</span> <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">,</span> <span class="n">msg</span><span class="p">)</span>

                <span class="n">ypeakldata</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="n">leftMainBeamLocs</span><span class="p">]</span>

<span class="w">                </span><span class="sd">&#39;&#39;&#39;pl.plot(x, yCorrected)</span>
<span class="sd">                pl.plot(x[leftMainBeamLocs], yCorrected[leftMainBeamLocs], &#39;b&#39;)</span>
<span class="sd">                #pl.plot(x[rightlocs],yCorrected[rightlocs])</span>
<span class="sd">                #pl.plot(x[rightMainBeamLocs], yCorrected[rightMainBeamLocs])</span>
<span class="sd">                pl.plot(x[leftMainBeamLocs], ypeakl, &#39;r&#39;)</span>
<span class="sd">                #pl.plot(x[rightMainBeamLocs], ypeakr)</span>
<span class="sd">                pl.plot(x, np.zeros(scanLen))</span>
<span class="sd">                pl.plot(x[baseLocs], yCorrected[baseLocs], &quot;.&quot;)</span>
<span class="sd">                #pl.show()</span>
<span class="sd">                pl.close()</span>
<span class="sd">                #sys.exit()&#39;&#39;&#39;</span>

                <span class="k">return</span> <span class="p">{</span><span class="s2">&quot;correctedData&quot;</span><span class="p">:[],</span><span class="s2">&quot;driftRes&quot;</span><span class="p">:[],</span><span class="s2">&quot;driftRms&quot;</span><span class="p">:</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span>
                        <span class="s2">&quot;driftCoeffs&quot;</span><span class="p">:[],</span> <span class="s2">&quot;baseLocsCombined&quot;</span><span class="p">:[],</span>
                        <span class="s2">&quot;baseLocsLeft&quot;</span><span class="p">:[],</span><span class="s2">&quot;baseLocsRight&quot;</span><span class="p">:[],</span>
                    <span class="s2">&quot;leftPeakData&quot;</span><span class="p">:[],</span><span class="s2">&quot;leftPeakModelData&quot;</span><span class="p">:[],</span>
                    <span class="s2">&quot;leftPeakFit&quot;</span><span class="p">:</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="s2">&quot;leftPeakFitErr&quot;</span><span class="p">:</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span><span class="s2">&quot;leftPeakFitRes&quot;</span><span class="p">:[],</span>
                    <span class="s2">&quot;rightPeakData&quot;</span><span class="p">:[],</span><span class="s2">&quot;rightPeakModelData&quot;</span><span class="p">:[],</span>
                    <span class="s2">&quot;rightPeakFit&quot;</span><span class="p">:</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="s2">&quot;rightPeakFitErr&quot;</span><span class="p">:[],</span><span class="s2">&quot;rightPeakFitRes&quot;</span><span class="p">:[],</span>
                    <span class="s2">&quot;msg&quot;</span><span class="p">:</span><span class="s2">&quot;&quot;</span><span class="p">,</span><span class="s2">&quot;midXValueLeft&quot;</span><span class="p">:[],</span><span class="s2">&quot;midXValueRight&quot;</span><span class="p">:[],</span>
                    <span class="s2">&quot;flag&quot;</span><span class="p">:</span><span class="n">flag</span>
                    <span class="p">}</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">overlapRight</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>

            <span class="n">overlap</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="nb">iter</span><span class="p">(</span><span class="n">overlapRight</span><span class="p">))</span>
            <span class="n">shift</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">rightMainBeamLocs</span><span class="p">)</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">overlap</span><span class="p">))</span>

            <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;Overlap found on B beam&quot;</span>
            <span class="n">flag</span> <span class="o">=</span> <span class="mi">34</span>
            <span class="n">msg_wrapper</span><span class="p">(</span><span class="s2">&quot;warning&quot;</span><span class="p">,</span> <span class="n">log</span><span class="o">.</span><span class="n">warning</span><span class="p">,</span> <span class="n">msg</span><span class="p">)</span>

            <span class="c1"># move beam to the RIGHT</span>
            <span class="n">f</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">rightMainBeamLocs</span><span class="p">)</span><span class="o">-</span><span class="n">shift</span><span class="p">)</span>
            <span class="n">rightMainBeamLocs</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">rightMainBeamLocs</span><span class="o">-</span><span class="n">f</span><span class="p">)</span>

            <span class="n">msg</span><span class="o">=</span><span class="s2">&quot;beam shifted to left by </span><span class="si">{}</span><span class="s2"> points&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
            <span class="n">msg_wrapper</span><span class="p">(</span><span class="s2">&quot;debug&quot;</span><span class="p">,</span> <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">,</span> <span class="n">msg</span><span class="p">)</span>

            <span class="c1"># fit right peak</span>
            <span class="n">ypeakr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">polyval</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">polyfit</span><span class="p">(</span>
                <span class="n">x</span><span class="p">[</span><span class="n">rightMainBeamLocs</span><span class="p">],</span> <span class="n">yCorrected</span><span class="p">[</span><span class="n">rightMainBeamLocs</span><span class="p">],</span>  <span class="mi">2</span><span class="p">),</span> <span class="n">x</span><span class="p">[</span><span class="n">rightMainBeamLocs</span><span class="p">])</span>
            <span class="n">fitResr</span><span class="p">,</span> <span class="n">err_peakr</span> <span class="o">=</span> <span class="n">calc_residual</span><span class="p">(</span>
                <span class="n">yCorrected</span><span class="p">[</span><span class="n">rightMainBeamLocs</span><span class="p">],</span> <span class="n">ypeakr</span><span class="p">)</span>

            <span class="n">ymin</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">ypeakr</span><span class="p">)</span>

            <span class="n">msg</span><span class="o">=</span><span class="s2">&quot;left: </span><span class="si">{:.3f}</span><span class="s2">, min: </span><span class="si">{:.3f}</span><span class="s2">, right</span><span class="si">{:.3f}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                <span class="n">ypeakr</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">ymin</span><span class="p">,</span> <span class="n">ypeakr</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
            <span class="n">msg_wrapper</span><span class="p">(</span><span class="s2">&quot;debug&quot;</span><span class="p">,</span> <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">,</span> <span class="n">msg</span><span class="p">)</span>

            <span class="k">if</span><span class="p">(</span><span class="n">ypeakr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">ymin</span> <span class="ow">or</span> <span class="n">ypeakr</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">ymin</span><span class="p">):</span>
                <span class="n">ymin</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
                <span class="n">err_peakr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>

            <span class="k">else</span><span class="p">:</span>
                <span class="n">flag</span> <span class="o">=</span> <span class="mi">35</span>
                <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;fit entire right beam&quot;</span>
                <span class="n">msg_wrapper</span><span class="p">(</span><span class="s2">&quot;debug&quot;</span><span class="p">,</span> <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">,</span> <span class="n">msg</span><span class="p">)</span>

            <span class="n">ypeakrdata</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="n">rightMainBeamLocs</span><span class="p">]</span>

            <span class="c1">#pl.plot(x, yCorrected)</span>

<span class="w">            </span><span class="sd">&#39;&#39;&#39;#pl.plot(x[leftlocs],yCorrected[leftlocs])</span>
<span class="sd">            #pl.plot(x[leftMainBeamLocs], yCorrected[leftMainBeamLocs])</span>
<span class="sd">            #pl.plot(x[rightlocs],yCorrected[rightlocs])</span>
<span class="sd">            pl.plot(x[rightMainBeamLocs], yCorrected[rightMainBeamLocs])</span>
<span class="sd">            #pl.plot(x[leftMainBeamLocs], ypeakl)</span>
<span class="sd">            pl.plot(x[rightMainBeamLocs], ypeakr)</span>
<span class="sd">            pl.plot(x, np.zeros(scanLen))</span>
<span class="sd">            pl.plot(x[baseLocs], yCorrected[baseLocs], &quot;.&quot;)</span>
<span class="sd">            #pl.show()</span>
<span class="sd">            pl.close()</span>
<span class="sd">            #sys.exit()&#39;&#39;&#39;</span>

            <span class="k">return</span> <span class="p">{</span><span class="s2">&quot;correctedData&quot;</span><span class="p">:[],</span><span class="s2">&quot;driftRes&quot;</span><span class="p">:[],</span><span class="s2">&quot;driftRms&quot;</span><span class="p">:</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span>
                        <span class="s2">&quot;driftCoeffs&quot;</span><span class="p">:[],</span> <span class="s2">&quot;baseLocsCombined&quot;</span><span class="p">:[],</span>
                        <span class="s2">&quot;baseLocsLeft&quot;</span><span class="p">:[],</span><span class="s2">&quot;baseLocsRight&quot;</span><span class="p">:[],</span>
                    <span class="s2">&quot;leftPeakData&quot;</span><span class="p">:[],</span><span class="s2">&quot;leftPeakModelData&quot;</span><span class="p">:[],</span>
                    <span class="s2">&quot;leftPeakFit&quot;</span><span class="p">:</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="s2">&quot;leftPeakFitErr&quot;</span><span class="p">:</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span><span class="s2">&quot;leftPeakFitRes&quot;</span><span class="p">:[],</span>
                    <span class="s2">&quot;rightPeakData&quot;</span><span class="p">:[],</span><span class="s2">&quot;rightPeakModelData&quot;</span><span class="p">:[],</span>
                    <span class="s2">&quot;rightPeakFit&quot;</span><span class="p">:</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="s2">&quot;rightPeakFitErr&quot;</span><span class="p">:[],</span><span class="s2">&quot;rightPeakFitRes&quot;</span><span class="p">:[],</span>
                    <span class="s2">&quot;msg&quot;</span><span class="p">:</span><span class="s2">&quot;&quot;</span><span class="p">,</span><span class="s2">&quot;midXValueLeft&quot;</span><span class="p">:[],</span><span class="s2">&quot;midXValueRight&quot;</span><span class="p">:[],</span>
                    <span class="s2">&quot;flag&quot;</span><span class="p">:</span><span class="n">flag</span>
                    <span class="p">}</span>

        <span class="k">if</span> <span class="p">((</span><span class="n">x</span><span class="p">[</span><span class="n">leftMainBeamLocs</span><span class="p">])[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">):</span>
            <span class="n">flag</span> <span class="o">=</span> <span class="mi">28</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;left beam data goes beyond midpoint&quot;</span>
            <span class="n">msg_wrapper</span><span class="p">(</span><span class="s2">&quot;warning&quot;</span><span class="p">,</span> <span class="n">log</span><span class="o">.</span><span class="n">warning</span><span class="p">,</span> <span class="n">msg</span><span class="p">)</span>
            <span class="k">return</span> <span class="p">{</span><span class="s2">&quot;correctedData&quot;</span><span class="p">:[],</span><span class="s2">&quot;driftRes&quot;</span><span class="p">:[],</span><span class="s2">&quot;driftRms&quot;</span><span class="p">:</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span>
                        <span class="s2">&quot;driftCoeffs&quot;</span><span class="p">:[],</span> <span class="s2">&quot;baseLocsCombined&quot;</span><span class="p">:[],</span>
                        <span class="s2">&quot;baseLocsLeft&quot;</span><span class="p">:[],</span><span class="s2">&quot;baseLocsRight&quot;</span><span class="p">:[],</span>
                    <span class="s2">&quot;leftPeakData&quot;</span><span class="p">:[],</span><span class="s2">&quot;leftPeakModelData&quot;</span><span class="p">:[],</span>
                    <span class="s2">&quot;leftPeakFit&quot;</span><span class="p">:</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="s2">&quot;leftPeakFitErr&quot;</span><span class="p">:</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span><span class="s2">&quot;leftPeakFitRes&quot;</span><span class="p">:[],</span>
                    <span class="s2">&quot;rightPeakData&quot;</span><span class="p">:[],</span><span class="s2">&quot;rightPeakModelData&quot;</span><span class="p">:[],</span>
                    <span class="s2">&quot;rightPeakFit&quot;</span><span class="p">:</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="s2">&quot;rightPeakFitErr&quot;</span><span class="p">:[],</span><span class="s2">&quot;rightPeakFitRes&quot;</span><span class="p">:[],</span>
                    <span class="s2">&quot;msg&quot;</span><span class="p">:</span><span class="s2">&quot;&quot;</span><span class="p">,</span><span class="s2">&quot;midXValueLeft&quot;</span><span class="p">:[],</span><span class="s2">&quot;midXValueRight&quot;</span><span class="p">:[],</span>
                    <span class="s2">&quot;flag&quot;</span><span class="p">:</span><span class="n">flag</span>
                    <span class="p">}</span>

        <span class="k">if</span> <span class="p">((</span><span class="n">x</span><span class="p">[</span><span class="n">rightMainBeamLocs</span><span class="p">])[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">):</span>
            <span class="n">flag</span> <span class="o">=</span> <span class="mi">29</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;right beam data goes beyond midpoint&quot;</span>
            <span class="n">msg_wrapper</span><span class="p">(</span><span class="s2">&quot;warning&quot;</span><span class="p">,</span> <span class="n">log</span><span class="o">.</span><span class="n">warning</span><span class="p">,</span> <span class="n">msg</span><span class="p">)</span>
            <span class="c1"># return [], [], [], np.nan, [], \</span>
            <span class="c1">#     [], [], np.nan, np.nan, [], \</span>
            <span class="c1">#     [], [], np.nan, np.nan, [],\</span>
            <span class="c1">#     msg, flag, np.nan, np.nan</span>
            <span class="k">return</span> <span class="p">{</span><span class="s2">&quot;correctedData&quot;</span><span class="p">:[],</span><span class="s2">&quot;driftRes&quot;</span><span class="p">:[],</span><span class="s2">&quot;driftRms&quot;</span><span class="p">:</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span>
                        <span class="s2">&quot;driftCoeffs&quot;</span><span class="p">:[],</span> <span class="s2">&quot;baseLocsCombined&quot;</span><span class="p">:[],</span>
                        <span class="s2">&quot;baseLocsLeft&quot;</span><span class="p">:[],</span><span class="s2">&quot;baseLocsRight&quot;</span><span class="p">:[],</span>
                    <span class="s2">&quot;leftPeakData&quot;</span><span class="p">:[],</span><span class="s2">&quot;leftPeakModelData&quot;</span><span class="p">:[],</span>
                    <span class="s2">&quot;leftPeakFit&quot;</span><span class="p">:</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="s2">&quot;leftPeakFitErr&quot;</span><span class="p">:</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span><span class="s2">&quot;leftPeakFitRes&quot;</span><span class="p">:[],</span>
                    <span class="s2">&quot;rightPeakData&quot;</span><span class="p">:[],</span><span class="s2">&quot;rightPeakModelData&quot;</span><span class="p">:[],</span>
                    <span class="s2">&quot;rightPeakFit&quot;</span><span class="p">:</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="s2">&quot;rightPeakFitErr&quot;</span><span class="p">:[],</span><span class="s2">&quot;rightPeakFitRes&quot;</span><span class="p">:[],</span>
                    <span class="s2">&quot;msg&quot;</span><span class="p">:</span><span class="s2">&quot;&quot;</span><span class="p">,</span><span class="s2">&quot;midXValueLeft&quot;</span><span class="p">:[],</span><span class="s2">&quot;midXValueRight&quot;</span><span class="p">:[],</span>
                    <span class="s2">&quot;flag&quot;</span><span class="p">:</span><span class="n">flag</span>
                    <span class="p">}</span>
            

        <span class="c1"># import matplotlib.pyplot as pl </span>
        <span class="c1"># pl.plot(x, yCorrected, label=&quot;corrected data&quot;)</span>
        <span class="c1"># pl.plot(x[leftlocs], yCorrected[leftlocs], label=&quot;peakl data&quot;)</span>
        <span class="c1"># pl.plot(x[leftMainBeamLocs], yCorrected[leftMainBeamLocs])</span>
        <span class="c1"># pl.plot(x[rightlocs], yCorrected[rightlocs], label=&quot;peakr data&quot;)</span>
        <span class="c1"># pl.plot(x[rightMainBeamLocs], yCorrected[rightMainBeamLocs])</span>
        <span class="c1"># pl.plot(x[leftMainBeamLocs],</span>
        <span class="c1">#         ypeakl, label=&quot;peak fitl: {:.3f} +- {:.3f}&quot;.format(ymin, err_peakl))</span>
        <span class="c1"># pl.plot(x[rightMainBeamLocs], ypeakr,</span>
        <span class="c1">#         label=&quot;peak fitr: {:.3f} +- {:.3f}&quot;.format(ymax, err_peakr))</span>
        <span class="c1"># pl.plot(x[baseLocs], yCorrected[baseLocs], &quot;.&quot;, label=&quot;baselocs&quot;)</span>
        <span class="c1"># pl.plot(x, np.zeros(scanLen))</span>
        <span class="c1"># pl.legend(loc=&quot;best&quot;)</span>
        <span class="c1"># pl.show()</span>
        <span class="c1"># try:</span>
        <span class="c1">#     pl.savefig(saveFolder+&quot;fitted.png&quot;)</span>
        <span class="c1"># except:</span>
        <span class="c1">#     pass</span>
        <span class="c1"># pl.close()</span>
        <span class="c1"># sys.exit()</span>

        <span class="n">msg_wrapper</span><span class="p">(</span><span class="s2">&quot;info&quot;</span><span class="p">,</span> <span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">,</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="n">msg_wrapper</span><span class="p">(</span><span class="s2">&quot;info&quot;</span><span class="p">,</span> <span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">,</span> <span class="s2">&quot;-&quot;</span><span class="o">*</span><span class="mi">30</span><span class="p">)</span>
        <span class="n">msg_wrapper</span><span class="p">(</span><span class="s2">&quot;info&quot;</span><span class="p">,</span> <span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">,</span> <span class="s2">&quot;Fit the peaks.&quot;</span><span class="p">)</span>
        <span class="n">msg_wrapper</span><span class="p">(</span><span class="s2">&quot;info&quot;</span><span class="p">,</span> <span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">,</span><span class="s2">&quot;-&quot;</span><span class="o">*</span><span class="mi">30</span><span class="p">)</span>

        <span class="n">msg</span><span class="o">=</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">peak left: </span><span class="si">{:.3f}</span><span class="s2"> +- </span><span class="si">{:.3f}</span><span class="s2"> K</span><span class="se">\n</span><span class="s2">peak right: </span><span class="si">{:.3f}</span><span class="s2"> +- </span><span class="si">{:.3f}</span><span class="s2"> K</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
            <span class="n">ymin</span><span class="p">,</span> <span class="n">err_peakl</span><span class="p">,</span> <span class="n">ymax</span><span class="p">,</span> <span class="n">err_peakr</span><span class="p">)</span>
        <span class="n">msg_wrapper</span><span class="p">(</span><span class="s2">&quot;info&quot;</span><span class="p">,</span> <span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">,</span> <span class="n">msg</span><span class="p">)</span>
      
        <span class="c1"># find final peak loc</span>
        <span class="n">ploca</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">ypeakl</span> <span class="o">==</span> <span class="n">ymin</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">ploca</span><span class="p">)</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span>
            <span class="n">peakLoca</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">peakLoca</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">leftMainBeamLocs</span><span class="p">])[</span><span class="n">ploca</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>

        <span class="c1"># find final peak loc</span>
        <span class="n">plocb</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">ypeakr</span> <span class="o">==</span> <span class="n">ymax</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> 
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">plocb</span><span class="p">)</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span>    
            <span class="n">peakLocb</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">peakLocb</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">rightMainBeamLocs</span><span class="p">])[</span><span class="n">plocb</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>

        <span class="k">return</span> <span class="p">{</span><span class="s2">&quot;correctedData&quot;</span><span class="p">:</span><span class="n">yCorrected</span><span class="p">,</span><span class="s2">&quot;driftRes&quot;</span><span class="p">:</span><span class="n">driftRes</span><span class="p">,</span><span class="s2">&quot;driftRms&quot;</span><span class="p">:</span><span class="n">driftRms</span><span class="p">,</span>
                        <span class="s2">&quot;driftCoeffs&quot;</span><span class="p">:</span><span class="n">driftCoeffs</span><span class="p">,</span> <span class="s2">&quot;baseLocsCombined&quot;</span><span class="p">:</span><span class="n">baseLocs</span><span class="p">,</span>
                        <span class="s2">&quot;baseLocsLeft&quot;</span><span class="p">:</span><span class="n">leftMainBeamLocs</span><span class="p">,</span><span class="s2">&quot;baseLocsRight&quot;</span><span class="p">:</span><span class="n">rightMainBeamLocs</span><span class="p">,</span>
                    <span class="s2">&quot;leftPeakData&quot;</span><span class="p">:</span><span class="n">ypeakldata</span><span class="p">,</span><span class="s2">&quot;leftPeakModelData&quot;</span><span class="p">:</span><span class="n">ypeakl</span><span class="p">,</span>
                    <span class="s2">&quot;leftPeakFit&quot;</span><span class="p">:</span><span class="n">ymax</span><span class="p">,</span> <span class="s2">&quot;leftPeakFitErr&quot;</span><span class="p">:</span><span class="n">err_peakl</span><span class="p">,</span><span class="s2">&quot;leftPeakFitRes&quot;</span><span class="p">:</span><span class="n">fitResl</span><span class="p">,</span>
                    <span class="s2">&quot;rightPeakData&quot;</span><span class="p">:</span><span class="n">ypeakrdata</span><span class="p">,</span><span class="s2">&quot;rightPeakModelData&quot;</span><span class="p">:</span><span class="n">ypeakr</span><span class="p">,</span>
                    <span class="s2">&quot;rightPeakFit&quot;</span><span class="p">:</span><span class="n">ymin</span><span class="p">,</span> <span class="s2">&quot;rightPeakFitErr&quot;</span><span class="p">:</span><span class="n">err_peakr</span><span class="p">,</span><span class="s2">&quot;rightPeakFitRes&quot;</span><span class="p">:</span><span class="n">fitResr</span><span class="p">,</span>
                    <span class="s2">&quot;msg&quot;</span><span class="p">:</span><span class="s2">&quot;&quot;</span><span class="p">,</span><span class="s2">&quot;midXValueLeft&quot;</span><span class="p">:</span><span class="n">peakLoca</span><span class="p">,</span><span class="s2">&quot;midXValueRight&quot;</span><span class="p">:</span><span class="n">peakLocb</span><span class="p">,</span>
                    <span class="s2">&quot;flag&quot;</span><span class="p">:</span><span class="n">flag</span>
                    <span class="p">}</span></div>

                   
        <span class="c1"># return yCorrected, driftRes, driftRms, driftCoeffs[0], baseLocs, \</span>
        <span class="c1">#     ypeakldata, ypeakl, ymin, err_peakl, fitResl, \</span>
        <span class="c1">#     ypeakrdata, ypeakr, ymax, err_peakr, fitResr,\</span>
        <span class="c1">#     msg, flag, peakLoca, peakLocb</span>

<div class="viewcode-block" id="get_base">
<a class="viewcode-back" href="../../../docs/src.common.html#src.common.fitting.get_base">[docs]</a>
<span class="k">def</span> <span class="nf">get_base</span><span class="p">(</span><span class="n">localMinPositions</span><span class="p">,</span> <span class="n">block_width</span><span class="p">,</span> <span class="n">scan_len</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; get the baseline block/s from data with large sidelobes. &quot;&quot;&quot;</span>

        <span class="n">base</span><span class="o">=</span><span class="p">[]</span> <span class="c1"># entire basline block points</span>
        <span class="n">localMinPositions</span><span class="o">=</span><span class="nb">sorted</span><span class="p">(</span><span class="n">localMinPositions</span><span class="p">)</span>

        <span class="n">basel</span><span class="o">=</span><span class="p">[]</span> <span class="c1"># left baseline blocks</span>
        <span class="n">baser</span><span class="o">=</span><span class="p">[]</span> <span class="c1"># right baseline blocks</span>
        <span class="n">lp</span><span class="o">=</span><span class="p">[]</span>
        <span class="n">rp</span><span class="o">=</span><span class="p">[]</span>
        <span class="n">basell</span><span class="o">=</span><span class="p">[]</span>
        <span class="n">baserr</span><span class="o">=</span><span class="p">[]</span>

        <span class="n">ind</span><span class="o">=</span><span class="mi">4</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">localMinPositions</span><span class="p">)):</span>

            <span class="c1">#print(localMinPositions[i], block_width)</span>

            <span class="k">if</span> <span class="n">localMinPositions</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">&lt;=</span><span class="n">block_width</span><span class="p">:</span>
                <span class="c1"># get everything before and after</span>
                <span class="c1"># print(&quot;0&quot;,localMinPositions[i], block_width+localMinPositions[i])</span>
                <span class="n">base</span><span class="o">=</span><span class="n">base</span><span class="o">+</span><span class="nb">list</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">block_width</span><span class="o">+</span><span class="n">localMinPositions</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span>

                <span class="k">if</span> <span class="n">localMinPositions</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">scan_len</span><span class="o">/</span><span class="mi">2</span><span class="p">:</span>
                    <span class="n">basel</span> <span class="o">=</span> <span class="n">basel</span><span class="o">+</span><span class="nb">list</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">block_width</span><span class="o">+</span><span class="n">localMinPositions</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span>

                    <span class="n">lp</span><span class="o">=</span><span class="n">lp</span><span class="o">+</span><span class="p">[</span><span class="n">localMinPositions</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span>
                    <span class="c1">#print(&quot;1- &quot;,localMinPositions[i])</span>
                    <span class="n">basell</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
                    <span class="n">basell</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">block_width</span><span class="o">+</span><span class="n">localMinPositions</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
                
                <span class="k">elif</span> <span class="n">localMinPositions</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">scan_len</span><span class="o">/</span><span class="mi">2</span><span class="p">:</span>
                    <span class="n">baser</span> <span class="o">=</span> <span class="n">baser</span> <span class="o">+</span> \
                        <span class="nb">list</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">block_width</span><span class="o">+</span><span class="n">localMinPositions</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span>
                    
                    <span class="n">rp</span><span class="o">=</span><span class="n">rp</span><span class="o">+</span><span class="p">[</span><span class="n">localMinPositions</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span>
                    <span class="c1">#print(&quot;2+ &quot;, localMinPositions[i])</span>
                    <span class="n">baserr</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
                    <span class="n">baserr</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">block_width</span><span class="o">+</span><span class="n">localMinPositions</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>

            <span class="k">elif</span> <span class="n">localMinPositions</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">&gt;=</span><span class="n">scan_len</span><span class="o">-</span><span class="n">block_width</span><span class="p">:</span>
                <span class="c1"># get everything before and after</span>
                <span class="c1">#print(localMinPositions[i]-block_width, localMinPositions[i], scan_len)</span>
                <span class="n">base</span><span class="o">=</span><span class="n">base</span><span class="o">+</span><span class="nb">list</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">localMinPositions</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-</span><span class="n">block_width</span><span class="p">,</span><span class="n">scan_len</span><span class="p">))</span>

                <span class="k">if</span> <span class="n">localMinPositions</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">scan_len</span><span class="o">/</span><span class="mi">2</span><span class="p">:</span>
                    <span class="n">basel</span> <span class="o">=</span> <span class="n">basel</span><span class="o">+</span><span class="nb">list</span><span class="p">(</span>
                            <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">localMinPositions</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-</span><span class="n">block_width</span><span class="p">,</span> <span class="n">scan_len</span><span class="p">))</span>
                    <span class="n">lp</span><span class="o">=</span><span class="n">lp</span><span class="o">+</span><span class="p">[</span><span class="n">localMinPositions</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span>
                    <span class="c1">#print(&quot;3- &quot;, localMinPositions[i])</span>
                    <span class="n">basell</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">localMinPositions</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-</span><span class="n">block_width</span><span class="p">)</span>
                    <span class="n">basell</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">scan_len</span><span class="p">)</span>

                <span class="k">elif</span> <span class="n">localMinPositions</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">scan_len</span><span class="o">/</span><span class="mi">2</span><span class="p">:</span>
                    <span class="n">baser</span> <span class="o">=</span> <span class="n">baser</span><span class="o">+</span><span class="nb">list</span><span class="p">(</span>
                        <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">localMinPositions</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-</span><span class="n">block_width</span><span class="p">,</span> <span class="n">scan_len</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span>
                    
                    <span class="n">baserr</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">localMinPositions</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-</span><span class="n">block_width</span><span class="p">)</span>
                    <span class="n">baserr</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">scan_len</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
                    <span class="n">rp</span> <span class="o">=</span> <span class="n">rp</span><span class="o">+</span><span class="p">[</span><span class="n">localMinPositions</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span>
                    <span class="c1">#print(&quot;4+ &quot;, localMinPositions[i])</span>

            <span class="k">else</span><span class="p">:</span>
                
                <span class="c1">#print(localMinPositions[i]-block_width, localMinPositions[i], block_width+localMinPositions[i])</span>
                
                <span class="n">base</span><span class="o">=</span><span class="n">base</span><span class="o">+</span><span class="nb">list</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">localMinPositions</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-</span><span class="n">block_width</span><span class="p">,</span><span class="n">block_width</span><span class="o">+</span><span class="n">localMinPositions</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span>

                <span class="k">if</span> <span class="n">localMinPositions</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">scan_len</span><span class="o">/</span><span class="mi">2</span><span class="p">:</span>

                    <span class="c1">#print(&quot;5- &quot;, localMinPositions[i])</span>

                    <span class="n">basel</span><span class="o">=</span><span class="n">basel</span><span class="o">+</span><span class="nb">list</span><span class="p">(</span>
                            <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">localMinPositions</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-</span><span class="n">block_width</span><span class="p">,</span> <span class="n">block_width</span><span class="o">+</span><span class="n">localMinPositions</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span>

                    <span class="c1">#print(&quot;6- &quot;,lp,localMinPositions[i])</span>
                    <span class="n">lp</span> <span class="o">=</span> <span class="n">lp</span><span class="o">+</span><span class="p">[</span><span class="n">localMinPositions</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span>

                    <span class="n">basell</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">localMinPositions</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-</span><span class="n">block_width</span><span class="p">)</span>
                    <span class="n">basell</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">block_width</span><span class="o">+</span><span class="n">localMinPositions</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>

                <span class="k">elif</span> <span class="n">localMinPositions</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">scan_len</span><span class="o">/</span><span class="mi">2</span><span class="p">:</span>
                        <span class="n">baser</span><span class="o">=</span> <span class="n">baser</span><span class="o">+</span><span class="nb">list</span><span class="p">(</span>
                        <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">localMinPositions</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-</span><span class="n">block_width</span><span class="p">,</span> <span class="n">block_width</span><span class="o">+</span><span class="n">localMinPositions</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span>
                        
                        <span class="n">rp</span> <span class="o">=</span> <span class="n">rp</span><span class="o">+</span><span class="p">[</span><span class="n">localMinPositions</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span>
                    
                        <span class="n">end</span> <span class="o">=</span> <span class="n">block_width</span><span class="o">+</span><span class="n">localMinPositions</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                        <span class="n">baserr</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">localMinPositions</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-</span><span class="n">block_width</span><span class="p">)</span>

                        <span class="k">if</span> <span class="n">end</span> <span class="o">&gt;=</span><span class="n">scan_len</span><span class="p">:</span>

                            <span class="n">baserr</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">scan_len</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">base</span><span class="p">,</span> <span class="n">basel</span><span class="p">,</span><span class="n">baser</span><span class="p">,</span><span class="n">basell</span><span class="p">,</span><span class="n">baserr</span><span class="p">,</span><span class="n">lp</span><span class="p">,</span><span class="n">rp</span></div>


<span class="c1"># GUI operation</span>
<div class="viewcode-block" id="get_base_pts">
<a class="viewcode-back" href="../../../docs/src.common.html#src.common.fitting.get_base_pts">[docs]</a>
<span class="k">def</span> <span class="nf">get_base_pts</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">base_index_list</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot; Get baseline points from a list of </span>
<span class="sd">        indexes.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># Get data between the indexes selected</span>
    <span class="n">ind_list</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">base_index_list</span><span class="p">)</span>

    <span class="c1"># get location of all points</span>
    <span class="n">xb_data</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">yb_data</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">ind_list</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
        <span class="n">ind_1</span> <span class="o">=</span> <span class="n">ind_list</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">ind_2</span> <span class="o">=</span> <span class="n">ind_list</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="c1">#print(i, i+1, ind_1, ind_2, len(ind_list))</span>
        <span class="n">xb_data</span> <span class="o">=</span> <span class="n">xb_data</span> <span class="o">+</span> <span class="nb">list</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">ind_1</span><span class="p">:</span><span class="n">ind_2</span><span class="p">])</span>
        <span class="n">yb_data</span> <span class="o">=</span> <span class="n">yb_data</span> <span class="o">+</span> <span class="nb">list</span><span class="p">(</span><span class="n">y</span><span class="p">[</span><span class="n">ind_1</span><span class="p">:</span><span class="n">ind_2</span><span class="p">])</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">ind_list</span><span class="p">)):</span>
            <span class="k">if</span> <span class="n">i</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">i</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">ind_1</span> <span class="o">=</span> <span class="n">ind_list</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                <span class="n">ind_2</span> <span class="o">=</span> <span class="n">ind_list</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span>
                <span class="c1">#print(i, i+1, ind_1, ind_2, len(ind_list))</span>
                <span class="n">xb_data</span> <span class="o">=</span> <span class="n">xb_data</span> <span class="o">+</span> <span class="nb">list</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">ind_1</span><span class="p">:</span><span class="n">ind_2</span><span class="p">])</span>
                <span class="n">yb_data</span> <span class="o">=</span> <span class="n">yb_data</span> <span class="o">+</span> <span class="nb">list</span><span class="p">(</span><span class="n">y</span><span class="p">[</span><span class="n">ind_1</span><span class="p">:</span><span class="n">ind_2</span><span class="p">])</span>

    <span class="k">return</span> <span class="n">xb_data</span><span class="p">,</span> <span class="n">yb_data</span></div>


<div class="viewcode-block" id="filter_scans">
<a class="viewcode-back" href="../../../docs/src.common.html#src.common.fitting.filter_scans">[docs]</a>
<span class="k">def</span> <span class="nf">filter_scans</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">window_len</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">window</span><span class="o">=</span><span class="s1">&#39;flat&#39;</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        smooth the data using a window with requested size.</span>
<span class="sd">    </span>
<span class="sd">        This method is based on the convolution of a scaled window with the signal.</span>
<span class="sd">        The signal is prepared by introducing reflected copies of the signal </span>
<span class="sd">        (with the window size) in both ends so that transient parts are minimized</span>
<span class="sd">        in the begining and end part of the output signal.</span>
<span class="sd">        </span>
<span class="sd">        Args:</span>
<span class="sd">            x: the input signal </span>
<span class="sd">            window_len: the dimension of the smoothing window; should be an odd integer</span>
<span class="sd">            window: the type of window from &#39;flat&#39;, &#39;hanning&#39;, &#39;hamming&#39;, &#39;bartlett&#39;, </span>
<span class="sd">                &#39;blackman&#39; flat window will produce a moving average smoothing.</span>

<span class="sd">        Returns:</span>
<span class="sd">            the smoothed signal</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="n">x</span><span class="o">.</span><span class="n">ndim</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">raise</span> <span class="p">(</span><span class="ne">ValueError</span><span class="p">,</span> <span class="s2">&quot;smooth only accepts 1 dimension arrays.&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">x</span><span class="o">.</span><span class="n">size</span> <span class="o">&lt;</span> <span class="n">window_len</span><span class="p">:</span>
        <span class="k">raise</span> <span class="p">(</span><span class="ne">ValueError</span><span class="p">,</span> <span class="s2">&quot;Input vector needs to be bigger than window size.&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">window_len</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">x</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">window</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;flat&#39;</span><span class="p">,</span> <span class="s1">&#39;hanning&#39;</span><span class="p">,</span> <span class="s1">&#39;hamming&#39;</span><span class="p">,</span> <span class="s1">&#39;bartlett&#39;</span><span class="p">,</span> <span class="s1">&#39;blackman&#39;</span><span class="p">]:</span>
        <span class="k">raise</span> <span class="p">(</span>
            <span class="ne">ValueError</span><span class="p">,</span> <span class="s2">&quot;Window is one of &#39;flat&#39;, &#39;hanning&#39;, &#39;hamming&#39;, &#39;bartlett&#39;, &#39;blackman&#39;&quot;</span><span class="p">)</span>

    <span class="n">s</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">r_</span><span class="p">[</span><span class="n">x</span><span class="p">[</span><span class="n">window_len</span><span class="o">-</span><span class="mi">1</span><span class="p">:</span><span class="mi">0</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">x</span><span class="p">,</span> <span class="n">x</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">:</span><span class="o">-</span><span class="n">window_len</span><span class="o">-</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]]</span>

    <span class="k">if</span> <span class="n">window</span> <span class="o">==</span> <span class="s1">&#39;flat&#39;</span><span class="p">:</span>  <span class="c1"># moving average</span>
        <span class="n">w</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">window_len</span><span class="p">,</span> <span class="s1">&#39;d&#39;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">w</span> <span class="o">=</span> <span class="nb">eval</span><span class="p">(</span><span class="s1">&#39;np.&#39;</span><span class="o">+</span><span class="n">window</span><span class="o">+</span><span class="s1">&#39;(window_len)&#39;</span><span class="p">)</span>

    <span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">convolve</span><span class="p">(</span><span class="n">w</span><span class="o">/</span><span class="n">w</span><span class="o">.</span><span class="n">sum</span><span class="p">(),</span> <span class="n">s</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;valid&#39;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">y</span></div>


<div class="viewcode-block" id="fit_poly_peak">
<a class="viewcode-back" href="../../../docs/src.common.html#src.common.fitting.fit_poly_peak">[docs]</a>
<span class="k">def</span> <span class="nf">fit_poly_peak</span><span class="p">(</span><span class="n">xp</span><span class="p">,</span> <span class="n">yp</span><span class="p">,</span> <span class="n">order</span><span class="p">,</span><span class="n">log</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Fit the peak and estimate the errors.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">peakCoeffs</span> <span class="o">=</span> <span class="n">poly_coeff</span><span class="p">(</span><span class="n">xp</span><span class="p">,</span> <span class="n">yp</span><span class="p">,</span> <span class="n">order</span><span class="p">)</span>
    <span class="n">peakModel</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">polyval</span><span class="p">(</span><span class="n">peakCoeffs</span><span class="p">,</span> <span class="n">xp</span><span class="p">)</span>

    <span class="c1"># Calculate the residual and rms of the peak fit</span>
    <span class="n">peakRes</span><span class="p">,</span> <span class="n">peakRms</span> <span class="o">=</span> <span class="n">calc_residual</span><span class="p">(</span><span class="n">peakModel</span><span class="p">,</span> <span class="n">yp</span><span class="p">,</span><span class="n">log</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">peakRes</span><span class="p">,</span> <span class="n">peakRms</span><span class="p">,</span> <span class="n">peakModel</span></div>


</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2024, Pfesesani van Zyl.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>